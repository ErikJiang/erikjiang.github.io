title: "Go笔记之基础数据类型"
date: 2018-08-05 20:32:00
categories: "技术" 
tags: 
  - go
type: "tags"

---

这篇主要是Go的基础数据类型，包含`数值类型`、`布尔类型`、`字符串类型`以及`常量`的相关记录；

<!--more-->


### 数值类型：整数

* 整数类型符：
``` go
// 1. 有符号整数类型
int8、int16、int32、int64

// 2. 无符号整数类型
uint8、uint16、uint32、uint64

// 3. 与CPU平台位数相关的整数类型 （32bit or 64bit）
int、uint   // 等同于int32、uint32 或者 int64、uint64

// 4. unicode字符类型，用于表示Unicode码点
rune    // 等价于int32类型

// 5. 原始数据数值类型
byte    // 等价于uint8类型

// 6. 无符号整数类型指针
uintptr

```

* 算术运算、逻辑运算和比较运算的二元运算符
按照优先级递减的顺序排列 (从左往右从上到下递减)：
``` go
*      /      %      <<       >>     &       &^
+      -      |      ^
==     !=     <      <=       >      >=
&&
||
```

* 二元比较运算符
``` go
==    等于
!=    不等于
<     小于
<=    小于等于
>     大于
>=    大于等于
```

* bit位操作运算符
``` go
&      位运算 AND
|      位运算 OR
^      位运算 XOR
&^     位清空 (AND NOT)
<<     左移
>>     右移
```

### 数值类型：浮点数
* 两种精度浮点数
```
float32 float64
```
* 用于浮点数的格式化输出符
```
%g/G: 大指数（指数 >= 6）使用 %e/%E，其它情况使用 %f/%F
%e/E: 科学计数法（以 10 为底，小写 e/大写 E）
%f/F: 普通小数格式（两者无区别）
```
* 无穷大与非数
```
+Inf: 正无穷大
-Inf: 负无穷大
NaN: 非数
```

### 数值类型：复数
* 两种精度的复数类型：
```
complex64 complex128
```
* 通过complex()函数构建复数
* 使用内建real()及imag()获取复数的实部及虚部；

### 布尔型
布尔型值即`true`和`false`;
* 运算操作短路行为
布尔值可以和&&（AND）和||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值；


### 字符串
字符串是一个不可改变的字节序列,文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列;
* 不变性
因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的；
不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的；

* 转义字符
```
\a      响铃
\b      退格
\f      换页
\n      换行
\r      回车
\t      制表符
\v      垂直制表符
\'      单引号 (只用在 '\'' 形式的rune符号面值中)
\"      双引号 (只用在 "..." 形式的字符串面值中)
\\      反斜杠
\xhh    一个十六进制的转义形式, 其中两个h表示十六进制数字（大写或小写都可以）
\ooo    一个八进制转义形式, 包含三个八进制的o数字（0到7）,但是不能超过\377（译注：对应一个字节的范围，十进制为255）
```

* 原生字符串面值
普通字符串面值使用`""`来包含内容，而原生字符串面值反引号``代替双引号;
在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行;
唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的;
原生字符串面值应用场景：
正则表达式、HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。

* Unicode
Unicode 收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符，还有很多神秘的符号，每个符号都分配一个唯一的Unicode码点，Unicode码点对应Go语言中的rune整数类型（译注：rune是int32等价类型）
优点：涵盖语言符号广；
缺点：浪费很多存储空间；
unicode码点使用rune符文类型，且等价于int32类型，这种编码方式叫UTF-32或UCS-4, 每个码点占用32bit位，而计算机中大多数位ASCII码，每个ASCII字符仅需要8bit位或1字节大小，所以全部使用unicode码点会比较占用存储；

* UTF-8
UTF-8是一个基于Unicode码点编码的可变长编码；是Unicode标准；
UTF-8使用1（8bit）到4(32bit)个字节来表示Unicode码点;
ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表示。每个符号编码后第一个字节的高端bit位用于表示编码总共有多少个字节。
优点：按需使用存储，紧凑，完全兼容ASCII码

* 四种用于处理字符串的标准库包
```
> strings包：
提供了诸如字符串的查询、替换、比较、截断、拆分和合并等功能

> bytes包：
与strings包类似，但针对于 `[]byte` 类型, 使用bytes.Buffer处理更加灵活

> strconv包：
提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换

> unicode包：
提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类
```


### 常量
常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：boolean、string或数字；常量值不可改变；

因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度；

* 批量生成常量
如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的
```
const (
    a = 1
    b
    c = 2
    d
)

fmt.Println(a, b, c, d) // "1 1 2 2"
```
* iota常量生成器

常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一；在其它编程语言中，这种类型一般被称为枚举类型。
```
type Weekday int

const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)
```

* 无类型常量
许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；可以认为至少有256bit的运算精度。有六种未明确类型的常量类型，分别是`无类型的布尔型`、`无类型的整数`、`无类型的字符`、`无类型的浮点数`、`无类型的复数`、`无类型的字符串`;

---
