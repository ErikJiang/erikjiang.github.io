{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1490972714000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1490972714000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1490972714000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1490972714000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1490972714000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1490972714000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1490972714000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1490972714000},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1490972714000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1490972714000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1490972714000},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1490972714000},{"_id":"themes/next/_config.yml","hash":"6e7e7e8ebfba4e7333de39520ceef71f0df80a9d","modified":1492529629000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1490972714000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1490972714000},{"_id":"themes/next/package.json","hash":"7e87b2621104b39a30488654c2a8a0c6a563574b","modified":1490972714000},{"_id":"source/_posts/ChangeNodeVersion.md","hash":"0e586a94c7db76bd10273fa22fb17ee487377910","modified":1491485106000},{"_id":"source/_posts/Booklist2015.md","hash":"2703f120edb3942f4a516fb3756fc929802ad378","modified":1491484652000},{"_id":"source/_posts/BuildingWithGulp.md","hash":"1bd4798c1a946581d8d345c32a0feeb3a52fd54d","modified":1491485085000},{"_id":"source/_posts/CodingWithSSL.md","hash":"641de2a8e478d8bae8d8e960840d65a69525266d","modified":1491485129000},{"_id":"source/_posts/DeployNodeApp.md","hash":"bcbf26ec256e17d19a930d6335020ddc8b880269","modified":1491485158000},{"_id":"source/_posts/HelloWorld.md","hash":"b9c92a13bbd072e6758259bb9c6afefc542a3ebf","modified":1491484737000},{"_id":"source/_posts/ForgetThing.md","hash":"56cae52ed578b01fcd9fd552c87964beae294924","modified":1491484729000},{"_id":"source/_posts/DontLiveInIllusion.md","hash":"10fd3f6f8fd0f249b61852c387e9267745a16266","modified":1491484719000},{"_id":"source/_posts/MountMacSharedDir.md","hash":"2bb8b09d2fb80aa28b3c39f0f1d42cbdf08f7386","modified":1491485196000},{"_id":"source/_posts/MEANNote.md","hash":"e04deb71d7e210722937ba00515df4f1e33087e4","modified":1491485322000},{"_id":"source/_posts/NodeInspector.md","hash":"45d82f8951aea37742e078047374aa43ebda26f8","modified":1491485219000},{"_id":"source/_posts/MoveForward.md","hash":"9b6e27512d8e37a9652bb3320210c29bd9c8d316","modified":1491484770000},{"_id":"source/_posts/ResolveDomain.md","hash":"83c9184a7c9e35c4eb345a0f92a5b4df95fba83c","modified":1491485288000},{"_id":"source/_posts/RedisNote.md","hash":"8148192a088904cc6de4f0fc5bf76326fd89b2cd","modified":1491485266000},{"_id":"source/_posts/NodeSchedule.md","hash":"5fa8b851cb8ee62ec366d37b1ba1e8724f7bdc19","modified":1491485237000},{"_id":"source/_posts/WebSocketNote.md","hash":"94bcfe342d9dae3082df8a7270fd0c38fa17bcc2","modified":1491485302000},{"_id":"source/about/index.md","hash":"99ea49867e7fc38f133a9d346891fa6d58248937","modified":1491484002000},{"_id":"source/about/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1490972714000},{"_id":"source/tags/index.md","hash":"40ae235080fb4a641c1badf488ee7cb6f8fa1f4f","modified":1490972714000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1490972714000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"fdd63b77472612337309eb93ec415a059b90756b","modified":1490972714000},{"_id":"themes/next/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1490972714000},{"_id":"themes/next/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1490972714000},{"_id":"themes/next/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1490972714000},{"_id":"themes/next/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1490972714000},{"_id":"themes/next/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1490972714000},{"_id":"themes/next/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1490972714000},{"_id":"themes/next/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1490972714000},{"_id":"themes/next/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1490972714000},{"_id":"themes/next/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1490972714000},{"_id":"themes/next/languages/ru.yml","hash":"7462c3017dae88e5f80ff308db0b95baf960c83f","modified":1490972714000},{"_id":"themes/next/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1490972714000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"3c0c7dfd0256457ee24df9e9879226c58cb084b5","modified":1490972714000},{"_id":"themes/next/layout/_layout.swig","hash":"909d68b164227fe7601d82e2303bf574eb754172","modified":1490972714000},{"_id":"themes/next/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1490972714000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1490972714000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1490972714000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1490972714000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1490972714000},{"_id":"themes/next/layout/schedule.swig","hash":"234dc8c3b9e276e7811c69011efd5d560519ef19","modified":1490972714000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1490972714000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1490972714000},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1490972714000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1490972714000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1490972714000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1490972714000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1490972714000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490972714000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1490972714000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1490972714000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1490972714000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"b16fcbf0efd20c018d7545257a8533c497ea7647","modified":1490972714000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"d714cbfefc194d48d9d1ebb242476d4d7b72e9d1","modified":1492531552000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1490972714000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1490972714000},{"_id":"themes/next/layout/_macro/post.swig","hash":"640b431eccbbd27f10c6781f33db5ea9a6e064de","modified":1490972714000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"1c7d3c975e499b9aa3119d6724b030b7b00fc87e","modified":1490972714000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1490972714000},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1490972714000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1490972714000},{"_id":"themes/next/layout/_partials/head.swig","hash":"a0eafe24d1dae30c790ae35612154b3ffbbd5cce","modified":1490972714000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1490972714000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1490972714000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1490972714000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1490972714000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9de352a32865869e7ed6863db271c46db5853e5a","modified":1490972714000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1490972714000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1490972714000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1490972714000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1490972714000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1490972714000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1490972714000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1490972714000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1490972714000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1490972714000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1490972714000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1490972714000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1490972714000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1490972714000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1490972714000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1490972714000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1490972714000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1490972714000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1490972714000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1490972714000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1490972714000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1490972714000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1490972714000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1490972714000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1490972714000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1490972714000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490972714000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490972714000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490972714000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490972714000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490972714000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490972714000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490972714000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1490972714000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1490972714000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"2d1075f4cabcb3956b7b84a8e210f5a66f0a5562","modified":1490972714000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1490972714000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1490972714000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1490972714000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1490972714000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1490972714000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1490972714000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1490972714000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1490972714000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1490972714000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1490972714000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1490972714000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1490972714000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1490972714000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1490972714000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"3358d11b9a26185a2d36c96049e4340e701646e4","modified":1490972714000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1490972714000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1490972714000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1490972714000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"a652f202bd5b30c648c228ab8f0e997eb4928e44","modified":1490972714000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1490972714000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1490972714000},{"_id":"themes/next/layout/_third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1490972714000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1490972714000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"abb92620197a16ed2c0775edf18a0f044a82256e","modified":1490972714000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1490972714000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"7240f2e5ec7115f8abbbc4c9ef73d4bed180fdc7","modified":1490972714000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1490972714000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1490972714000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1490972714000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1490972714000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"f4dbd4c896e6510ded8ebe05394c28f8a86e71bf","modified":1490972714000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1490972714000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1490972714000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1490972714000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1490972714000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1490972714000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"e7f4200d26ca89ee6bb96159a0e6c2c2fefca681","modified":1490972714000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1490972714000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1490972714000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1490972714000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1490972714000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1490972714000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1490972714000},{"_id":"themes/next/source/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1490972714000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1490972714000},{"_id":"themes/next/source/js/src/utils.js","hash":"e13c9ccf70d593bdf3b8cc1d768f595abd610e6e","modified":1490972714000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1490972714000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1490972714000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1490972714000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1490972714000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1490972714000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1490972714000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1490972714000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1490972714000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1490972714000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1490972714000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1490972714000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1490972714000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1490972714000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1490972714000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1490972714000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1490972714000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1490972714000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1490972714000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"5b38ae00297ffc07f433c632c3dbf7bde4cdf39a","modified":1490972714000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1490972714000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1490972714000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1490972714000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1490972714000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1490972714000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1490972714000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1490972714000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1490972714000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1490972714000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"7804e31c44717c9a9ddf0f8482b9b9c1a0f74538","modified":1490972714000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1490972714000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1490972714000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1490972714000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1490972714000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1490972714000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1490972714000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1490972714000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1490972714000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1490972714000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1490972714000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1490972714000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1490972714000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1490972714000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1490972714000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1490972714000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1490972714000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1490972714000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1490972714000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1490972714000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1490972714000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1490972714000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1490972714000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1490972714000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"755b04edbbfbdd981a783edb09c9cc34cb79cea7","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b9a2e76f019a5941191f1263b54aef7b69c48789","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"8c0276883398651336853d5ec0e9da267a00dd86","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"48c000163ce191a76e9e5c747c72be5c46930b88","modified":1492529462000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"dd310c2d999185e881db007360176ee2f811df10","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"173490e21bece35a34858e8e534cf86e34561350","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1490972714000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1490972714000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1490972714000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1490972714000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1490972714000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1490972714000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1490972714000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1490972714000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1490972714000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1490972714000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1490972714000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1490972714000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1490972714000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1490972714000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1490972714000},{"_id":"public/content.json","hash":"b68ddd7b101a431734cb1e18e375a52f59aaef39","modified":1492523830379},{"_id":"public/about/index.html","hash":"dffabc6716da009d0b6150212d78d8dfa06aac2c","modified":1492531570842},{"_id":"public/tags/index.html","hash":"7eb1049e8b6b34e19f4cdc095b20d18f12a89cc8","modified":1492531570842},{"_id":"public/2015/04/06/DontLiveInIllusion/index.html","hash":"b79e27c6e90153a4c5ff3d4454aac42a1f5f296b","modified":1492531570843},{"_id":"public/2015/02/04/ForgetThing/index.html","hash":"5a7284c61c65174eaf78ddb8e8c45ee3950cb744","modified":1492531570843},{"_id":"public/2015/01/27/MoveForward/index.html","hash":"d2c7de577263e79c70f79ff4c8409a6f7c2b214f","modified":1492531570843},{"_id":"public/2015/01/23/HelloWorld/index.html","hash":"2988d6d5ea202924284d7ddbb861f363186535a0","modified":1492531570843},{"_id":"public/archives/index.html","hash":"29e780d0a9298309c1f183b62c168b92c8eaadf7","modified":1492531570843},{"_id":"public/archives/page/2/index.html","hash":"1fef46e17cf29f3e6fdc622982a84b0a4f2caf76","modified":1492531570843},{"_id":"public/archives/page/3/index.html","hash":"8c0bd3a332cf88c8a4e09f2710bbcac728375633","modified":1492531570843},{"_id":"public/archives/2015/index.html","hash":"cc6595957a177348b89e9b985e4a9ca29611a353","modified":1492531570843},{"_id":"public/archives/2015/page/2/index.html","hash":"402571fa51642911264d098d47ee0e4e93a075a6","modified":1492531570843},{"_id":"public/archives/2015/01/index.html","hash":"d073049e385966feb655244026f4492adf239a04","modified":1492531570843},{"_id":"public/archives/2015/02/index.html","hash":"815cadef40494b3fea6f4db6ed0d29aa56d8ccf2","modified":1492531570843},{"_id":"public/archives/2015/03/index.html","hash":"092bc5f5e1415b7c459f827629e0d036cb1a8b38","modified":1492531570843},{"_id":"public/archives/2015/04/index.html","hash":"a691f0d232cfc53df3241ce426753ce455ae3cf1","modified":1492531570843},{"_id":"public/archives/2015/05/index.html","hash":"15976a76a777721d073f329ffa09376f55baafe0","modified":1492531570843},{"_id":"public/archives/2015/12/index.html","hash":"b29cdfa43a09f05eaffc63a71991198056eddb0d","modified":1492531570843},{"_id":"public/archives/2016/index.html","hash":"7250de000146dc9248a48a6d3f5951134bee3866","modified":1492531570843},{"_id":"public/archives/2016/01/index.html","hash":"e785fbb072d2d72d9c2469e57b2888b2a69d4695","modified":1492531570843},{"_id":"public/archives/2017/index.html","hash":"f8512f0a5473221012d803ee0a6afa130764e0d8","modified":1492531570843},{"_id":"public/archives/2017/04/index.html","hash":"89e0b6a338431d77e511efa7de9a10da76e1d765","modified":1492531570843},{"_id":"public/categories/技术/index.html","hash":"5d46e2c1bf9be72529ad34ce16ada037846aa4a8","modified":1492531570843},{"_id":"public/categories/技术/page/2/index.html","hash":"6df0dfa80a2e5d924a12b672a7b79851aae452f3","modified":1492531570843},{"_id":"public/categories/技术/page/3/index.html","hash":"cc4e4a9d4fd81c7ef0b41823fbfadc4f1ee2dbf1","modified":1492531570843},{"_id":"public/categories/心情/index.html","hash":"a50db0bfd7bd3fec5193d69943b3e653c458acdd","modified":1492531570843},{"_id":"public/tags/nvm/index.html","hash":"ea71e4b8bed05480db203b0a43f880ceb0c9654e","modified":1492531570844},{"_id":"public/tags/gulp/index.html","hash":"f9ec6710026f3f6d1d7b625bf33219065d28aa60","modified":1492531570844},{"_id":"public/tags/c/index.html","hash":"5b4efaedfcba552062ed67e23018422f46d100c1","modified":1492531570844},{"_id":"public/tags/ssl/index.html","hash":"feca8ec8d4fed2fa63bc1f5ad6e587d375a28f6a","modified":1492531570844},{"_id":"public/tags/mongoLab/index.html","hash":"2136bcbde0964e4b6a04950318f0020553be31d7","modified":1492531570844},{"_id":"public/tags/redis4You/index.html","hash":"f0a5e7e5d47fc37c28027a71133e81048106dd6b","modified":1492531570844},{"_id":"public/tags/heroku/index.html","hash":"952ad1aa2f07c4f63cfeef9f6e6d0ff3f3693a58","modified":1492531570844},{"_id":"public/tags/个人日志/index.html","hash":"dad761c50bd8d09685ce605c8dfc226e358fa981","modified":1492531570844},{"_id":"public/tags/Mac/index.html","hash":"1ec41e8d5ad41231454000cbe999ce76dad5d4bb","modified":1492531570844},{"_id":"public/tags/mount/index.html","hash":"0f2452846c34c22d4e550a154118fc97b6e7b1a0","modified":1492531570844},{"_id":"public/tags/MEAN/index.html","hash":"5e4148b75afca6b8b6f8aac2800352d19ae1ea37","modified":1492531570844},{"_id":"public/tags/node/index.html","hash":"58b7d1fbb53243eb5a747b706c0a417ed3c56147","modified":1492531570844},{"_id":"public/tags/debug/index.html","hash":"ce64ef0afcb23ce4fe9e19a46fd0276c774f4abf","modified":1492531570844},{"_id":"public/tags/DNS/index.html","hash":"2358652f8ef31d48c641e657f2ea37308b5f6ed4","modified":1492531570844},{"_id":"public/tags/redis/index.html","hash":"29908a20b08147a384a2b9676ed13d73832507d4","modified":1492531570844},{"_id":"public/tags/schedule/index.html","hash":"bf7b6467ceeb5a0a6b50ecbb8a21e3d8207555a1","modified":1492531570844},{"_id":"public/tags/cron/index.html","hash":"128d5fb714fd0d3ed151a994dbd0a98f16d6d3f1","modified":1492531570844},{"_id":"public/tags/websocket/index.html","hash":"7703f8d39728a7e7c6303291d3e7666943070215","modified":1492531570844},{"_id":"public/tags/socket-io/index.html","hash":"2c325aa0b553b7a3e8c2c413dfba917c493eded8","modified":1492531570844},{"_id":"public/2017/04/02/NodeSchedule/index.html","hash":"759c7c80a2037480f5cb572e5dec4556ce6b0392","modified":1492531570844},{"_id":"public/2016/01/29/BuildingWithGulp/index.html","hash":"72b96a84c18373489075538acf7791c8f4afb4c0","modified":1492531570844},{"_id":"public/2016/01/19/WebSocketNote/index.html","hash":"8a1e0ff32d3422b4ff927e65b6b58b7c2fc52246","modified":1492531570844},{"_id":"public/2016/01/13/DeployNodeApp/index.html","hash":"b1284369ada1a8c68a4322d5344808c88e15f80d","modified":1492531570844},{"_id":"public/2016/01/05/RedisNote/index.html","hash":"acba0c359bddfa9ff143897cb4b85a84ff4e1bca","modified":1492531570845},{"_id":"public/2015/12/22/ChangeNodeVersion/index.html","hash":"7cec72f49105c43aa37f6fa4c947836c0c80d3f8","modified":1492531570845},{"_id":"public/2015/05/11/NodeInspector/index.html","hash":"c8511573c37a17159d3297541f49b836e938c719","modified":1492531570845},{"_id":"public/2015/04/08/MEANNote/index.html","hash":"4f59f56257ffedb1e42a1a25c30a1e2617a6a0d8","modified":1492531570845},{"_id":"public/2015/04/05/MountMacSharedDir/index.html","hash":"17e3c8eaf9aadf4cbdf0e9752d5bc623781dfa40","modified":1492531570845},{"_id":"public/2015/03/18/ResolveDomain/index.html","hash":"720b4b44506d6850ed1a42bb506a0076a43d31e7","modified":1492531570845},{"_id":"public/2015/03/09/CodingWithSSL/index.html","hash":"4f208965b726fb58eb73c406a314c975341799dd","modified":1492531570845},{"_id":"public/index.html","hash":"865925a5dc0633bd8a64c0d431c77e236ff5f260","modified":1492531570845},{"_id":"public/page/2/index.html","hash":"9dae7986c620449ba791bc9a9a77a58a44da1a0b","modified":1492531570845},{"_id":"public/page/3/index.html","hash":"f34b5cd1398cded990809dfd3ec77b683296e10a","modified":1492531570848}],"Category":[{"name":"技术","_id":"cj1nm18ys0002rmup343n0ir7"},{"name":"心情","_id":"cj1nm194t000nrmuplsj3lgbj"}],"Data":[],"Page":[{"title":"關於","_content":"\n![ink jiang](http://7u2pj1.com1.z0.glb.clouddn.com/About/Head.jpg)\n\n{% iframe http://music.163.com/outchain/player?type=2&id=32977568&auto=1&height=66 [180] [85] %}\n\n----\n\n### 個人信息：\n\n- **網絡暱稱**：Ink Jiang .\n- **年齡區間**：二十來歲 .\n- **目前職業**：服務端程序猿 .\n- **專攻領域**：Node.JS、 Express、 MySQL、 Redis、 LinuxC\n\n---- \n\n### 工作經歷：\n\n> **2015.02～至今**\n> 成都某醫藥行業互聯網公司\n> 從事於服務器後台醫藥業務功能開發\n\n\n> **2013.04～2014.12**\n> 北京某網絡信息安全公司\n> 從事於內網安全接入網關服務器後台研發\n\n\n> **2012.04～2013.01**\n> 北京某通用無線電軟件公司\n> 從事Linux平台下軟件無線電桌面應用控制軟件研發\n\n\n---- \n\n### 聯繫方式：\n\n<jiangink@foxmail.com>\n\n","source":"about/index.md","raw":"title: 關於\n---\n\n![ink jiang](http://7u2pj1.com1.z0.glb.clouddn.com/About/Head.jpg)\n\n{% iframe http://music.163.com/outchain/player?type=2&id=32977568&auto=1&height=66 [180] [85] %}\n\n----\n\n### 個人信息：\n\n- **網絡暱稱**：Ink Jiang .\n- **年齡區間**：二十來歲 .\n- **目前職業**：服務端程序猿 .\n- **專攻領域**：Node.JS、 Express、 MySQL、 Redis、 LinuxC\n\n---- \n\n### 工作經歷：\n\n> **2015.02～至今**\n> 成都某醫藥行業互聯網公司\n> 從事於服務器後台醫藥業務功能開發\n\n\n> **2013.04～2014.12**\n> 北京某網絡信息安全公司\n> 從事於內網安全接入網關服務器後台研發\n\n\n> **2012.04～2013.01**\n> 北京某通用無線電軟件公司\n> 從事Linux平台下軟件無線電桌面應用控制軟件研發\n\n\n---- \n\n### 聯繫方式：\n\n<jiangink@foxmail.com>\n\n","date":"2017-04-06T13:06:42.000Z","updated":"2017-04-06T13:06:42.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj1nm194h000irmuplub1w3gm","content":"<p><img src=\"http://7u2pj1.com1.z0.glb.clouddn.com/About/Head.jpg\" alt=\"ink jiang\"></p>\n<iframe src=\"http://music.163.com/outchain/player?type=2&id=32977568&auto=1&height=66\" width=\"[180]\" height=\"[85]\" frameborder=\"0\" allowfullscreen></iframe>\n<hr>\n<h3 id=\"個人信息：\"><a href=\"#個人信息：\" class=\"headerlink\" title=\"個人信息：\"></a>個人信息：</h3><ul>\n<li><strong>網絡暱稱</strong>：Ink Jiang .</li>\n<li><strong>年齡區間</strong>：二十來歲 .</li>\n<li><strong>目前職業</strong>：服務端程序猿 .</li>\n<li><strong>專攻領域</strong>：Node.JS、 Express、 MySQL、 Redis、 LinuxC</li>\n</ul>\n<hr>\n<h3 id=\"工作經歷：\"><a href=\"#工作經歷：\" class=\"headerlink\" title=\"工作經歷：\"></a>工作經歷：</h3><blockquote>\n<p><strong>2015.02～至今</strong><br>成都某醫藥行業互聯網公司<br>從事於服務器後台醫藥業務功能開發</p>\n<p><strong>2013.04～2014.12</strong><br>北京某網絡信息安全公司<br>從事於內網安全接入網關服務器後台研發</p>\n<p><strong>2012.04～2013.01</strong><br>北京某通用無線電軟件公司<br>從事Linux平台下軟件無線電桌面應用控制軟件研發</p>\n</blockquote>\n<hr>\n<h3 id=\"聯繫方式：\"><a href=\"#聯繫方式：\" class=\"headerlink\" title=\"聯繫方式：\"></a>聯繫方式：</h3><p><a href=\"&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#105;&#97;&#110;&#x67;&#105;&#110;&#x6b;&#x40;&#102;&#x6f;&#120;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;\">&#106;&#105;&#97;&#110;&#x67;&#105;&#110;&#x6b;&#x40;&#102;&#x6f;&#120;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a></p>\n","excerpt":"","more":"<p><img src=\"http://7u2pj1.com1.z0.glb.clouddn.com/About/Head.jpg\" alt=\"ink jiang\"></p>\n<iframe src=\"http://music.163.com/outchain/player?type=2&id=32977568&auto=1&height=66\" width=\"[180]\" height=\"[85]\" frameborder=\"0\" allowfullscreen></iframe>\n<hr>\n<h3 id=\"個人信息：\"><a href=\"#個人信息：\" class=\"headerlink\" title=\"個人信息：\"></a>個人信息：</h3><ul>\n<li><strong>網絡暱稱</strong>：Ink Jiang .</li>\n<li><strong>年齡區間</strong>：二十來歲 .</li>\n<li><strong>目前職業</strong>：服務端程序猿 .</li>\n<li><strong>專攻領域</strong>：Node.JS、 Express、 MySQL、 Redis、 LinuxC</li>\n</ul>\n<hr>\n<h3 id=\"工作經歷：\"><a href=\"#工作經歷：\" class=\"headerlink\" title=\"工作經歷：\"></a>工作經歷：</h3><blockquote>\n<p><strong>2015.02～至今</strong><br>成都某醫藥行業互聯網公司<br>從事於服務器後台醫藥業務功能開發</p>\n<p><strong>2013.04～2014.12</strong><br>北京某網絡信息安全公司<br>從事於內網安全接入網關服務器後台研發</p>\n<p><strong>2012.04～2013.01</strong><br>北京某通用無線電軟件公司<br>從事Linux平台下軟件無線電桌面應用控制軟件研發</p>\n</blockquote>\n<hr>\n<h3 id=\"聯繫方式：\"><a href=\"#聯繫方式：\" class=\"headerlink\" title=\"聯繫方式：\"></a>聯繫方式：</h3><p><a href=\"&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#105;&#97;&#110;&#x67;&#105;&#110;&#x6b;&#x40;&#102;&#x6f;&#120;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;\">&#106;&#105;&#97;&#110;&#x67;&#105;&#110;&#x6b;&#x40;&#102;&#x6f;&#120;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a></p>\n"},{"title":"tags","date":"2017-03-30T13:55:26.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-03-30 21:55:26\n---\n","updated":"2017-03-31T15:05:14.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cj1nm194o000krmup8lzufg7s","content":"","excerpt":"","more":""}],"Post":[{"title":"关于Node版本切换","date":"2015-12-22T04:06:55.000Z","type":"tags","_content":"\n今天在安装yeoman时，警告提示node版本过低，那么好吧，咱们就来更新node版本。\n顺带把整个过程梳理一遍，做一个有节操的程序猿。\n\n<!--more-->\n\n---\n\n提到node的安装，就不得不说这个 NVM （ Node Version Manager ）Node版本管理器，\n一般情况下，不建议直接下载node安装程序进行安装，为了便于管理更新频繁的node，\n比较妥当的做法是通过nvm工具进行安装，而nvm工具本身的安装就不多加细究，\n在Mac上的方式是通过homebrew管理工具进行安装的，其他平台可Google寻找答案。\n\n#### NVM的安装及简单使用：\nMac上安装nvm的命令：\n``` bash\n$ brew install nvm\n```\n\n我们可以查看nvm是否正常安装：\n``` bash\n$ nvm —version\n```\n\n如果安装正常，我们可以通过如下命令，查看当前哪些版本可供安装：\n``` bash\n$ nvm ls-remote\n```\n\n然后可以通过下面命令安装指定版本的node：\n``` bash\n$ nvm install <version>\n```\n\n同样我们可以卸载指定版本的node：\n``` bash\n$ nvm uninstall <version>\n```\n查看当前系统中可管理的所有版本node信息：\n``` bash\n$ nvm ls\n```\n\n---\n\n#### Node安装及版本切换：\n\n我这里安装了v0.12.9版本：\n``` bash\n$ nvm install v0.12.9\n#################################################### 100.0%\nNow using node v0.12.9\n```\n\n当前我使用v0.12.9版本即可，但如果此时我需要切换至其它版本，就可以使用如下命令：\n``` bash\n$ nvm use <version>\n```\n\n但是使用 nvm use 命令有一个问题，即只对当前shell窗口生效，\n如果我们此时关闭该shell窗口，重新打开命令行就会发现node的版本又恢复到之前的版本状态；\n所以针对这种状况，我们需要设置一个默认node版本，命令如下：\n``` bash\n$ nvm alias default <version>\n```\n此时打开shell窗口，就会使用默认版本的node执行；\n\n噢，对了，更新了node版本过后，别忘记更新npm：\n``` bash\nnpm install -g npm\n```\n\n\n\n","source":"_posts/ChangeNodeVersion.md","raw":"title: \"关于Node版本切换\"\ndate: 2015-12-22 12:06:55\ncategories: \"技术\"\ntags:\n  - nvm \ntype: \"tags\"\n---\n\n今天在安装yeoman时，警告提示node版本过低，那么好吧，咱们就来更新node版本。\n顺带把整个过程梳理一遍，做一个有节操的程序猿。\n\n<!--more-->\n\n---\n\n提到node的安装，就不得不说这个 NVM （ Node Version Manager ）Node版本管理器，\n一般情况下，不建议直接下载node安装程序进行安装，为了便于管理更新频繁的node，\n比较妥当的做法是通过nvm工具进行安装，而nvm工具本身的安装就不多加细究，\n在Mac上的方式是通过homebrew管理工具进行安装的，其他平台可Google寻找答案。\n\n#### NVM的安装及简单使用：\nMac上安装nvm的命令：\n``` bash\n$ brew install nvm\n```\n\n我们可以查看nvm是否正常安装：\n``` bash\n$ nvm —version\n```\n\n如果安装正常，我们可以通过如下命令，查看当前哪些版本可供安装：\n``` bash\n$ nvm ls-remote\n```\n\n然后可以通过下面命令安装指定版本的node：\n``` bash\n$ nvm install <version>\n```\n\n同样我们可以卸载指定版本的node：\n``` bash\n$ nvm uninstall <version>\n```\n查看当前系统中可管理的所有版本node信息：\n``` bash\n$ nvm ls\n```\n\n---\n\n#### Node安装及版本切换：\n\n我这里安装了v0.12.9版本：\n``` bash\n$ nvm install v0.12.9\n#################################################### 100.0%\nNow using node v0.12.9\n```\n\n当前我使用v0.12.9版本即可，但如果此时我需要切换至其它版本，就可以使用如下命令：\n``` bash\n$ nvm use <version>\n```\n\n但是使用 nvm use 命令有一个问题，即只对当前shell窗口生效，\n如果我们此时关闭该shell窗口，重新打开命令行就会发现node的版本又恢复到之前的版本状态；\n所以针对这种状况，我们需要设置一个默认node版本，命令如下：\n``` bash\n$ nvm alias default <version>\n```\n此时打开shell窗口，就会使用默认版本的node执行；\n\n噢，对了，更新了node版本过后，别忘记更新npm：\n``` bash\nnpm install -g npm\n```\n\n\n\n","slug":"ChangeNodeVersion","published":1,"updated":"2017-04-06T13:25:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1nm18y20000rmupfirf7tbx","content":"<p>今天在安装yeoman时，警告提示node版本过低，那么好吧，咱们就来更新node版本。<br>顺带把整个过程梳理一遍，做一个有节操的程序猿。</p>\n<a id=\"more\"></a>\n<hr>\n<p>提到node的安装，就不得不说这个 NVM （ Node Version Manager ）Node版本管理器，<br>一般情况下，不建议直接下载node安装程序进行安装，为了便于管理更新频繁的node，<br>比较妥当的做法是通过nvm工具进行安装，而nvm工具本身的安装就不多加细究，<br>在Mac上的方式是通过homebrew管理工具进行安装的，其他平台可Google寻找答案。</p>\n<h4 id=\"NVM的安装及简单使用：\"><a href=\"#NVM的安装及简单使用：\" class=\"headerlink\" title=\"NVM的安装及简单使用：\"></a>NVM的安装及简单使用：</h4><p>Mac上安装nvm的命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ brew install nvm</div></pre></td></tr></table></figure></p>\n<p>我们可以查看nvm是否正常安装：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm —version</div></pre></td></tr></table></figure></p>\n<p>如果安装正常，我们可以通过如下命令，查看当前哪些版本可供安装：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm ls-remote</div></pre></td></tr></table></figure></p>\n<p>然后可以通过下面命令安装指定版本的node：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm install &lt;version&gt;</div></pre></td></tr></table></figure></p>\n<p>同样我们可以卸载指定版本的node：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm uninstall &lt;version&gt;</div></pre></td></tr></table></figure></p>\n<p>查看当前系统中可管理的所有版本node信息：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm ls</div></pre></td></tr></table></figure></p>\n<hr>\n<h4 id=\"Node安装及版本切换：\"><a href=\"#Node安装及版本切换：\" class=\"headerlink\" title=\"Node安装及版本切换：\"></a>Node安装及版本切换：</h4><p>我这里安装了v0.12.9版本：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm install v0.12.9</div><div class=\"line\"><span class=\"comment\">#################################################### 100.0%</span></div><div class=\"line\">Now using node v0.12.9</div></pre></td></tr></table></figure></p>\n<p>当前我使用v0.12.9版本即可，但如果此时我需要切换至其它版本，就可以使用如下命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm use &lt;version&gt;</div></pre></td></tr></table></figure></p>\n<p>但是使用 nvm use 命令有一个问题，即只对当前shell窗口生效，<br>如果我们此时关闭该shell窗口，重新打开命令行就会发现node的版本又恢复到之前的版本状态；<br>所以针对这种状况，我们需要设置一个默认node版本，命令如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm <span class=\"built_in\">alias</span> default &lt;version&gt;</div></pre></td></tr></table></figure></p>\n<p>此时打开shell窗口，就会使用默认版本的node执行；</p>\n<p>噢，对了，更新了node版本过后，别忘记更新npm：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g npm</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>今天在安装yeoman时，警告提示node版本过低，那么好吧，咱们就来更新node版本。<br>顺带把整个过程梳理一遍，做一个有节操的程序猿。</p>","more":"<hr>\n<p>提到node的安装，就不得不说这个 NVM （ Node Version Manager ）Node版本管理器，<br>一般情况下，不建议直接下载node安装程序进行安装，为了便于管理更新频繁的node，<br>比较妥当的做法是通过nvm工具进行安装，而nvm工具本身的安装就不多加细究，<br>在Mac上的方式是通过homebrew管理工具进行安装的，其他平台可Google寻找答案。</p>\n<h4 id=\"NVM的安装及简单使用：\"><a href=\"#NVM的安装及简单使用：\" class=\"headerlink\" title=\"NVM的安装及简单使用：\"></a>NVM的安装及简单使用：</h4><p>Mac上安装nvm的命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ brew install nvm</div></pre></td></tr></table></figure></p>\n<p>我们可以查看nvm是否正常安装：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm —version</div></pre></td></tr></table></figure></p>\n<p>如果安装正常，我们可以通过如下命令，查看当前哪些版本可供安装：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm ls-remote</div></pre></td></tr></table></figure></p>\n<p>然后可以通过下面命令安装指定版本的node：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm install &lt;version&gt;</div></pre></td></tr></table></figure></p>\n<p>同样我们可以卸载指定版本的node：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm uninstall &lt;version&gt;</div></pre></td></tr></table></figure></p>\n<p>查看当前系统中可管理的所有版本node信息：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm ls</div></pre></td></tr></table></figure></p>\n<hr>\n<h4 id=\"Node安装及版本切换：\"><a href=\"#Node安装及版本切换：\" class=\"headerlink\" title=\"Node安装及版本切换：\"></a>Node安装及版本切换：</h4><p>我这里安装了v0.12.9版本：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm install v0.12.9</div><div class=\"line\"><span class=\"comment\">#################################################### 100.0%</span></div><div class=\"line\">Now using node v0.12.9</div></pre></td></tr></table></figure></p>\n<p>当前我使用v0.12.9版本即可，但如果此时我需要切换至其它版本，就可以使用如下命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm use &lt;version&gt;</div></pre></td></tr></table></figure></p>\n<p>但是使用 nvm use 命令有一个问题，即只对当前shell窗口生效，<br>如果我们此时关闭该shell窗口，重新打开命令行就会发现node的版本又恢复到之前的版本状态；<br>所以针对这种状况，我们需要设置一个默认node版本，命令如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm <span class=\"built_in\">alias</span> default &lt;version&gt;</div></pre></td></tr></table></figure></p>\n<p>此时打开shell窗口，就会使用默认版本的node执行；</p>\n<p>噢，对了，更新了node版本过后，别忘记更新npm：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g npm</div></pre></td></tr></table></figure></p>"},{"title":"使用 Gulp 构建工程","date":"2016-01-29T09:00:27.000Z","type":"tags","_content":"\ngulp 是什么？\n\n如果你和我一样，曾做过 Linux C 相关开发，一定知道对于 C 一类的工程，都不可缺少一个编译构建工具 Automake ，我们通过在工程中编写 makefile 脚本文件，实现工程代码的检查、编译以及安装等等。\n\n而在如今大前端工程化的背景下，愈来愈强调前端的工作流程，如果有一种工具，能够如 automake 一般，能够帮助我们处理检测、编译、自动发布以及文件压缩、文件Hash、等等事宜，那一定能简化不少工作，而 gulp 即是我所说的这样一种工具。\n\n<!--more-->\n\n---\n\nGulp 是一个基于 Node.js 的流式构建工具，有别与 Grunt 基于 I/O 的构建方式，Grunt 在处理过程中会产生一些中间态的临时文件，而任务会最终基于这些临时文件生成构建后的结果文件。在这个过程中 Grunt 会进行大量的 I/O 读写操作，那么如果遇到大型项目工程，Grunt 的构建处理速度将大大拖长，这也就是为什么 Gulp 渐渐取代 Grunt 的原因之一，如果想了解更多，可以试着阅读 [《 gulp vs grunt 》](http://segmentfault.com/a/1190000002491282 \"gulp vs grunt\") 这篇文章。\n\n由于 Gulp 通过代码优于配置的策略不仅使得任务易于编写，同时也易于维护和阅读。Gulp 基于的 NodeJS 的流，使用管道 Pipe 的概念，这一级的输出作为下一级的输入，中间无需在硬盘上写入任何临时文件和目录，让任务构建的更加迅速。\n\n\n\n### Gulp 的基本安装 ：\n\n这里我默认您已经安装了 Node.js 以及 NPM 包管理工具，首先需要全局安装 Gulp 工具：\n\n\t$ npm install gulp -g\n\t\n然后，需要在已有的项目中安装 gulp 的依赖包（前提是项目中已存在 package.json 文件）：\n\t\n\t$ npm init\t#如果项目中没有 package.json 文件，需要执行此命令生成，有则忽略；\n\t$ npm install gulp --save-dev\t#安装 gulp 依赖包\n\t\n一切顺利，将会发现 package.json 文件中的 devDependencies 项里多了一个 gulp 子项，且 node_modules 中也多了一个 gulp 的依赖包；\n\n\n\n### Gulp 插件的安装 ：\n\n要使用 Gulp 中的功能，必须依赖于 Gulp 的插件，在 Gulp 中每个插件完成一个具体的功能任务，而实际的构建工作往往是多个任务的流程，所以就要涉及到多个插件的安装，那么具体要用到哪些插件呢？这里我大概列出了常用的几项，仅供参考。\n\n* Sass compile (gulp-ruby-sass)\t\t# css 预处理器编译\n* Autoprefixer (gulp-autoprefixer)\t# css 浏览器兼容前缀处理\n* Minify CSS with cssnano (gulp-cssnano)\t# css 文本压缩\n* JSHint (gulp-jshint)\t# JS 代码检测\n* Concatenation (gulp-concat)\t# 代码文本合并\n* Uglify (gulp-uglify)\t# 代码文本压缩\n* Compress images (gulp-imagemin)\t# 图片资源压缩\n* LiveReload (gulp-livereload)\t# 文件变动页面重载\n* Caching of images so only changed images are compressed (gulp-cache)\t# 图片资源缓存\n* Notify of changes (gulp-notify)\t# 任务完成通知提示\n* Clean files for a clean build (del)\t# 清理构建目录及文件\n\n安装方式与安装 Gulp 依赖包命令一致：\n\n\t$ npm install [package-name] --save-dev\n\n### Gulp 任务文件的配置 ：\n\t\n这里我直接使用本人 Github 上的一个聊天室项目 [node_chat](https://github.com/JiangInk/node_chat \"node_chat\") 来进行讲解。\n\t\n\t// 加载插件\n\tvar del = require('del'),\n\t\tgulp = require('gulp'),\n\t\tcache = require('gulp-cache'),\n\t\tjshint = require('gulp-jshint'),\n\t\tconcat = require('gulp-concat'),\n\t\tuglify = require('gulp-uglify'),\n\t\trename = require('gulp-rename'),\n\t\tnotify = require('gulp-notify'),\n\t\tcssnano = require('gulp-cssnano'),\n\t\timagemin = require('gulp-imagemin'),\n\t\tlivereload = require('gulp-livereload'),\n\t\tautoprefixer = require('gulp-autoprefixer');\n\n\t// 设置源路径\n\tvar srcPaths = {\n\t\tscripts: ['./public/javascripts/*.js'],\n\t\timages: './public/images/*',\n\t\tstyles: './public/stylesheets/*.css'\n\t};\n\n\t// 设置目标路径\n\tvar destPaths = {\n\t\tall: './build/**',\n\t\tscripts: './build/script',\n\t\timages: './build/image',\n\t\tstyles: './build/style'\n\t};\n\n\t// 任务：脚本代码验证\n\tgulp.task('analysis', function() {\n\t\treturn gulp.src(srcPaths.scripts)\n\t\t\t.pipe(jshint())\n\t\t\t.pipe(jshint.reporter('default'))\n\t\t\t.pipe(notify({message: 'Analysis task complete.'}));\n\t});\n\n\t// 任务1. 脚本合并与压缩\n\tgulp.task('scripts', ['analysis'], function() {\n\t\treturn gulp.src(srcPaths.scripts)\n\t\t\t.pipe(concat('main.js'))\n\t\t\t.pipe(gulp.dest(destPaths.scripts))\n\t\t\t.pipe(rename({suffix: '.min'}))\n\t\t\t.pipe(uglify())\n\t\t\t.pipe(gulp.dest(destPaths.scripts))\n\t\t\t.pipe(notify({message: 'Scripts task complete.'}));\n\t});\n\n\t// 任务2. 资源图片压缩\n\tgulp.task('images', function() {\n\t\treturn gulp.src(srcPaths.images)\n\t\t\t// 压缩 imagemin 并缓存 cache 图片\n\t\t\t.pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })))\n\t\t\t.pipe(gulp.dest(destPaths.images))\n\t\t\t.pipe(notify({message: 'Images task complete.'}));\n\t});\n\n\t// 任务3. 样式表的压缩\n\tgulp.task('styles', function() {\n\t\treturn gulp.src(srcPaths.styles)\n\t\t\t.pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))\n\t\t\t.pipe(gulp.dest(destPaths.styles))\n\t\t\t.pipe(rename({suffix: '.min'}))\n\t\t\t.pipe(cssnano())\n\t\t\t.pipe(gulp.dest(destPaths.styles))\n\t\t\t.pipe(notify({message: 'Styles task complete.'}));\n\t});\n\n\t// 任务：清理构建目录\n\tgulp.task('clean', function(cb) {\n\t\t// 清空 build 目录\n\t\treturn del([destPaths.scripts, destPaths.images, destPaths.styles], cb);\n\t});\n\n\t// 默认任务\n\tgulp.task('default', ['clean'], function() {\n\t\tgulp.start('scripts', 'images', 'styles');\n\t});\n\n\t// 任务：监听文件变动\n\tgulp.task('watch', function() {\n\t\t// 监听文件变动\n\t\tgulp.watch(srcPaths.scripts, ['scripts']);\n\t\tgulp.watch(srcPaths.images, ['images']);\n\t\tgulp.watch(srcPaths.styles, ['styles']);\n\t\t// 创建 livereload 监听服务\n\t\tlivereload.listen();\n\t\t// 若有改变自动重载刷新\n\t\tgulp.watch([destPaths.all]).on('change', livereload.changed);\n\t});\n\t\n---\n","source":"_posts/BuildingWithGulp.md","raw":"title: \"使用 Gulp 构建工程\"\ndate: 2016-01-29 17:00:27\ncategories: \"技术\"\ntags:\n  - gulp\ntype: \"tags\"\n---\n\ngulp 是什么？\n\n如果你和我一样，曾做过 Linux C 相关开发，一定知道对于 C 一类的工程，都不可缺少一个编译构建工具 Automake ，我们通过在工程中编写 makefile 脚本文件，实现工程代码的检查、编译以及安装等等。\n\n而在如今大前端工程化的背景下，愈来愈强调前端的工作流程，如果有一种工具，能够如 automake 一般，能够帮助我们处理检测、编译、自动发布以及文件压缩、文件Hash、等等事宜，那一定能简化不少工作，而 gulp 即是我所说的这样一种工具。\n\n<!--more-->\n\n---\n\nGulp 是一个基于 Node.js 的流式构建工具，有别与 Grunt 基于 I/O 的构建方式，Grunt 在处理过程中会产生一些中间态的临时文件，而任务会最终基于这些临时文件生成构建后的结果文件。在这个过程中 Grunt 会进行大量的 I/O 读写操作，那么如果遇到大型项目工程，Grunt 的构建处理速度将大大拖长，这也就是为什么 Gulp 渐渐取代 Grunt 的原因之一，如果想了解更多，可以试着阅读 [《 gulp vs grunt 》](http://segmentfault.com/a/1190000002491282 \"gulp vs grunt\") 这篇文章。\n\n由于 Gulp 通过代码优于配置的策略不仅使得任务易于编写，同时也易于维护和阅读。Gulp 基于的 NodeJS 的流，使用管道 Pipe 的概念，这一级的输出作为下一级的输入，中间无需在硬盘上写入任何临时文件和目录，让任务构建的更加迅速。\n\n\n\n### Gulp 的基本安装 ：\n\n这里我默认您已经安装了 Node.js 以及 NPM 包管理工具，首先需要全局安装 Gulp 工具：\n\n\t$ npm install gulp -g\n\t\n然后，需要在已有的项目中安装 gulp 的依赖包（前提是项目中已存在 package.json 文件）：\n\t\n\t$ npm init\t#如果项目中没有 package.json 文件，需要执行此命令生成，有则忽略；\n\t$ npm install gulp --save-dev\t#安装 gulp 依赖包\n\t\n一切顺利，将会发现 package.json 文件中的 devDependencies 项里多了一个 gulp 子项，且 node_modules 中也多了一个 gulp 的依赖包；\n\n\n\n### Gulp 插件的安装 ：\n\n要使用 Gulp 中的功能，必须依赖于 Gulp 的插件，在 Gulp 中每个插件完成一个具体的功能任务，而实际的构建工作往往是多个任务的流程，所以就要涉及到多个插件的安装，那么具体要用到哪些插件呢？这里我大概列出了常用的几项，仅供参考。\n\n* Sass compile (gulp-ruby-sass)\t\t# css 预处理器编译\n* Autoprefixer (gulp-autoprefixer)\t# css 浏览器兼容前缀处理\n* Minify CSS with cssnano (gulp-cssnano)\t# css 文本压缩\n* JSHint (gulp-jshint)\t# JS 代码检测\n* Concatenation (gulp-concat)\t# 代码文本合并\n* Uglify (gulp-uglify)\t# 代码文本压缩\n* Compress images (gulp-imagemin)\t# 图片资源压缩\n* LiveReload (gulp-livereload)\t# 文件变动页面重载\n* Caching of images so only changed images are compressed (gulp-cache)\t# 图片资源缓存\n* Notify of changes (gulp-notify)\t# 任务完成通知提示\n* Clean files for a clean build (del)\t# 清理构建目录及文件\n\n安装方式与安装 Gulp 依赖包命令一致：\n\n\t$ npm install [package-name] --save-dev\n\n### Gulp 任务文件的配置 ：\n\t\n这里我直接使用本人 Github 上的一个聊天室项目 [node_chat](https://github.com/JiangInk/node_chat \"node_chat\") 来进行讲解。\n\t\n\t// 加载插件\n\tvar del = require('del'),\n\t\tgulp = require('gulp'),\n\t\tcache = require('gulp-cache'),\n\t\tjshint = require('gulp-jshint'),\n\t\tconcat = require('gulp-concat'),\n\t\tuglify = require('gulp-uglify'),\n\t\trename = require('gulp-rename'),\n\t\tnotify = require('gulp-notify'),\n\t\tcssnano = require('gulp-cssnano'),\n\t\timagemin = require('gulp-imagemin'),\n\t\tlivereload = require('gulp-livereload'),\n\t\tautoprefixer = require('gulp-autoprefixer');\n\n\t// 设置源路径\n\tvar srcPaths = {\n\t\tscripts: ['./public/javascripts/*.js'],\n\t\timages: './public/images/*',\n\t\tstyles: './public/stylesheets/*.css'\n\t};\n\n\t// 设置目标路径\n\tvar destPaths = {\n\t\tall: './build/**',\n\t\tscripts: './build/script',\n\t\timages: './build/image',\n\t\tstyles: './build/style'\n\t};\n\n\t// 任务：脚本代码验证\n\tgulp.task('analysis', function() {\n\t\treturn gulp.src(srcPaths.scripts)\n\t\t\t.pipe(jshint())\n\t\t\t.pipe(jshint.reporter('default'))\n\t\t\t.pipe(notify({message: 'Analysis task complete.'}));\n\t});\n\n\t// 任务1. 脚本合并与压缩\n\tgulp.task('scripts', ['analysis'], function() {\n\t\treturn gulp.src(srcPaths.scripts)\n\t\t\t.pipe(concat('main.js'))\n\t\t\t.pipe(gulp.dest(destPaths.scripts))\n\t\t\t.pipe(rename({suffix: '.min'}))\n\t\t\t.pipe(uglify())\n\t\t\t.pipe(gulp.dest(destPaths.scripts))\n\t\t\t.pipe(notify({message: 'Scripts task complete.'}));\n\t});\n\n\t// 任务2. 资源图片压缩\n\tgulp.task('images', function() {\n\t\treturn gulp.src(srcPaths.images)\n\t\t\t// 压缩 imagemin 并缓存 cache 图片\n\t\t\t.pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })))\n\t\t\t.pipe(gulp.dest(destPaths.images))\n\t\t\t.pipe(notify({message: 'Images task complete.'}));\n\t});\n\n\t// 任务3. 样式表的压缩\n\tgulp.task('styles', function() {\n\t\treturn gulp.src(srcPaths.styles)\n\t\t\t.pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))\n\t\t\t.pipe(gulp.dest(destPaths.styles))\n\t\t\t.pipe(rename({suffix: '.min'}))\n\t\t\t.pipe(cssnano())\n\t\t\t.pipe(gulp.dest(destPaths.styles))\n\t\t\t.pipe(notify({message: 'Styles task complete.'}));\n\t});\n\n\t// 任务：清理构建目录\n\tgulp.task('clean', function(cb) {\n\t\t// 清空 build 目录\n\t\treturn del([destPaths.scripts, destPaths.images, destPaths.styles], cb);\n\t});\n\n\t// 默认任务\n\tgulp.task('default', ['clean'], function() {\n\t\tgulp.start('scripts', 'images', 'styles');\n\t});\n\n\t// 任务：监听文件变动\n\tgulp.task('watch', function() {\n\t\t// 监听文件变动\n\t\tgulp.watch(srcPaths.scripts, ['scripts']);\n\t\tgulp.watch(srcPaths.images, ['images']);\n\t\tgulp.watch(srcPaths.styles, ['styles']);\n\t\t// 创建 livereload 监听服务\n\t\tlivereload.listen();\n\t\t// 若有改变自动重载刷新\n\t\tgulp.watch([destPaths.all]).on('change', livereload.changed);\n\t});\n\t\n---\n","slug":"BuildingWithGulp","published":1,"updated":"2017-04-06T13:24:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1nm18ya0001rmupzfaslaol","content":"<p>gulp 是什么？</p>\n<p>如果你和我一样，曾做过 Linux C 相关开发，一定知道对于 C 一类的工程，都不可缺少一个编译构建工具 Automake ，我们通过在工程中编写 makefile 脚本文件，实现工程代码的检查、编译以及安装等等。</p>\n<p>而在如今大前端工程化的背景下，愈来愈强调前端的工作流程，如果有一种工具，能够如 automake 一般，能够帮助我们处理检测、编译、自动发布以及文件压缩、文件Hash、等等事宜，那一定能简化不少工作，而 gulp 即是我所说的这样一种工具。</p>\n<a id=\"more\"></a>\n<hr>\n<p>Gulp 是一个基于 Node.js 的流式构建工具，有别与 Grunt 基于 I/O 的构建方式，Grunt 在处理过程中会产生一些中间态的临时文件，而任务会最终基于这些临时文件生成构建后的结果文件。在这个过程中 Grunt 会进行大量的 I/O 读写操作，那么如果遇到大型项目工程，Grunt 的构建处理速度将大大拖长，这也就是为什么 Gulp 渐渐取代 Grunt 的原因之一，如果想了解更多，可以试着阅读 <a href=\"http://segmentfault.com/a/1190000002491282\" title=\"gulp vs grunt\" target=\"_blank\" rel=\"external\">《 gulp vs grunt 》</a> 这篇文章。</p>\n<p>由于 Gulp 通过代码优于配置的策略不仅使得任务易于编写，同时也易于维护和阅读。Gulp 基于的 NodeJS 的流，使用管道 Pipe 的概念，这一级的输出作为下一级的输入，中间无需在硬盘上写入任何临时文件和目录，让任务构建的更加迅速。</p>\n<h3 id=\"Gulp-的基本安装-：\"><a href=\"#Gulp-的基本安装-：\" class=\"headerlink\" title=\"Gulp 的基本安装 ：\"></a>Gulp 的基本安装 ：</h3><p>这里我默认您已经安装了 Node.js 以及 NPM 包管理工具，首先需要全局安装 Gulp 工具：</p>\n<pre><code>$ npm install gulp -g\n</code></pre><p>然后，需要在已有的项目中安装 gulp 的依赖包（前提是项目中已存在 package.json 文件）：</p>\n<pre><code>$ npm init    #如果项目中没有 package.json 文件，需要执行此命令生成，有则忽略；\n$ npm install gulp --save-dev    #安装 gulp 依赖包\n</code></pre><p>一切顺利，将会发现 package.json 文件中的 devDependencies 项里多了一个 gulp 子项，且 node_modules 中也多了一个 gulp 的依赖包；</p>\n<h3 id=\"Gulp-插件的安装-：\"><a href=\"#Gulp-插件的安装-：\" class=\"headerlink\" title=\"Gulp 插件的安装 ：\"></a>Gulp 插件的安装 ：</h3><p>要使用 Gulp 中的功能，必须依赖于 Gulp 的插件，在 Gulp 中每个插件完成一个具体的功能任务，而实际的构建工作往往是多个任务的流程，所以就要涉及到多个插件的安装，那么具体要用到哪些插件呢？这里我大概列出了常用的几项，仅供参考。</p>\n<ul>\n<li>Sass compile (gulp-ruby-sass)        # css 预处理器编译</li>\n<li>Autoprefixer (gulp-autoprefixer)    # css 浏览器兼容前缀处理</li>\n<li>Minify CSS with cssnano (gulp-cssnano)    # css 文本压缩</li>\n<li>JSHint (gulp-jshint)    # JS 代码检测</li>\n<li>Concatenation (gulp-concat)    # 代码文本合并</li>\n<li>Uglify (gulp-uglify)    # 代码文本压缩</li>\n<li>Compress images (gulp-imagemin)    # 图片资源压缩</li>\n<li>LiveReload (gulp-livereload)    # 文件变动页面重载</li>\n<li>Caching of images so only changed images are compressed (gulp-cache)    # 图片资源缓存</li>\n<li>Notify of changes (gulp-notify)    # 任务完成通知提示</li>\n<li>Clean files for a clean build (del)    # 清理构建目录及文件</li>\n</ul>\n<p>安装方式与安装 Gulp 依赖包命令一致：</p>\n<pre><code>$ npm install [package-name] --save-dev\n</code></pre><h3 id=\"Gulp-任务文件的配置-：\"><a href=\"#Gulp-任务文件的配置-：\" class=\"headerlink\" title=\"Gulp 任务文件的配置 ：\"></a>Gulp 任务文件的配置 ：</h3><p>这里我直接使用本人 Github 上的一个聊天室项目 <a href=\"https://github.com/JiangInk/node_chat\" title=\"node_chat\" target=\"_blank\" rel=\"external\">node_chat</a> 来进行讲解。</p>\n<pre><code>// 加载插件\nvar del = require(&apos;del&apos;),\n    gulp = require(&apos;gulp&apos;),\n    cache = require(&apos;gulp-cache&apos;),\n    jshint = require(&apos;gulp-jshint&apos;),\n    concat = require(&apos;gulp-concat&apos;),\n    uglify = require(&apos;gulp-uglify&apos;),\n    rename = require(&apos;gulp-rename&apos;),\n    notify = require(&apos;gulp-notify&apos;),\n    cssnano = require(&apos;gulp-cssnano&apos;),\n    imagemin = require(&apos;gulp-imagemin&apos;),\n    livereload = require(&apos;gulp-livereload&apos;),\n    autoprefixer = require(&apos;gulp-autoprefixer&apos;);\n\n// 设置源路径\nvar srcPaths = {\n    scripts: [&apos;./public/javascripts/*.js&apos;],\n    images: &apos;./public/images/*&apos;,\n    styles: &apos;./public/stylesheets/*.css&apos;\n};\n\n// 设置目标路径\nvar destPaths = {\n    all: &apos;./build/**&apos;,\n    scripts: &apos;./build/script&apos;,\n    images: &apos;./build/image&apos;,\n    styles: &apos;./build/style&apos;\n};\n\n// 任务：脚本代码验证\ngulp.task(&apos;analysis&apos;, function() {\n    return gulp.src(srcPaths.scripts)\n        .pipe(jshint())\n        .pipe(jshint.reporter(&apos;default&apos;))\n        .pipe(notify({message: &apos;Analysis task complete.&apos;}));\n});\n\n// 任务1. 脚本合并与压缩\ngulp.task(&apos;scripts&apos;, [&apos;analysis&apos;], function() {\n    return gulp.src(srcPaths.scripts)\n        .pipe(concat(&apos;main.js&apos;))\n        .pipe(gulp.dest(destPaths.scripts))\n        .pipe(rename({suffix: &apos;.min&apos;}))\n        .pipe(uglify())\n        .pipe(gulp.dest(destPaths.scripts))\n        .pipe(notify({message: &apos;Scripts task complete.&apos;}));\n});\n\n// 任务2. 资源图片压缩\ngulp.task(&apos;images&apos;, function() {\n    return gulp.src(srcPaths.images)\n        // 压缩 imagemin 并缓存 cache 图片\n        .pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })))\n        .pipe(gulp.dest(destPaths.images))\n        .pipe(notify({message: &apos;Images task complete.&apos;}));\n});\n\n// 任务3. 样式表的压缩\ngulp.task(&apos;styles&apos;, function() {\n    return gulp.src(srcPaths.styles)\n        .pipe(autoprefixer(&apos;last 2 version&apos;, &apos;safari 5&apos;, &apos;ie 8&apos;, &apos;ie 9&apos;, &apos;opera 12.1&apos;, &apos;ios 6&apos;, &apos;android 4&apos;))\n        .pipe(gulp.dest(destPaths.styles))\n        .pipe(rename({suffix: &apos;.min&apos;}))\n        .pipe(cssnano())\n        .pipe(gulp.dest(destPaths.styles))\n        .pipe(notify({message: &apos;Styles task complete.&apos;}));\n});\n\n// 任务：清理构建目录\ngulp.task(&apos;clean&apos;, function(cb) {\n    // 清空 build 目录\n    return del([destPaths.scripts, destPaths.images, destPaths.styles], cb);\n});\n\n// 默认任务\ngulp.task(&apos;default&apos;, [&apos;clean&apos;], function() {\n    gulp.start(&apos;scripts&apos;, &apos;images&apos;, &apos;styles&apos;);\n});\n\n// 任务：监听文件变动\ngulp.task(&apos;watch&apos;, function() {\n    // 监听文件变动\n    gulp.watch(srcPaths.scripts, [&apos;scripts&apos;]);\n    gulp.watch(srcPaths.images, [&apos;images&apos;]);\n    gulp.watch(srcPaths.styles, [&apos;styles&apos;]);\n    // 创建 livereload 监听服务\n    livereload.listen();\n    // 若有改变自动重载刷新\n    gulp.watch([destPaths.all]).on(&apos;change&apos;, livereload.changed);\n});\n</code></pre><hr>\n","excerpt":"<p>gulp 是什么？</p>\n<p>如果你和我一样，曾做过 Linux C 相关开发，一定知道对于 C 一类的工程，都不可缺少一个编译构建工具 Automake ，我们通过在工程中编写 makefile 脚本文件，实现工程代码的检查、编译以及安装等等。</p>\n<p>而在如今大前端工程化的背景下，愈来愈强调前端的工作流程，如果有一种工具，能够如 automake 一般，能够帮助我们处理检测、编译、自动发布以及文件压缩、文件Hash、等等事宜，那一定能简化不少工作，而 gulp 即是我所说的这样一种工具。</p>","more":"<hr>\n<p>Gulp 是一个基于 Node.js 的流式构建工具，有别与 Grunt 基于 I/O 的构建方式，Grunt 在处理过程中会产生一些中间态的临时文件，而任务会最终基于这些临时文件生成构建后的结果文件。在这个过程中 Grunt 会进行大量的 I/O 读写操作，那么如果遇到大型项目工程，Grunt 的构建处理速度将大大拖长，这也就是为什么 Gulp 渐渐取代 Grunt 的原因之一，如果想了解更多，可以试着阅读 <a href=\"http://segmentfault.com/a/1190000002491282\" title=\"gulp vs grunt\">《 gulp vs grunt 》</a> 这篇文章。</p>\n<p>由于 Gulp 通过代码优于配置的策略不仅使得任务易于编写，同时也易于维护和阅读。Gulp 基于的 NodeJS 的流，使用管道 Pipe 的概念，这一级的输出作为下一级的输入，中间无需在硬盘上写入任何临时文件和目录，让任务构建的更加迅速。</p>\n<h3 id=\"Gulp-的基本安装-：\"><a href=\"#Gulp-的基本安装-：\" class=\"headerlink\" title=\"Gulp 的基本安装 ：\"></a>Gulp 的基本安装 ：</h3><p>这里我默认您已经安装了 Node.js 以及 NPM 包管理工具，首先需要全局安装 Gulp 工具：</p>\n<pre><code>$ npm install gulp -g\n</code></pre><p>然后，需要在已有的项目中安装 gulp 的依赖包（前提是项目中已存在 package.json 文件）：</p>\n<pre><code>$ npm init    #如果项目中没有 package.json 文件，需要执行此命令生成，有则忽略；\n$ npm install gulp --save-dev    #安装 gulp 依赖包\n</code></pre><p>一切顺利，将会发现 package.json 文件中的 devDependencies 项里多了一个 gulp 子项，且 node_modules 中也多了一个 gulp 的依赖包；</p>\n<h3 id=\"Gulp-插件的安装-：\"><a href=\"#Gulp-插件的安装-：\" class=\"headerlink\" title=\"Gulp 插件的安装 ：\"></a>Gulp 插件的安装 ：</h3><p>要使用 Gulp 中的功能，必须依赖于 Gulp 的插件，在 Gulp 中每个插件完成一个具体的功能任务，而实际的构建工作往往是多个任务的流程，所以就要涉及到多个插件的安装，那么具体要用到哪些插件呢？这里我大概列出了常用的几项，仅供参考。</p>\n<ul>\n<li>Sass compile (gulp-ruby-sass)        # css 预处理器编译</li>\n<li>Autoprefixer (gulp-autoprefixer)    # css 浏览器兼容前缀处理</li>\n<li>Minify CSS with cssnano (gulp-cssnano)    # css 文本压缩</li>\n<li>JSHint (gulp-jshint)    # JS 代码检测</li>\n<li>Concatenation (gulp-concat)    # 代码文本合并</li>\n<li>Uglify (gulp-uglify)    # 代码文本压缩</li>\n<li>Compress images (gulp-imagemin)    # 图片资源压缩</li>\n<li>LiveReload (gulp-livereload)    # 文件变动页面重载</li>\n<li>Caching of images so only changed images are compressed (gulp-cache)    # 图片资源缓存</li>\n<li>Notify of changes (gulp-notify)    # 任务完成通知提示</li>\n<li>Clean files for a clean build (del)    # 清理构建目录及文件</li>\n</ul>\n<p>安装方式与安装 Gulp 依赖包命令一致：</p>\n<pre><code>$ npm install [package-name] --save-dev\n</code></pre><h3 id=\"Gulp-任务文件的配置-：\"><a href=\"#Gulp-任务文件的配置-：\" class=\"headerlink\" title=\"Gulp 任务文件的配置 ：\"></a>Gulp 任务文件的配置 ：</h3><p>这里我直接使用本人 Github 上的一个聊天室项目 <a href=\"https://github.com/JiangInk/node_chat\" title=\"node_chat\">node_chat</a> 来进行讲解。</p>\n<pre><code>// 加载插件\nvar del = require(&apos;del&apos;),\n    gulp = require(&apos;gulp&apos;),\n    cache = require(&apos;gulp-cache&apos;),\n    jshint = require(&apos;gulp-jshint&apos;),\n    concat = require(&apos;gulp-concat&apos;),\n    uglify = require(&apos;gulp-uglify&apos;),\n    rename = require(&apos;gulp-rename&apos;),\n    notify = require(&apos;gulp-notify&apos;),\n    cssnano = require(&apos;gulp-cssnano&apos;),\n    imagemin = require(&apos;gulp-imagemin&apos;),\n    livereload = require(&apos;gulp-livereload&apos;),\n    autoprefixer = require(&apos;gulp-autoprefixer&apos;);\n\n// 设置源路径\nvar srcPaths = {\n    scripts: [&apos;./public/javascripts/*.js&apos;],\n    images: &apos;./public/images/*&apos;,\n    styles: &apos;./public/stylesheets/*.css&apos;\n};\n\n// 设置目标路径\nvar destPaths = {\n    all: &apos;./build/**&apos;,\n    scripts: &apos;./build/script&apos;,\n    images: &apos;./build/image&apos;,\n    styles: &apos;./build/style&apos;\n};\n\n// 任务：脚本代码验证\ngulp.task(&apos;analysis&apos;, function() {\n    return gulp.src(srcPaths.scripts)\n        .pipe(jshint())\n        .pipe(jshint.reporter(&apos;default&apos;))\n        .pipe(notify({message: &apos;Analysis task complete.&apos;}));\n});\n\n// 任务1. 脚本合并与压缩\ngulp.task(&apos;scripts&apos;, [&apos;analysis&apos;], function() {\n    return gulp.src(srcPaths.scripts)\n        .pipe(concat(&apos;main.js&apos;))\n        .pipe(gulp.dest(destPaths.scripts))\n        .pipe(rename({suffix: &apos;.min&apos;}))\n        .pipe(uglify())\n        .pipe(gulp.dest(destPaths.scripts))\n        .pipe(notify({message: &apos;Scripts task complete.&apos;}));\n});\n\n// 任务2. 资源图片压缩\ngulp.task(&apos;images&apos;, function() {\n    return gulp.src(srcPaths.images)\n        // 压缩 imagemin 并缓存 cache 图片\n        .pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })))\n        .pipe(gulp.dest(destPaths.images))\n        .pipe(notify({message: &apos;Images task complete.&apos;}));\n});\n\n// 任务3. 样式表的压缩\ngulp.task(&apos;styles&apos;, function() {\n    return gulp.src(srcPaths.styles)\n        .pipe(autoprefixer(&apos;last 2 version&apos;, &apos;safari 5&apos;, &apos;ie 8&apos;, &apos;ie 9&apos;, &apos;opera 12.1&apos;, &apos;ios 6&apos;, &apos;android 4&apos;))\n        .pipe(gulp.dest(destPaths.styles))\n        .pipe(rename({suffix: &apos;.min&apos;}))\n        .pipe(cssnano())\n        .pipe(gulp.dest(destPaths.styles))\n        .pipe(notify({message: &apos;Styles task complete.&apos;}));\n});\n\n// 任务：清理构建目录\ngulp.task(&apos;clean&apos;, function(cb) {\n    // 清空 build 目录\n    return del([destPaths.scripts, destPaths.images, destPaths.styles], cb);\n});\n\n// 默认任务\ngulp.task(&apos;default&apos;, [&apos;clean&apos;], function() {\n    gulp.start(&apos;scripts&apos;, &apos;images&apos;, &apos;styles&apos;);\n});\n\n// 任务：监听文件变动\ngulp.task(&apos;watch&apos;, function() {\n    // 监听文件变动\n    gulp.watch(srcPaths.scripts, [&apos;scripts&apos;]);\n    gulp.watch(srcPaths.images, [&apos;images&apos;]);\n    gulp.watch(srcPaths.styles, [&apos;styles&apos;]);\n    // 创建 livereload 监听服务\n    livereload.listen();\n    // 若有改变自动重载刷新\n    gulp.watch([destPaths.all]).on(&apos;change&apos;, livereload.changed);\n});\n</code></pre><hr>"},{"title":"SSL编程小札","date":"2015-03-09T14:42:04.000Z","type":"tags","_content":"\n### SSL简介：\n---\n\n安全套接层(Secure Socket Layer，SSL)是一种在两台机器之间提供安全通道的协议。它具有保护传输数据以及识别通信机器的功能。安全通道是透明的，意思就是说它对传输的数据不加变更。客户端与服务器之间的数据是经过加密的，一端写入的数据完全是另一端读取的内容。透明性使得几乎所有基于TCP的协议稍加改动就可以在SSL上运行，非常方便。\n\nSSL最初的版本是由网景(Netscape)设计的，但1996年由于市场份额下滑等因素，网景决定将SSL移交给因特网工程任务组（IETF）进行标准化制定，随后便产生了TLS，也被称作SSL3.1版本；\n\nSSL/TLS的特性确保了通信双方可以进行端点认证(ndpoint authentication)互验对方身份，并保证了数据的消息完整性(message integrity)以及私密性(confidentiality)。\n<!--more-->\n### SSL编程套路：\n---\n\nSSL通信模型采用的是标准C/S结构，因此基于OpenSSL的程序就被分成两个部分：Client和Server。且程序遵循着以下几个重要步骤：\n\n#### OpenSSL初始化\n\n在使用OpenSSL之前，必须进行相应的初始化工作。完成初始化功能的函数原型如下： \n```cpp\nint SSL_library_int(void);              // 初始化SSL算法库函数，调用SSL函数之前必须调用此函数\nvoid OpenSSL_add_all_algorithms(void);  //加载SSL所有算法\nvoid SSL_load_error_strings(void);      //错误信息的初始化  \n```\n在建立SSL连接之前，要为Client和Server分别指定本次连接采用的协议及其版本，目前能够使用的协议版本包括SSLv2、SSLv3、SSLv2/v3和TLSv1.0。SSL连接若要正常建立，则要求Client和Server必须使用相互兼容的协议。\n\n#### 创建CTX\n\n在OpenSSL中，CTX是指SSL会话环境。建立连接时使用不同的协议（ [*详见*](http://www.openssl.org/docs/ssl/SSL_CTX_new.html) ），其CTX也不一样。创建CTX的过程中会依次用到以下OpenSSL函数：\n```cpp\n//客户端、服务端都需要调用的\nSSL_CTX_new()                               //申请SSL会话环境\n//若有验证对方证书的需求，则需调用\nSSL_CTX_set_verify()                        //指定证书验证方式\nSSL_CTX_load_verify_location()              //为SSL会话环境加载本应用所信任的CA证书列表\n//若有加载证书的需求，则需调用\nSSL_CTX_use_certificate_file()              //为SSL会话加载本应用的证书\nSSL_CTX_use_certificate_chain_file()        //为SSL会话加载本应用的证书所属的证书链\nSSL_CTX_set_default_passwd_cb_userdata()    //设置私钥的密码(如果有的话);注：需要在加载私钥之前设置\nSSL_CTX_use_PrivateKey_file()               //为SSL会话加载本应用的私钥\nSSL_CTX_check_private_key()                 //验证所加载的私钥和证书是否相匹配\n```\n\n对于SSL证书的双向认证，这里需要补充的是，可能需要client以及server配置如下的接口函数：\n```cpp\n/* 设置验证证书链的最大长度 */\nvoid SSL_CTX_set_verify_depth(SSL_CTX *ctx,int depth);\n/* SSL_CTX_set_verify的回调函数，需要自己去写实现 */\nint verify_callback(int preverify_ok, X509_STORE_CTX *x509_ctx);\n/* 设置认证的模式及是否开启认证回调 */\nSSL_CTX_set_verify(SSL_CTX* ctx,int mode,int (*verify_callback)(int,X509_STORE_CTX*));\n/* 加载CA证书文件 */\nSSL_CTX_load_verify_locations(SSL_CTX* ctx,const char* CAfile,const char* CApath);\n```\n另外还需要注意认证的模式（ [*详见*](https://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html) ），常用的模式如下：\n\n> 1. SSL_VERIFY_NONE:\n    不会进行证书验证\n> 2. SSL_VERIFY_PEER:\n    要求对方提供证书进行验证的模式，该模式在服务端类似于一种自愿验证的模式，当遇到客户端不提供证书时，是否继续通信可自行决定；但该模式运用于客户端，若服务端无证书则会导致SSL握手失败。\n> 3. SSL_VERIFY_FAIL_IF_NO_PEER_CERT:\n    服务端使用的一种的模式，此模式下，相当于强制验证客户端的证书，若客户端无证书则SSL握手失败。\n\n#### 建立SSL套接字\n\n在此之前要先创建普通的流套接字，完成TCP三次握手，建立普通的TCP连接。然后创建SSL套接字，并将其与流套接字绑定。这一过程中会使用以下几个函数：\n```cpp\nSSL *SSl_new(SSL_CTX *ctx);         //申请一个SSL套接字\nint SSL_set_fd(SSL *ssl,int fd);    //绑定读写套接字\nint SSL_set_rfd(SSL *ssl,int fd);   //绑定只读套接字\nint SSL_set_wfd(SSL *ssl,int fd);   //绑定只写套接字\n```\n\n#### 完成SSL握手\n\n在这一步，我们需要在普通TCP连接的基础上，建立SSL连接。与普通流套接字建立连接的过程类似：\nClient使用函数SSL_connect()发起握手（ *类似于流套接字中用的connect()* ），而Server使用函数SSL_accept()对握手进行响应（ *类似于流套接字中用的accept()* ），从而完成握手过程。两函数原型如下：\n```cpp\nint SSL_connect(SSL *ssl);\nint SSL_accept(SSL *ssl);\n```\n\n#### 鉴别证书信息\n\n握手过程完成以后，Client以及Server通常能够获取到对方的证书信息，并对信息进行鉴别。具体实现中会用到以下函数:\n```cpp\nX509 *SSL_get_peer_certificate(SSL *ssl);   //从SSL套接字中获取对方的证书信息\nX509_NAME *X509_get_subject_name(X509 *a);  //获取证书所有者名字\nX509_NAME *X509_get_issuer_name(X509  *a);  //获取证书颁发者名字\n```\n\n#### 进行数据传输\n\n经过前面的一系列过程后，就可以进行安全的数据传输了。\n在数据传输阶段，需要使用SSL_read( )和SSL_write( )来代替普通流套接字所使用的read( )和write( )函数，以此完成对SSL套接字的读写操作,两个新函数的原型分别如下：\n```cpp\nint SSL_read(SSL *ssl,void *buf,int num);           //从SSL套接字读取数据\nint SSL_write(SSL *ssl,const void *buf,int num);    //向SSL套接字写入数据\n```\n\n#### 会话结束\n\n当Client和Server之间的通信过程完成后，就使用以下函数来释放前面过程中申请的SSL资源： \n```cpp\nint SSL_shutdown(SSL *ssl);         //关闭SSL套接字\nvoid SSl_free(SSL *ssl);            //释放SSL套接字\nvoid SSL_CTX_free(SSL_CTX *ctx);    //释放SSL会话环境\n```\n\n### 具体源码示范：\n\n- [*SSLSocketDemo*](https://github.com/JiangInk/SSLSocketDemo)\n\n---\n\n*本文参考如下资料整理：*\n\n*1. 《SSL与TLS》*\n\n*2. 《[使用OpenSSL API 建立SSL安全通信的一般流程](http://blog.bccn.net/Ping_Fani07/13407)》*\n\n\n","source":"_posts/CodingWithSSL.md","raw":"title: \"SSL编程小札\"\ndate: 2015-03-09 22:42:04\ncategories: \"技术\"  \ntags: \n  - c\n  - ssl \ntype: \"tags\"\n---\n\n### SSL简介：\n---\n\n安全套接层(Secure Socket Layer，SSL)是一种在两台机器之间提供安全通道的协议。它具有保护传输数据以及识别通信机器的功能。安全通道是透明的，意思就是说它对传输的数据不加变更。客户端与服务器之间的数据是经过加密的，一端写入的数据完全是另一端读取的内容。透明性使得几乎所有基于TCP的协议稍加改动就可以在SSL上运行，非常方便。\n\nSSL最初的版本是由网景(Netscape)设计的，但1996年由于市场份额下滑等因素，网景决定将SSL移交给因特网工程任务组（IETF）进行标准化制定，随后便产生了TLS，也被称作SSL3.1版本；\n\nSSL/TLS的特性确保了通信双方可以进行端点认证(ndpoint authentication)互验对方身份，并保证了数据的消息完整性(message integrity)以及私密性(confidentiality)。\n<!--more-->\n### SSL编程套路：\n---\n\nSSL通信模型采用的是标准C/S结构，因此基于OpenSSL的程序就被分成两个部分：Client和Server。且程序遵循着以下几个重要步骤：\n\n#### OpenSSL初始化\n\n在使用OpenSSL之前，必须进行相应的初始化工作。完成初始化功能的函数原型如下： \n```cpp\nint SSL_library_int(void);              // 初始化SSL算法库函数，调用SSL函数之前必须调用此函数\nvoid OpenSSL_add_all_algorithms(void);  //加载SSL所有算法\nvoid SSL_load_error_strings(void);      //错误信息的初始化  \n```\n在建立SSL连接之前，要为Client和Server分别指定本次连接采用的协议及其版本，目前能够使用的协议版本包括SSLv2、SSLv3、SSLv2/v3和TLSv1.0。SSL连接若要正常建立，则要求Client和Server必须使用相互兼容的协议。\n\n#### 创建CTX\n\n在OpenSSL中，CTX是指SSL会话环境。建立连接时使用不同的协议（ [*详见*](http://www.openssl.org/docs/ssl/SSL_CTX_new.html) ），其CTX也不一样。创建CTX的过程中会依次用到以下OpenSSL函数：\n```cpp\n//客户端、服务端都需要调用的\nSSL_CTX_new()                               //申请SSL会话环境\n//若有验证对方证书的需求，则需调用\nSSL_CTX_set_verify()                        //指定证书验证方式\nSSL_CTX_load_verify_location()              //为SSL会话环境加载本应用所信任的CA证书列表\n//若有加载证书的需求，则需调用\nSSL_CTX_use_certificate_file()              //为SSL会话加载本应用的证书\nSSL_CTX_use_certificate_chain_file()        //为SSL会话加载本应用的证书所属的证书链\nSSL_CTX_set_default_passwd_cb_userdata()    //设置私钥的密码(如果有的话);注：需要在加载私钥之前设置\nSSL_CTX_use_PrivateKey_file()               //为SSL会话加载本应用的私钥\nSSL_CTX_check_private_key()                 //验证所加载的私钥和证书是否相匹配\n```\n\n对于SSL证书的双向认证，这里需要补充的是，可能需要client以及server配置如下的接口函数：\n```cpp\n/* 设置验证证书链的最大长度 */\nvoid SSL_CTX_set_verify_depth(SSL_CTX *ctx,int depth);\n/* SSL_CTX_set_verify的回调函数，需要自己去写实现 */\nint verify_callback(int preverify_ok, X509_STORE_CTX *x509_ctx);\n/* 设置认证的模式及是否开启认证回调 */\nSSL_CTX_set_verify(SSL_CTX* ctx,int mode,int (*verify_callback)(int,X509_STORE_CTX*));\n/* 加载CA证书文件 */\nSSL_CTX_load_verify_locations(SSL_CTX* ctx,const char* CAfile,const char* CApath);\n```\n另外还需要注意认证的模式（ [*详见*](https://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html) ），常用的模式如下：\n\n> 1. SSL_VERIFY_NONE:\n    不会进行证书验证\n> 2. SSL_VERIFY_PEER:\n    要求对方提供证书进行验证的模式，该模式在服务端类似于一种自愿验证的模式，当遇到客户端不提供证书时，是否继续通信可自行决定；但该模式运用于客户端，若服务端无证书则会导致SSL握手失败。\n> 3. SSL_VERIFY_FAIL_IF_NO_PEER_CERT:\n    服务端使用的一种的模式，此模式下，相当于强制验证客户端的证书，若客户端无证书则SSL握手失败。\n\n#### 建立SSL套接字\n\n在此之前要先创建普通的流套接字，完成TCP三次握手，建立普通的TCP连接。然后创建SSL套接字，并将其与流套接字绑定。这一过程中会使用以下几个函数：\n```cpp\nSSL *SSl_new(SSL_CTX *ctx);         //申请一个SSL套接字\nint SSL_set_fd(SSL *ssl,int fd);    //绑定读写套接字\nint SSL_set_rfd(SSL *ssl,int fd);   //绑定只读套接字\nint SSL_set_wfd(SSL *ssl,int fd);   //绑定只写套接字\n```\n\n#### 完成SSL握手\n\n在这一步，我们需要在普通TCP连接的基础上，建立SSL连接。与普通流套接字建立连接的过程类似：\nClient使用函数SSL_connect()发起握手（ *类似于流套接字中用的connect()* ），而Server使用函数SSL_accept()对握手进行响应（ *类似于流套接字中用的accept()* ），从而完成握手过程。两函数原型如下：\n```cpp\nint SSL_connect(SSL *ssl);\nint SSL_accept(SSL *ssl);\n```\n\n#### 鉴别证书信息\n\n握手过程完成以后，Client以及Server通常能够获取到对方的证书信息，并对信息进行鉴别。具体实现中会用到以下函数:\n```cpp\nX509 *SSL_get_peer_certificate(SSL *ssl);   //从SSL套接字中获取对方的证书信息\nX509_NAME *X509_get_subject_name(X509 *a);  //获取证书所有者名字\nX509_NAME *X509_get_issuer_name(X509  *a);  //获取证书颁发者名字\n```\n\n#### 进行数据传输\n\n经过前面的一系列过程后，就可以进行安全的数据传输了。\n在数据传输阶段，需要使用SSL_read( )和SSL_write( )来代替普通流套接字所使用的read( )和write( )函数，以此完成对SSL套接字的读写操作,两个新函数的原型分别如下：\n```cpp\nint SSL_read(SSL *ssl,void *buf,int num);           //从SSL套接字读取数据\nint SSL_write(SSL *ssl,const void *buf,int num);    //向SSL套接字写入数据\n```\n\n#### 会话结束\n\n当Client和Server之间的通信过程完成后，就使用以下函数来释放前面过程中申请的SSL资源： \n```cpp\nint SSL_shutdown(SSL *ssl);         //关闭SSL套接字\nvoid SSl_free(SSL *ssl);            //释放SSL套接字\nvoid SSL_CTX_free(SSL_CTX *ctx);    //释放SSL会话环境\n```\n\n### 具体源码示范：\n\n- [*SSLSocketDemo*](https://github.com/JiangInk/SSLSocketDemo)\n\n---\n\n*本文参考如下资料整理：*\n\n*1. 《SSL与TLS》*\n\n*2. 《[使用OpenSSL API 建立SSL安全通信的一般流程](http://blog.bccn.net/Ping_Fani07/13407)》*\n\n\n","slug":"CodingWithSSL","published":1,"updated":"2017-04-06T13:25:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1nm18yy0004rmupgvof88t3","content":"<h3 id=\"SSL简介：\"><a href=\"#SSL简介：\" class=\"headerlink\" title=\"SSL简介：\"></a>SSL简介：</h3><hr>\n<p>安全套接层(Secure Socket Layer，SSL)是一种在两台机器之间提供安全通道的协议。它具有保护传输数据以及识别通信机器的功能。安全通道是透明的，意思就是说它对传输的数据不加变更。客户端与服务器之间的数据是经过加密的，一端写入的数据完全是另一端读取的内容。透明性使得几乎所有基于TCP的协议稍加改动就可以在SSL上运行，非常方便。</p>\n<p>SSL最初的版本是由网景(Netscape)设计的，但1996年由于市场份额下滑等因素，网景决定将SSL移交给因特网工程任务组（IETF）进行标准化制定，随后便产生了TLS，也被称作SSL3.1版本；</p>\n<p>SSL/TLS的特性确保了通信双方可以进行端点认证(ndpoint authentication)互验对方身份，并保证了数据的消息完整性(message integrity)以及私密性(confidentiality)。<br><a id=\"more\"></a></p>\n<h3 id=\"SSL编程套路：\"><a href=\"#SSL编程套路：\" class=\"headerlink\" title=\"SSL编程套路：\"></a>SSL编程套路：</h3><hr>\n<p>SSL通信模型采用的是标准C/S结构，因此基于OpenSSL的程序就被分成两个部分：Client和Server。且程序遵循着以下几个重要步骤：</p>\n<h4 id=\"OpenSSL初始化\"><a href=\"#OpenSSL初始化\" class=\"headerlink\" title=\"OpenSSL初始化\"></a>OpenSSL初始化</h4><p>在使用OpenSSL之前，必须进行相应的初始化工作。完成初始化功能的函数原型如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_library_int</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;              <span class=\"comment\">// 初始化SSL算法库函数，调用SSL函数之前必须调用此函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OpenSSL_add_all_algorithms</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;  <span class=\"comment\">//加载SSL所有算法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SSL_load_error_strings</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;      <span class=\"comment\">//错误信息的初始化</span></div></pre></td></tr></table></figure></p>\n<p>在建立SSL连接之前，要为Client和Server分别指定本次连接采用的协议及其版本，目前能够使用的协议版本包括SSLv2、SSLv3、SSLv2/v3和TLSv1.0。SSL连接若要正常建立，则要求Client和Server必须使用相互兼容的协议。</p>\n<h4 id=\"创建CTX\"><a href=\"#创建CTX\" class=\"headerlink\" title=\"创建CTX\"></a>创建CTX</h4><p>在OpenSSL中，CTX是指SSL会话环境。建立连接时使用不同的协议（ <a href=\"http://www.openssl.org/docs/ssl/SSL_CTX_new.html\" target=\"_blank\" rel=\"external\"><em>详见</em></a> ），其CTX也不一样。创建CTX的过程中会依次用到以下OpenSSL函数：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//客户端、服务端都需要调用的</span></div><div class=\"line\">SSL_CTX_new()                               <span class=\"comment\">//申请SSL会话环境</span></div><div class=\"line\"><span class=\"comment\">//若有验证对方证书的需求，则需调用</span></div><div class=\"line\">SSL_CTX_set_verify()                        <span class=\"comment\">//指定证书验证方式</span></div><div class=\"line\">SSL_CTX_load_verify_location()              <span class=\"comment\">//为SSL会话环境加载本应用所信任的CA证书列表</span></div><div class=\"line\"><span class=\"comment\">//若有加载证书的需求，则需调用</span></div><div class=\"line\">SSL_CTX_use_certificate_file()              <span class=\"comment\">//为SSL会话加载本应用的证书</span></div><div class=\"line\">SSL_CTX_use_certificate_chain_file()        <span class=\"comment\">//为SSL会话加载本应用的证书所属的证书链</span></div><div class=\"line\">SSL_CTX_set_default_passwd_cb_userdata()    <span class=\"comment\">//设置私钥的密码(如果有的话);注：需要在加载私钥之前设置</span></div><div class=\"line\">SSL_CTX_use_PrivateKey_file()               <span class=\"comment\">//为SSL会话加载本应用的私钥</span></div><div class=\"line\">SSL_CTX_check_private_key()                 <span class=\"comment\">//验证所加载的私钥和证书是否相匹配</span></div></pre></td></tr></table></figure></p>\n<p>对于SSL证书的双向认证，这里需要补充的是，可能需要client以及server配置如下的接口函数：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 设置验证证书链的最大长度 */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SSL_CTX_set_verify_depth</span><span class=\"params\">(SSL_CTX *ctx,<span class=\"keyword\">int</span> depth)</span></span>;</div><div class=\"line\"><span class=\"comment\">/* SSL_CTX_set_verify的回调函数，需要自己去写实现 */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">verify_callback</span><span class=\"params\">(<span class=\"keyword\">int</span> preverify_ok, X509_STORE_CTX *x509_ctx)</span></span>;</div><div class=\"line\"><span class=\"comment\">/* 设置认证的模式及是否开启认证回调 */</span></div><div class=\"line\">SSL_CTX_set_verify(SSL_CTX* ctx,<span class=\"keyword\">int</span> mode,<span class=\"keyword\">int</span> (*verify_callback)(<span class=\"keyword\">int</span>,X509_STORE_CTX*));</div><div class=\"line\"><span class=\"comment\">/* 加载CA证书文件 */</span></div><div class=\"line\">SSL_CTX_load_verify_locations(SSL_CTX* ctx,<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* CAfile,<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* CApath);</div></pre></td></tr></table></figure></p>\n<p>另外还需要注意认证的模式（ <a href=\"https://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html\" target=\"_blank\" rel=\"external\"><em>详见</em></a> ），常用的模式如下：</p>\n<blockquote>\n<ol>\n<li>SSL_VERIFY_NONE:<br> 不会进行证书验证</li>\n<li>SSL_VERIFY_PEER:<br> 要求对方提供证书进行验证的模式，该模式在服务端类似于一种自愿验证的模式，当遇到客户端不提供证书时，是否继续通信可自行决定；但该模式运用于客户端，若服务端无证书则会导致SSL握手失败。</li>\n<li>SSL_VERIFY_FAIL_IF_NO_PEER_CERT:<br> 服务端使用的一种的模式，此模式下，相当于强制验证客户端的证书，若客户端无证书则SSL握手失败。</li>\n</ol>\n</blockquote>\n<h4 id=\"建立SSL套接字\"><a href=\"#建立SSL套接字\" class=\"headerlink\" title=\"建立SSL套接字\"></a>建立SSL套接字</h4><p>在此之前要先创建普通的流套接字，完成TCP三次握手，建立普通的TCP连接。然后创建SSL套接字，并将其与流套接字绑定。这一过程中会使用以下几个函数：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">SSL *<span class=\"title\">SSl_new</span><span class=\"params\">(SSL_CTX *ctx)</span></span>;         <span class=\"comment\">//申请一个SSL套接字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_set_fd</span><span class=\"params\">(SSL *ssl,<span class=\"keyword\">int</span> fd)</span></span>;    <span class=\"comment\">//绑定读写套接字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_set_rfd</span><span class=\"params\">(SSL *ssl,<span class=\"keyword\">int</span> fd)</span></span>;   <span class=\"comment\">//绑定只读套接字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_set_wfd</span><span class=\"params\">(SSL *ssl,<span class=\"keyword\">int</span> fd)</span></span>;   <span class=\"comment\">//绑定只写套接字</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"完成SSL握手\"><a href=\"#完成SSL握手\" class=\"headerlink\" title=\"完成SSL握手\"></a>完成SSL握手</h4><p>在这一步，我们需要在普通TCP连接的基础上，建立SSL连接。与普通流套接字建立连接的过程类似：<br>Client使用函数SSL_connect()发起握手（ <em>类似于流套接字中用的connect()</em> ），而Server使用函数SSL_accept()对握手进行响应（ <em>类似于流套接字中用的accept()</em> ），从而完成握手过程。两函数原型如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_connect</span><span class=\"params\">(SSL *ssl)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_accept</span><span class=\"params\">(SSL *ssl)</span></span>;</div></pre></td></tr></table></figure></p>\n<h4 id=\"鉴别证书信息\"><a href=\"#鉴别证书信息\" class=\"headerlink\" title=\"鉴别证书信息\"></a>鉴别证书信息</h4><p>握手过程完成以后，Client以及Server通常能够获取到对方的证书信息，并对信息进行鉴别。具体实现中会用到以下函数:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">X509 *<span class=\"title\">SSL_get_peer_certificate</span><span class=\"params\">(SSL *ssl)</span></span>;   <span class=\"comment\">//从SSL套接字中获取对方的证书信息</span></div><div class=\"line\"><span class=\"function\">X509_NAME *<span class=\"title\">X509_get_subject_name</span><span class=\"params\">(X509 *a)</span></span>;  <span class=\"comment\">//获取证书所有者名字</span></div><div class=\"line\"><span class=\"function\">X509_NAME *<span class=\"title\">X509_get_issuer_name</span><span class=\"params\">(X509  *a)</span></span>;  <span class=\"comment\">//获取证书颁发者名字</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"进行数据传输\"><a href=\"#进行数据传输\" class=\"headerlink\" title=\"进行数据传输\"></a>进行数据传输</h4><p>经过前面的一系列过程后，就可以进行安全的数据传输了。<br>在数据传输阶段，需要使用SSL_read( )和SSL_write( )来代替普通流套接字所使用的read( )和write( )函数，以此完成对SSL套接字的读写操作,两个新函数的原型分别如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_read</span><span class=\"params\">(SSL *ssl,<span class=\"keyword\">void</span> *buf,<span class=\"keyword\">int</span> num)</span></span>;           <span class=\"comment\">//从SSL套接字读取数据</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_write</span><span class=\"params\">(SSL *ssl,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf,<span class=\"keyword\">int</span> num)</span></span>;    <span class=\"comment\">//向SSL套接字写入数据</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"会话结束\"><a href=\"#会话结束\" class=\"headerlink\" title=\"会话结束\"></a>会话结束</h4><p>当Client和Server之间的通信过程完成后，就使用以下函数来释放前面过程中申请的SSL资源：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_shutdown</span><span class=\"params\">(SSL *ssl)</span></span>;         <span class=\"comment\">//关闭SSL套接字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SSl_free</span><span class=\"params\">(SSL *ssl)</span></span>;            <span class=\"comment\">//释放SSL套接字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SSL_CTX_free</span><span class=\"params\">(SSL_CTX *ctx)</span></span>;    <span class=\"comment\">//释放SSL会话环境</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"具体源码示范：\"><a href=\"#具体源码示范：\" class=\"headerlink\" title=\"具体源码示范：\"></a>具体源码示范：</h3><ul>\n<li><a href=\"https://github.com/JiangInk/SSLSocketDemo\" target=\"_blank\" rel=\"external\"><em>SSLSocketDemo</em></a></li>\n</ul>\n<hr>\n<p><em>本文参考如下资料整理：</em></p>\n<p><em>1. 《SSL与TLS》</em></p>\n<p><em>2. 《<a href=\"http://blog.bccn.net/Ping_Fani07/13407\" target=\"_blank\" rel=\"external\">使用OpenSSL API 建立SSL安全通信的一般流程</a>》</em></p>\n","excerpt":"<h3 id=\"SSL简介：\"><a href=\"#SSL简介：\" class=\"headerlink\" title=\"SSL简介：\"></a>SSL简介：</h3><hr>\n<p>安全套接层(Secure Socket Layer，SSL)是一种在两台机器之间提供安全通道的协议。它具有保护传输数据以及识别通信机器的功能。安全通道是透明的，意思就是说它对传输的数据不加变更。客户端与服务器之间的数据是经过加密的，一端写入的数据完全是另一端读取的内容。透明性使得几乎所有基于TCP的协议稍加改动就可以在SSL上运行，非常方便。</p>\n<p>SSL最初的版本是由网景(Netscape)设计的，但1996年由于市场份额下滑等因素，网景决定将SSL移交给因特网工程任务组（IETF）进行标准化制定，随后便产生了TLS，也被称作SSL3.1版本；</p>\n<p>SSL/TLS的特性确保了通信双方可以进行端点认证(ndpoint authentication)互验对方身份，并保证了数据的消息完整性(message integrity)以及私密性(confidentiality)。<br>","more":"</p>\n<h3 id=\"SSL编程套路：\"><a href=\"#SSL编程套路：\" class=\"headerlink\" title=\"SSL编程套路：\"></a>SSL编程套路：</h3><hr>\n<p>SSL通信模型采用的是标准C/S结构，因此基于OpenSSL的程序就被分成两个部分：Client和Server。且程序遵循着以下几个重要步骤：</p>\n<h4 id=\"OpenSSL初始化\"><a href=\"#OpenSSL初始化\" class=\"headerlink\" title=\"OpenSSL初始化\"></a>OpenSSL初始化</h4><p>在使用OpenSSL之前，必须进行相应的初始化工作。完成初始化功能的函数原型如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_library_int</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;              <span class=\"comment\">// 初始化SSL算法库函数，调用SSL函数之前必须调用此函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OpenSSL_add_all_algorithms</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;  <span class=\"comment\">//加载SSL所有算法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SSL_load_error_strings</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;      <span class=\"comment\">//错误信息的初始化</span></div></pre></td></tr></table></figure></p>\n<p>在建立SSL连接之前，要为Client和Server分别指定本次连接采用的协议及其版本，目前能够使用的协议版本包括SSLv2、SSLv3、SSLv2/v3和TLSv1.0。SSL连接若要正常建立，则要求Client和Server必须使用相互兼容的协议。</p>\n<h4 id=\"创建CTX\"><a href=\"#创建CTX\" class=\"headerlink\" title=\"创建CTX\"></a>创建CTX</h4><p>在OpenSSL中，CTX是指SSL会话环境。建立连接时使用不同的协议（ <a href=\"http://www.openssl.org/docs/ssl/SSL_CTX_new.html\"><em>详见</em></a> ），其CTX也不一样。创建CTX的过程中会依次用到以下OpenSSL函数：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//客户端、服务端都需要调用的</span></div><div class=\"line\">SSL_CTX_new()                               <span class=\"comment\">//申请SSL会话环境</span></div><div class=\"line\"><span class=\"comment\">//若有验证对方证书的需求，则需调用</span></div><div class=\"line\">SSL_CTX_set_verify()                        <span class=\"comment\">//指定证书验证方式</span></div><div class=\"line\">SSL_CTX_load_verify_location()              <span class=\"comment\">//为SSL会话环境加载本应用所信任的CA证书列表</span></div><div class=\"line\"><span class=\"comment\">//若有加载证书的需求，则需调用</span></div><div class=\"line\">SSL_CTX_use_certificate_file()              <span class=\"comment\">//为SSL会话加载本应用的证书</span></div><div class=\"line\">SSL_CTX_use_certificate_chain_file()        <span class=\"comment\">//为SSL会话加载本应用的证书所属的证书链</span></div><div class=\"line\">SSL_CTX_set_default_passwd_cb_userdata()    <span class=\"comment\">//设置私钥的密码(如果有的话);注：需要在加载私钥之前设置</span></div><div class=\"line\">SSL_CTX_use_PrivateKey_file()               <span class=\"comment\">//为SSL会话加载本应用的私钥</span></div><div class=\"line\">SSL_CTX_check_private_key()                 <span class=\"comment\">//验证所加载的私钥和证书是否相匹配</span></div></pre></td></tr></table></figure></p>\n<p>对于SSL证书的双向认证，这里需要补充的是，可能需要client以及server配置如下的接口函数：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 设置验证证书链的最大长度 */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SSL_CTX_set_verify_depth</span><span class=\"params\">(SSL_CTX *ctx,<span class=\"keyword\">int</span> depth)</span></span>;</div><div class=\"line\"><span class=\"comment\">/* SSL_CTX_set_verify的回调函数，需要自己去写实现 */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">verify_callback</span><span class=\"params\">(<span class=\"keyword\">int</span> preverify_ok, X509_STORE_CTX *x509_ctx)</span></span>;</div><div class=\"line\"><span class=\"comment\">/* 设置认证的模式及是否开启认证回调 */</span></div><div class=\"line\">SSL_CTX_set_verify(SSL_CTX* ctx,<span class=\"keyword\">int</span> mode,<span class=\"keyword\">int</span> (*verify_callback)(<span class=\"keyword\">int</span>,X509_STORE_CTX*));</div><div class=\"line\"><span class=\"comment\">/* 加载CA证书文件 */</span></div><div class=\"line\">SSL_CTX_load_verify_locations(SSL_CTX* ctx,<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* CAfile,<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* CApath);</div></pre></td></tr></table></figure></p>\n<p>另外还需要注意认证的模式（ <a href=\"https://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html\"><em>详见</em></a> ），常用的模式如下：</p>\n<blockquote>\n<ol>\n<li>SSL_VERIFY_NONE:<br> 不会进行证书验证</li>\n<li>SSL_VERIFY_PEER:<br> 要求对方提供证书进行验证的模式，该模式在服务端类似于一种自愿验证的模式，当遇到客户端不提供证书时，是否继续通信可自行决定；但该模式运用于客户端，若服务端无证书则会导致SSL握手失败。</li>\n<li>SSL_VERIFY_FAIL_IF_NO_PEER_CERT:<br> 服务端使用的一种的模式，此模式下，相当于强制验证客户端的证书，若客户端无证书则SSL握手失败。</li>\n</ol>\n</blockquote>\n<h4 id=\"建立SSL套接字\"><a href=\"#建立SSL套接字\" class=\"headerlink\" title=\"建立SSL套接字\"></a>建立SSL套接字</h4><p>在此之前要先创建普通的流套接字，完成TCP三次握手，建立普通的TCP连接。然后创建SSL套接字，并将其与流套接字绑定。这一过程中会使用以下几个函数：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">SSL *<span class=\"title\">SSl_new</span><span class=\"params\">(SSL_CTX *ctx)</span></span>;         <span class=\"comment\">//申请一个SSL套接字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_set_fd</span><span class=\"params\">(SSL *ssl,<span class=\"keyword\">int</span> fd)</span></span>;    <span class=\"comment\">//绑定读写套接字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_set_rfd</span><span class=\"params\">(SSL *ssl,<span class=\"keyword\">int</span> fd)</span></span>;   <span class=\"comment\">//绑定只读套接字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_set_wfd</span><span class=\"params\">(SSL *ssl,<span class=\"keyword\">int</span> fd)</span></span>;   <span class=\"comment\">//绑定只写套接字</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"完成SSL握手\"><a href=\"#完成SSL握手\" class=\"headerlink\" title=\"完成SSL握手\"></a>完成SSL握手</h4><p>在这一步，我们需要在普通TCP连接的基础上，建立SSL连接。与普通流套接字建立连接的过程类似：<br>Client使用函数SSL_connect()发起握手（ <em>类似于流套接字中用的connect()</em> ），而Server使用函数SSL_accept()对握手进行响应（ <em>类似于流套接字中用的accept()</em> ），从而完成握手过程。两函数原型如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_connect</span><span class=\"params\">(SSL *ssl)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_accept</span><span class=\"params\">(SSL *ssl)</span></span>;</div></pre></td></tr></table></figure></p>\n<h4 id=\"鉴别证书信息\"><a href=\"#鉴别证书信息\" class=\"headerlink\" title=\"鉴别证书信息\"></a>鉴别证书信息</h4><p>握手过程完成以后，Client以及Server通常能够获取到对方的证书信息，并对信息进行鉴别。具体实现中会用到以下函数:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">X509 *<span class=\"title\">SSL_get_peer_certificate</span><span class=\"params\">(SSL *ssl)</span></span>;   <span class=\"comment\">//从SSL套接字中获取对方的证书信息</span></div><div class=\"line\"><span class=\"function\">X509_NAME *<span class=\"title\">X509_get_subject_name</span><span class=\"params\">(X509 *a)</span></span>;  <span class=\"comment\">//获取证书所有者名字</span></div><div class=\"line\"><span class=\"function\">X509_NAME *<span class=\"title\">X509_get_issuer_name</span><span class=\"params\">(X509  *a)</span></span>;  <span class=\"comment\">//获取证书颁发者名字</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"进行数据传输\"><a href=\"#进行数据传输\" class=\"headerlink\" title=\"进行数据传输\"></a>进行数据传输</h4><p>经过前面的一系列过程后，就可以进行安全的数据传输了。<br>在数据传输阶段，需要使用SSL_read( )和SSL_write( )来代替普通流套接字所使用的read( )和write( )函数，以此完成对SSL套接字的读写操作,两个新函数的原型分别如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_read</span><span class=\"params\">(SSL *ssl,<span class=\"keyword\">void</span> *buf,<span class=\"keyword\">int</span> num)</span></span>;           <span class=\"comment\">//从SSL套接字读取数据</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_write</span><span class=\"params\">(SSL *ssl,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf,<span class=\"keyword\">int</span> num)</span></span>;    <span class=\"comment\">//向SSL套接字写入数据</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"会话结束\"><a href=\"#会话结束\" class=\"headerlink\" title=\"会话结束\"></a>会话结束</h4><p>当Client和Server之间的通信过程完成后，就使用以下函数来释放前面过程中申请的SSL资源：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSL_shutdown</span><span class=\"params\">(SSL *ssl)</span></span>;         <span class=\"comment\">//关闭SSL套接字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SSl_free</span><span class=\"params\">(SSL *ssl)</span></span>;            <span class=\"comment\">//释放SSL套接字</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SSL_CTX_free</span><span class=\"params\">(SSL_CTX *ctx)</span></span>;    <span class=\"comment\">//释放SSL会话环境</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"具体源码示范：\"><a href=\"#具体源码示范：\" class=\"headerlink\" title=\"具体源码示范：\"></a>具体源码示范：</h3><ul>\n<li><a href=\"https://github.com/JiangInk/SSLSocketDemo\"><em>SSLSocketDemo</em></a></li>\n</ul>\n<hr>\n<p><em>本文参考如下资料整理：</em></p>\n<p><em>1. 《SSL与TLS》</em></p>\n<p><em>2. 《<a href=\"http://blog.bccn.net/Ping_Fani07/13407\">使用OpenSSL API 建立SSL安全通信的一般流程</a>》</em></p>"},{"title":"NodeJS应用部署初探","date":"2016-01-13T13:13:51.000Z","type":"tags","_content":"\n尝试使用 MongoLab、Redis4You、Heroku 来部署一个 node 应用。\n\n<!--more-->\n\n---\n\n###  首先，使用 MongoLab ：\n\nMongoLab 与 MongoHQ 是当今比较流行的 MongoDB 云数据库提供商。MongoLab 的免费套餐提供了 500MB 的存储空间，MongoLab 的使用比较简单明了，这里简要概述一二。\n\n#### 注册\n\n[mongolab.com/signup](https://mongolab.com/signup/ \"signup\")\n\n#### 创建数据库\n\n注册成功后，此时进入到自己的控制面板页，点击 `Create new` 创建一个数据库。在 `Plan` 选项选择 `Single-node` 的 `Sandbox` 免费套餐。在 `Darebase name` 除填写数据库的名字，点击 `Create new MongoDB deployment` 完成创建。\n\n创建成功后跳转到了控制面板页，点击刚才创建的数据库进入该数据库配置页面。我们需要先为数据库创建一个拥有读写权限的用户，点击 `Click here` 添加一个用户。\n\n打开 mongodb.js ，将：\n\n\tmongoose.connect('mongodb://localhost/drifter', {server: {poolSize: 10}});\n\t\n修改为：\n\n\tmongoose.connect('your_mongolab_url', {server: {poolSize: 10}});\n\t\n注意：将 `<dbuser>` 和 `<dbpassword>` 分别替换为刚才为数据库创建的用户名和密码。\n\n###  然后，使用 Redis4You ：\n\nredis4you 是一家 Redis 云服务提供商，提供多个档次的 Redis 实例供选择，所有类型的服务包括免费的 5M 试用版，都提供诸如多 DB，持久化等功能。这里我们仅供测试使用。\n\n#### 注册\n\n[redis4you.com/login_new](http://redis4you.com/login_new.php \"redis4you.com\")\n\n#### 创建数据库\n\n验证邮箱完成注册。登录 Redis4You，点击右上角的 `My Redis Instanses` 进入 `Redis` 管理页面，点击 `Provision new instance` 创建一个新的数据库。点击 5MB 的免费套餐右边的 `Select this instance` 完成创建。\n\n此时跳转到 Redis 管理页面，点击 `Information` 查看数据库详情。我们只会用到 Host、Port 和 Auth 这三项，其中 Auth 为随机生成的访问数据库的凭证。\n\n注意：一定要点击左上角的 `start` 启动数据库。\n\n打开 redis.js ，将：\n\n\tvar client = redis.createClient();\n\t\n修改为：\n\n\tvar client = redis.createClient(Port, Host, {auth_pass: Auth});\n\t\n注意：将 Host、Port 和 Auth 分别替换为给定的值。\n\t\n###  最后，部署到 HeroKu ：\n\nHeroku 是一个主流的 PaaS 提供商，在开发人员中广受欢迎。这个服务围绕着基于 Git 的工作流设计，假如你熟悉 Git ，那部署就十分简单。这个服务原本是为托管 Ruby 应用程序而设计的，但 Heroku 之后加入了对 Node.js 、Clojure 、Scala 、Python 和 Java 等语言的支持。Heroku 的基础服务是免费的。\n\n#### 注册\n\n[heroku.com](https://www.heroku.com/ \"heroku.com\")\n\n#### 创建一个应用\n\n右上角 “＋” 中点击 `Create a new app` ，填写独一无二的应用名称后，点击 `creat app` 即创建成功，然后点击 `Open app` 即可打开应用 URL 链接 。\n\n#### 安装 Heroku Toolbelt\n\nHeroku 官方提供了 Heroku Toolbelt 工具更方便地部署和管理应用。它包含三个部分：\n\n* Heroku client ：创建和管理 Heroku 应用的命令行工具\n* Foreman ：一个在本地运行你的 app 的不错的选择\n* Git ：分布式版本控制工具，用来把应用推送到 Heroku\n\nHeroku Toolbelt 下载地址：[toolbelt.heroku.com](https://toolbelt.heroku.com/ \"toolbelt.heroku.com\") 。\n\n注意：假如你的电脑上已经安装了 Git ，那么在安装的时候选择 `Custom Installation` 并去掉安装 Git 的选项，否则选择 `Full Installation` 。\n\n安装成功后，打开终端 shell ，输入 `heroku login` ，然后输入在 Heroku 注册的帐号和密码进行登录。Git 会检测是否有 SSH 密钥，如果有，则使用此密钥并上传，如果没有，则创建一个密钥并上传。\n\nTips：SSH 密钥通常用于授予用户访问服务器的权限。可将它们用于某些配置中，以便无需密码即可访问服务器。许多 PaaS 提供商都使用了此功能。\n\n#### Procfile\n\n在工程的根目录下新建一个 Procfile 文件，添加如下内容：\n\n\tweb: ./bin/www\n\t\nProcfile 文件告诉了服务器该使用什么命令启动一个 web 服务，这里我们通过 `./bin/www` 执行 Node 脚本。为什么这里声明了一个 web 类型呢？官方解释为：\n\n> The name “web” is important here. It declares that this process type will be attached to the HTTP routing stack of Heroku, and receive web traffic when deployed.\n\n\n#### 上传应用\n\n首先 clone 一份 git 仓库源码到你的本地机器中；\n\n\t$ heroku git:clone -a web_app_name\n\t$ cd web_app_name\n\t\n使用 git 将源码变动的部分更新以及部署到 heroku 当中.\n\n\t$ git add .\n\t$ git commit -am \"make it better\"\n\t$ git push heroku master\n\n在 push 到 heroku 服务器之前，我们还需要做一个工作。由于我国某些政策的原因，我们需到 ~/.ssh/ 目录下，新建一个 config 文件，内容如下：\n\n\tHost git.heroku.com\n\tUser yourName\n\tHostname 107.21.95.3\n\tPreferredAuthentications publickey\n\tIdentityFile ~/.ssh/id_rsa\n\tport 22\n\t\n然后回到 Git Bash ，输入：\n\n\t$ git push heroku master\n\t\n稍等片刻即上传成功。\n\n---\n\n参考：\n\n* [nswbmw github](https://github.com/nswbmw \"nswbmw\")\n","source":"_posts/DeployNodeApp.md","raw":"title: \"NodeJS应用部署初探\"\ndate: 2016-01-13 21:13:51\ncategories: \"技术\"\ntags: \n  - mongoLab\n  - redis4You\n  - heroku\ntype: \"tags\"\n---\n\n尝试使用 MongoLab、Redis4You、Heroku 来部署一个 node 应用。\n\n<!--more-->\n\n---\n\n###  首先，使用 MongoLab ：\n\nMongoLab 与 MongoHQ 是当今比较流行的 MongoDB 云数据库提供商。MongoLab 的免费套餐提供了 500MB 的存储空间，MongoLab 的使用比较简单明了，这里简要概述一二。\n\n#### 注册\n\n[mongolab.com/signup](https://mongolab.com/signup/ \"signup\")\n\n#### 创建数据库\n\n注册成功后，此时进入到自己的控制面板页，点击 `Create new` 创建一个数据库。在 `Plan` 选项选择 `Single-node` 的 `Sandbox` 免费套餐。在 `Darebase name` 除填写数据库的名字，点击 `Create new MongoDB deployment` 完成创建。\n\n创建成功后跳转到了控制面板页，点击刚才创建的数据库进入该数据库配置页面。我们需要先为数据库创建一个拥有读写权限的用户，点击 `Click here` 添加一个用户。\n\n打开 mongodb.js ，将：\n\n\tmongoose.connect('mongodb://localhost/drifter', {server: {poolSize: 10}});\n\t\n修改为：\n\n\tmongoose.connect('your_mongolab_url', {server: {poolSize: 10}});\n\t\n注意：将 `<dbuser>` 和 `<dbpassword>` 分别替换为刚才为数据库创建的用户名和密码。\n\n###  然后，使用 Redis4You ：\n\nredis4you 是一家 Redis 云服务提供商，提供多个档次的 Redis 实例供选择，所有类型的服务包括免费的 5M 试用版，都提供诸如多 DB，持久化等功能。这里我们仅供测试使用。\n\n#### 注册\n\n[redis4you.com/login_new](http://redis4you.com/login_new.php \"redis4you.com\")\n\n#### 创建数据库\n\n验证邮箱完成注册。登录 Redis4You，点击右上角的 `My Redis Instanses` 进入 `Redis` 管理页面，点击 `Provision new instance` 创建一个新的数据库。点击 5MB 的免费套餐右边的 `Select this instance` 完成创建。\n\n此时跳转到 Redis 管理页面，点击 `Information` 查看数据库详情。我们只会用到 Host、Port 和 Auth 这三项，其中 Auth 为随机生成的访问数据库的凭证。\n\n注意：一定要点击左上角的 `start` 启动数据库。\n\n打开 redis.js ，将：\n\n\tvar client = redis.createClient();\n\t\n修改为：\n\n\tvar client = redis.createClient(Port, Host, {auth_pass: Auth});\n\t\n注意：将 Host、Port 和 Auth 分别替换为给定的值。\n\t\n###  最后，部署到 HeroKu ：\n\nHeroku 是一个主流的 PaaS 提供商，在开发人员中广受欢迎。这个服务围绕着基于 Git 的工作流设计，假如你熟悉 Git ，那部署就十分简单。这个服务原本是为托管 Ruby 应用程序而设计的，但 Heroku 之后加入了对 Node.js 、Clojure 、Scala 、Python 和 Java 等语言的支持。Heroku 的基础服务是免费的。\n\n#### 注册\n\n[heroku.com](https://www.heroku.com/ \"heroku.com\")\n\n#### 创建一个应用\n\n右上角 “＋” 中点击 `Create a new app` ，填写独一无二的应用名称后，点击 `creat app` 即创建成功，然后点击 `Open app` 即可打开应用 URL 链接 。\n\n#### 安装 Heroku Toolbelt\n\nHeroku 官方提供了 Heroku Toolbelt 工具更方便地部署和管理应用。它包含三个部分：\n\n* Heroku client ：创建和管理 Heroku 应用的命令行工具\n* Foreman ：一个在本地运行你的 app 的不错的选择\n* Git ：分布式版本控制工具，用来把应用推送到 Heroku\n\nHeroku Toolbelt 下载地址：[toolbelt.heroku.com](https://toolbelt.heroku.com/ \"toolbelt.heroku.com\") 。\n\n注意：假如你的电脑上已经安装了 Git ，那么在安装的时候选择 `Custom Installation` 并去掉安装 Git 的选项，否则选择 `Full Installation` 。\n\n安装成功后，打开终端 shell ，输入 `heroku login` ，然后输入在 Heroku 注册的帐号和密码进行登录。Git 会检测是否有 SSH 密钥，如果有，则使用此密钥并上传，如果没有，则创建一个密钥并上传。\n\nTips：SSH 密钥通常用于授予用户访问服务器的权限。可将它们用于某些配置中，以便无需密码即可访问服务器。许多 PaaS 提供商都使用了此功能。\n\n#### Procfile\n\n在工程的根目录下新建一个 Procfile 文件，添加如下内容：\n\n\tweb: ./bin/www\n\t\nProcfile 文件告诉了服务器该使用什么命令启动一个 web 服务，这里我们通过 `./bin/www` 执行 Node 脚本。为什么这里声明了一个 web 类型呢？官方解释为：\n\n> The name “web” is important here. It declares that this process type will be attached to the HTTP routing stack of Heroku, and receive web traffic when deployed.\n\n\n#### 上传应用\n\n首先 clone 一份 git 仓库源码到你的本地机器中；\n\n\t$ heroku git:clone -a web_app_name\n\t$ cd web_app_name\n\t\n使用 git 将源码变动的部分更新以及部署到 heroku 当中.\n\n\t$ git add .\n\t$ git commit -am \"make it better\"\n\t$ git push heroku master\n\n在 push 到 heroku 服务器之前，我们还需要做一个工作。由于我国某些政策的原因，我们需到 ~/.ssh/ 目录下，新建一个 config 文件，内容如下：\n\n\tHost git.heroku.com\n\tUser yourName\n\tHostname 107.21.95.3\n\tPreferredAuthentications publickey\n\tIdentityFile ~/.ssh/id_rsa\n\tport 22\n\t\n然后回到 Git Bash ，输入：\n\n\t$ git push heroku master\n\t\n稍等片刻即上传成功。\n\n---\n\n参考：\n\n* [nswbmw github](https://github.com/nswbmw \"nswbmw\")\n","slug":"DeployNodeApp","published":1,"updated":"2017-04-06T13:25:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1nm194f000hrmupqka3eyaz","content":"<p>尝试使用 MongoLab、Redis4You、Heroku 来部署一个 node 应用。</p>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"首先，使用-MongoLab-：\"><a href=\"#首先，使用-MongoLab-：\" class=\"headerlink\" title=\"首先，使用 MongoLab ：\"></a>首先，使用 MongoLab ：</h3><p>MongoLab 与 MongoHQ 是当今比较流行的 MongoDB 云数据库提供商。MongoLab 的免费套餐提供了 500MB 的存储空间，MongoLab 的使用比较简单明了，这里简要概述一二。</p>\n<h4 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h4><p><a href=\"https://mongolab.com/signup/\" title=\"signup\" target=\"_blank\" rel=\"external\">mongolab.com/signup</a></p>\n<h4 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h4><p>注册成功后，此时进入到自己的控制面板页，点击 <code>Create new</code> 创建一个数据库。在 <code>Plan</code> 选项选择 <code>Single-node</code> 的 <code>Sandbox</code> 免费套餐。在 <code>Darebase name</code> 除填写数据库的名字，点击 <code>Create new MongoDB deployment</code> 完成创建。</p>\n<p>创建成功后跳转到了控制面板页，点击刚才创建的数据库进入该数据库配置页面。我们需要先为数据库创建一个拥有读写权限的用户，点击 <code>Click here</code> 添加一个用户。</p>\n<p>打开 mongodb.js ，将：</p>\n<pre><code>mongoose.connect(&apos;mongodb://localhost/drifter&apos;, {server: {poolSize: 10}});\n</code></pre><p>修改为：</p>\n<pre><code>mongoose.connect(&apos;your_mongolab_url&apos;, {server: {poolSize: 10}});\n</code></pre><p>注意：将 <code>&lt;dbuser&gt;</code> 和 <code>&lt;dbpassword&gt;</code> 分别替换为刚才为数据库创建的用户名和密码。</p>\n<h3 id=\"然后，使用-Redis4You-：\"><a href=\"#然后，使用-Redis4You-：\" class=\"headerlink\" title=\"然后，使用 Redis4You ：\"></a>然后，使用 Redis4You ：</h3><p>redis4you 是一家 Redis 云服务提供商，提供多个档次的 Redis 实例供选择，所有类型的服务包括免费的 5M 试用版，都提供诸如多 DB，持久化等功能。这里我们仅供测试使用。</p>\n<h4 id=\"注册-1\"><a href=\"#注册-1\" class=\"headerlink\" title=\"注册\"></a>注册</h4><p><a href=\"http://redis4you.com/login_new.php\" title=\"redis4you.com\" target=\"_blank\" rel=\"external\">redis4you.com/login_new</a></p>\n<h4 id=\"创建数据库-1\"><a href=\"#创建数据库-1\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h4><p>验证邮箱完成注册。登录 Redis4You，点击右上角的 <code>My Redis Instanses</code> 进入 <code>Redis</code> 管理页面，点击 <code>Provision new instance</code> 创建一个新的数据库。点击 5MB 的免费套餐右边的 <code>Select this instance</code> 完成创建。</p>\n<p>此时跳转到 Redis 管理页面，点击 <code>Information</code> 查看数据库详情。我们只会用到 Host、Port 和 Auth 这三项，其中 Auth 为随机生成的访问数据库的凭证。</p>\n<p>注意：一定要点击左上角的 <code>start</code> 启动数据库。</p>\n<p>打开 redis.js ，将：</p>\n<pre><code>var client = redis.createClient();\n</code></pre><p>修改为：</p>\n<pre><code>var client = redis.createClient(Port, Host, {auth_pass: Auth});\n</code></pre><p>注意：将 Host、Port 和 Auth 分别替换为给定的值。</p>\n<h3 id=\"最后，部署到-HeroKu-：\"><a href=\"#最后，部署到-HeroKu-：\" class=\"headerlink\" title=\"最后，部署到 HeroKu ：\"></a>最后，部署到 HeroKu ：</h3><p>Heroku 是一个主流的 PaaS 提供商，在开发人员中广受欢迎。这个服务围绕着基于 Git 的工作流设计，假如你熟悉 Git ，那部署就十分简单。这个服务原本是为托管 Ruby 应用程序而设计的，但 Heroku 之后加入了对 Node.js 、Clojure 、Scala 、Python 和 Java 等语言的支持。Heroku 的基础服务是免费的。</p>\n<h4 id=\"注册-2\"><a href=\"#注册-2\" class=\"headerlink\" title=\"注册\"></a>注册</h4><p><a href=\"https://www.heroku.com/\" title=\"heroku.com\" target=\"_blank\" rel=\"external\">heroku.com</a></p>\n<h4 id=\"创建一个应用\"><a href=\"#创建一个应用\" class=\"headerlink\" title=\"创建一个应用\"></a>创建一个应用</h4><p>右上角 “＋” 中点击 <code>Create a new app</code> ，填写独一无二的应用名称后，点击 <code>creat app</code> 即创建成功，然后点击 <code>Open app</code> 即可打开应用 URL 链接 。</p>\n<h4 id=\"安装-Heroku-Toolbelt\"><a href=\"#安装-Heroku-Toolbelt\" class=\"headerlink\" title=\"安装 Heroku Toolbelt\"></a>安装 Heroku Toolbelt</h4><p>Heroku 官方提供了 Heroku Toolbelt 工具更方便地部署和管理应用。它包含三个部分：</p>\n<ul>\n<li>Heroku client ：创建和管理 Heroku 应用的命令行工具</li>\n<li>Foreman ：一个在本地运行你的 app 的不错的选择</li>\n<li>Git ：分布式版本控制工具，用来把应用推送到 Heroku</li>\n</ul>\n<p>Heroku Toolbelt 下载地址：<a href=\"https://toolbelt.heroku.com/\" title=\"toolbelt.heroku.com\" target=\"_blank\" rel=\"external\">toolbelt.heroku.com</a> 。</p>\n<p>注意：假如你的电脑上已经安装了 Git ，那么在安装的时候选择 <code>Custom Installation</code> 并去掉安装 Git 的选项，否则选择 <code>Full Installation</code> 。</p>\n<p>安装成功后，打开终端 shell ，输入 <code>heroku login</code> ，然后输入在 Heroku 注册的帐号和密码进行登录。Git 会检测是否有 SSH 密钥，如果有，则使用此密钥并上传，如果没有，则创建一个密钥并上传。</p>\n<p>Tips：SSH 密钥通常用于授予用户访问服务器的权限。可将它们用于某些配置中，以便无需密码即可访问服务器。许多 PaaS 提供商都使用了此功能。</p>\n<h4 id=\"Procfile\"><a href=\"#Procfile\" class=\"headerlink\" title=\"Procfile\"></a>Procfile</h4><p>在工程的根目录下新建一个 Procfile 文件，添加如下内容：</p>\n<pre><code>web: ./bin/www\n</code></pre><p>Procfile 文件告诉了服务器该使用什么命令启动一个 web 服务，这里我们通过 <code>./bin/www</code> 执行 Node 脚本。为什么这里声明了一个 web 类型呢？官方解释为：</p>\n<blockquote>\n<p>The name “web” is important here. It declares that this process type will be attached to the HTTP routing stack of Heroku, and receive web traffic when deployed.</p>\n</blockquote>\n<h4 id=\"上传应用\"><a href=\"#上传应用\" class=\"headerlink\" title=\"上传应用\"></a>上传应用</h4><p>首先 clone 一份 git 仓库源码到你的本地机器中；</p>\n<pre><code>$ heroku git:clone -a web_app_name\n$ cd web_app_name\n</code></pre><p>使用 git 将源码变动的部分更新以及部署到 heroku 当中.</p>\n<pre><code>$ git add .\n$ git commit -am &quot;make it better&quot;\n$ git push heroku master\n</code></pre><p>在 push 到 heroku 服务器之前，我们还需要做一个工作。由于我国某些政策的原因，我们需到 ~/.ssh/ 目录下，新建一个 config 文件，内容如下：</p>\n<pre><code>Host git.heroku.com\nUser yourName\nHostname 107.21.95.3\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_rsa\nport 22\n</code></pre><p>然后回到 Git Bash ，输入：</p>\n<pre><code>$ git push heroku master\n</code></pre><p>稍等片刻即上传成功。</p>\n<hr>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/nswbmw\" title=\"nswbmw\" target=\"_blank\" rel=\"external\">nswbmw github</a></li>\n</ul>\n","excerpt":"<p>尝试使用 MongoLab、Redis4You、Heroku 来部署一个 node 应用。</p>","more":"<hr>\n<h3 id=\"首先，使用-MongoLab-：\"><a href=\"#首先，使用-MongoLab-：\" class=\"headerlink\" title=\"首先，使用 MongoLab ：\"></a>首先，使用 MongoLab ：</h3><p>MongoLab 与 MongoHQ 是当今比较流行的 MongoDB 云数据库提供商。MongoLab 的免费套餐提供了 500MB 的存储空间，MongoLab 的使用比较简单明了，这里简要概述一二。</p>\n<h4 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h4><p><a href=\"https://mongolab.com/signup/\" title=\"signup\">mongolab.com/signup</a></p>\n<h4 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h4><p>注册成功后，此时进入到自己的控制面板页，点击 <code>Create new</code> 创建一个数据库。在 <code>Plan</code> 选项选择 <code>Single-node</code> 的 <code>Sandbox</code> 免费套餐。在 <code>Darebase name</code> 除填写数据库的名字，点击 <code>Create new MongoDB deployment</code> 完成创建。</p>\n<p>创建成功后跳转到了控制面板页，点击刚才创建的数据库进入该数据库配置页面。我们需要先为数据库创建一个拥有读写权限的用户，点击 <code>Click here</code> 添加一个用户。</p>\n<p>打开 mongodb.js ，将：</p>\n<pre><code>mongoose.connect(&apos;mongodb://localhost/drifter&apos;, {server: {poolSize: 10}});\n</code></pre><p>修改为：</p>\n<pre><code>mongoose.connect(&apos;your_mongolab_url&apos;, {server: {poolSize: 10}});\n</code></pre><p>注意：将 <code>&lt;dbuser&gt;</code> 和 <code>&lt;dbpassword&gt;</code> 分别替换为刚才为数据库创建的用户名和密码。</p>\n<h3 id=\"然后，使用-Redis4You-：\"><a href=\"#然后，使用-Redis4You-：\" class=\"headerlink\" title=\"然后，使用 Redis4You ：\"></a>然后，使用 Redis4You ：</h3><p>redis4you 是一家 Redis 云服务提供商，提供多个档次的 Redis 实例供选择，所有类型的服务包括免费的 5M 试用版，都提供诸如多 DB，持久化等功能。这里我们仅供测试使用。</p>\n<h4 id=\"注册-1\"><a href=\"#注册-1\" class=\"headerlink\" title=\"注册\"></a>注册</h4><p><a href=\"http://redis4you.com/login_new.php\" title=\"redis4you.com\">redis4you.com/login_new</a></p>\n<h4 id=\"创建数据库-1\"><a href=\"#创建数据库-1\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h4><p>验证邮箱完成注册。登录 Redis4You，点击右上角的 <code>My Redis Instanses</code> 进入 <code>Redis</code> 管理页面，点击 <code>Provision new instance</code> 创建一个新的数据库。点击 5MB 的免费套餐右边的 <code>Select this instance</code> 完成创建。</p>\n<p>此时跳转到 Redis 管理页面，点击 <code>Information</code> 查看数据库详情。我们只会用到 Host、Port 和 Auth 这三项，其中 Auth 为随机生成的访问数据库的凭证。</p>\n<p>注意：一定要点击左上角的 <code>start</code> 启动数据库。</p>\n<p>打开 redis.js ，将：</p>\n<pre><code>var client = redis.createClient();\n</code></pre><p>修改为：</p>\n<pre><code>var client = redis.createClient(Port, Host, {auth_pass: Auth});\n</code></pre><p>注意：将 Host、Port 和 Auth 分别替换为给定的值。</p>\n<h3 id=\"最后，部署到-HeroKu-：\"><a href=\"#最后，部署到-HeroKu-：\" class=\"headerlink\" title=\"最后，部署到 HeroKu ：\"></a>最后，部署到 HeroKu ：</h3><p>Heroku 是一个主流的 PaaS 提供商，在开发人员中广受欢迎。这个服务围绕着基于 Git 的工作流设计，假如你熟悉 Git ，那部署就十分简单。这个服务原本是为托管 Ruby 应用程序而设计的，但 Heroku 之后加入了对 Node.js 、Clojure 、Scala 、Python 和 Java 等语言的支持。Heroku 的基础服务是免费的。</p>\n<h4 id=\"注册-2\"><a href=\"#注册-2\" class=\"headerlink\" title=\"注册\"></a>注册</h4><p><a href=\"https://www.heroku.com/\" title=\"heroku.com\">heroku.com</a></p>\n<h4 id=\"创建一个应用\"><a href=\"#创建一个应用\" class=\"headerlink\" title=\"创建一个应用\"></a>创建一个应用</h4><p>右上角 “＋” 中点击 <code>Create a new app</code> ，填写独一无二的应用名称后，点击 <code>creat app</code> 即创建成功，然后点击 <code>Open app</code> 即可打开应用 URL 链接 。</p>\n<h4 id=\"安装-Heroku-Toolbelt\"><a href=\"#安装-Heroku-Toolbelt\" class=\"headerlink\" title=\"安装 Heroku Toolbelt\"></a>安装 Heroku Toolbelt</h4><p>Heroku 官方提供了 Heroku Toolbelt 工具更方便地部署和管理应用。它包含三个部分：</p>\n<ul>\n<li>Heroku client ：创建和管理 Heroku 应用的命令行工具</li>\n<li>Foreman ：一个在本地运行你的 app 的不错的选择</li>\n<li>Git ：分布式版本控制工具，用来把应用推送到 Heroku</li>\n</ul>\n<p>Heroku Toolbelt 下载地址：<a href=\"https://toolbelt.heroku.com/\" title=\"toolbelt.heroku.com\">toolbelt.heroku.com</a> 。</p>\n<p>注意：假如你的电脑上已经安装了 Git ，那么在安装的时候选择 <code>Custom Installation</code> 并去掉安装 Git 的选项，否则选择 <code>Full Installation</code> 。</p>\n<p>安装成功后，打开终端 shell ，输入 <code>heroku login</code> ，然后输入在 Heroku 注册的帐号和密码进行登录。Git 会检测是否有 SSH 密钥，如果有，则使用此密钥并上传，如果没有，则创建一个密钥并上传。</p>\n<p>Tips：SSH 密钥通常用于授予用户访问服务器的权限。可将它们用于某些配置中，以便无需密码即可访问服务器。许多 PaaS 提供商都使用了此功能。</p>\n<h4 id=\"Procfile\"><a href=\"#Procfile\" class=\"headerlink\" title=\"Procfile\"></a>Procfile</h4><p>在工程的根目录下新建一个 Procfile 文件，添加如下内容：</p>\n<pre><code>web: ./bin/www\n</code></pre><p>Procfile 文件告诉了服务器该使用什么命令启动一个 web 服务，这里我们通过 <code>./bin/www</code> 执行 Node 脚本。为什么这里声明了一个 web 类型呢？官方解释为：</p>\n<blockquote>\n<p>The name “web” is important here. It declares that this process type will be attached to the HTTP routing stack of Heroku, and receive web traffic when deployed.</p>\n</blockquote>\n<h4 id=\"上传应用\"><a href=\"#上传应用\" class=\"headerlink\" title=\"上传应用\"></a>上传应用</h4><p>首先 clone 一份 git 仓库源码到你的本地机器中；</p>\n<pre><code>$ heroku git:clone -a web_app_name\n$ cd web_app_name\n</code></pre><p>使用 git 将源码变动的部分更新以及部署到 heroku 当中.</p>\n<pre><code>$ git add .\n$ git commit -am &quot;make it better&quot;\n$ git push heroku master\n</code></pre><p>在 push 到 heroku 服务器之前，我们还需要做一个工作。由于我国某些政策的原因，我们需到 ~/.ssh/ 目录下，新建一个 config 文件，内容如下：</p>\n<pre><code>Host git.heroku.com\nUser yourName\nHostname 107.21.95.3\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_rsa\nport 22\n</code></pre><p>然后回到 Git Bash ，输入：</p>\n<pre><code>$ git push heroku master\n</code></pre><p>稍等片刻即上传成功。</p>\n<hr>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/nswbmw\" title=\"nswbmw\">nswbmw github</a></li>\n</ul>"},{"title":"Hello, World!","date":"2015-01-23T15:14:55.000Z","type":"tags","_content":"*歡迎來到我的博客，這是我的第一篇[Hexo](http://hexo.io/)日誌，請多多指教！*\n\n作為開篇日誌，依照慣例，不出所料即定為 Hello World 。\n正所謂一千隻程序猿，就會有一千種 Hello World ，\n而在我理解，「Hello World」它代表的是一種探索趣味世界的精神；\n所以敲出這幾個字母，即是希望這種精神能夠成為我接下來每一天的生活基調，\n將每一天都過的更有意義，也更有趣味。\n開設博客，就是這樣一個簡單的初衷，同時也是希望能夠結交更多志同道合的朋友。\n\n進入編程這個行當也有些年月，或許你不會相信，只是在最近的這段時間，\n我才稍稍發覺，寫程序這個苦逼行當也存在著趣味可言。\n那麼過去一直以來，為什麼我就沒有過現在這麼高的覺悟呢？\n\n細細回想，覺得極有可能是被思維模式給“搞拐”了，\n過去的多數時間都耗費在碎小雜亂的結果上，為了短期功利的結果而去妥協做一件事，\n甚至於應付一件事，這樣的狀態是最糟糕的，這種背離初衷的做法最終也只會潛藏隱病，\n慶幸年末果斷的選擇，離開了這種畸形的思維模式，從而避免了捲入漩渦，\n寫這些只是希望今後自己能夠引以為戒，也希望給小夥伴們一個做事的考量。\n\n好了，我們的主題仍然是關於生活、關於探索趣味世界，我想接下來，會有更多的經歷值得分享，\n所以我要記錄下去，拭目以待吧！\n\n----\n*「注」：*\n*“Hello, World!”最早出現於1972年由貝爾實驗室成員Brian Kernighan撰寫的內部技術資料《Introduction to the Language B》中。*\n*對於程序猿而言，它意味著美好的開始。*","source":"_posts/HelloWorld.md","raw":"title: Hello, World!\ndate: 2015-01-23 23:14:55\ncategories: 心情\ntags: [个人日志]\ntype: \"tags\"\n---\n*歡迎來到我的博客，這是我的第一篇[Hexo](http://hexo.io/)日誌，請多多指教！*\n\n作為開篇日誌，依照慣例，不出所料即定為 Hello World 。\n正所謂一千隻程序猿，就會有一千種 Hello World ，\n而在我理解，「Hello World」它代表的是一種探索趣味世界的精神；\n所以敲出這幾個字母，即是希望這種精神能夠成為我接下來每一天的生活基調，\n將每一天都過的更有意義，也更有趣味。\n開設博客，就是這樣一個簡單的初衷，同時也是希望能夠結交更多志同道合的朋友。\n\n進入編程這個行當也有些年月，或許你不會相信，只是在最近的這段時間，\n我才稍稍發覺，寫程序這個苦逼行當也存在著趣味可言。\n那麼過去一直以來，為什麼我就沒有過現在這麼高的覺悟呢？\n\n細細回想，覺得極有可能是被思維模式給“搞拐”了，\n過去的多數時間都耗費在碎小雜亂的結果上，為了短期功利的結果而去妥協做一件事，\n甚至於應付一件事，這樣的狀態是最糟糕的，這種背離初衷的做法最終也只會潛藏隱病，\n慶幸年末果斷的選擇，離開了這種畸形的思維模式，從而避免了捲入漩渦，\n寫這些只是希望今後自己能夠引以為戒，也希望給小夥伴們一個做事的考量。\n\n好了，我們的主題仍然是關於生活、關於探索趣味世界，我想接下來，會有更多的經歷值得分享，\n所以我要記錄下去，拭目以待吧！\n\n----\n*「注」：*\n*“Hello, World!”最早出現於1972年由貝爾實驗室成員Brian Kernighan撰寫的內部技術資料《Introduction to the Language B》中。*\n*對於程序猿而言，它意味著美好的開始。*","slug":"HelloWorld","published":1,"updated":"2017-04-06T13:18:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1nm194j000jrmupps4k364r","content":"<p><em>歡迎來到我的博客，這是我的第一篇<a href=\"http://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>日誌，請多多指教！</em></p>\n<p>作為開篇日誌，依照慣例，不出所料即定為 Hello World 。<br>正所謂一千隻程序猿，就會有一千種 Hello World ，<br>而在我理解，「Hello World」它代表的是一種探索趣味世界的精神；<br>所以敲出這幾個字母，即是希望這種精神能夠成為我接下來每一天的生活基調，<br>將每一天都過的更有意義，也更有趣味。<br>開設博客，就是這樣一個簡單的初衷，同時也是希望能夠結交更多志同道合的朋友。</p>\n<p>進入編程這個行當也有些年月，或許你不會相信，只是在最近的這段時間，<br>我才稍稍發覺，寫程序這個苦逼行當也存在著趣味可言。<br>那麼過去一直以來，為什麼我就沒有過現在這麼高的覺悟呢？</p>\n<p>細細回想，覺得極有可能是被思維模式給“搞拐”了，<br>過去的多數時間都耗費在碎小雜亂的結果上，為了短期功利的結果而去妥協做一件事，<br>甚至於應付一件事，這樣的狀態是最糟糕的，這種背離初衷的做法最終也只會潛藏隱病，<br>慶幸年末果斷的選擇，離開了這種畸形的思維模式，從而避免了捲入漩渦，<br>寫這些只是希望今後自己能夠引以為戒，也希望給小夥伴們一個做事的考量。</p>\n<p>好了，我們的主題仍然是關於生活、關於探索趣味世界，我想接下來，會有更多的經歷值得分享，<br>所以我要記錄下去，拭目以待吧！</p>\n<hr>\n<p><em>「注」：</em><br><em>“Hello, World!”最早出現於1972年由貝爾實驗室成員Brian Kernighan撰寫的內部技術資料《Introduction to the Language B》中。</em><br><em>對於程序猿而言，它意味著美好的開始。</em></p>\n","excerpt":"","more":"<p><em>歡迎來到我的博客，這是我的第一篇<a href=\"http://hexo.io/\">Hexo</a>日誌，請多多指教！</em></p>\n<p>作為開篇日誌，依照慣例，不出所料即定為 Hello World 。<br>正所謂一千隻程序猿，就會有一千種 Hello World ，<br>而在我理解，「Hello World」它代表的是一種探索趣味世界的精神；<br>所以敲出這幾個字母，即是希望這種精神能夠成為我接下來每一天的生活基調，<br>將每一天都過的更有意義，也更有趣味。<br>開設博客，就是這樣一個簡單的初衷，同時也是希望能夠結交更多志同道合的朋友。</p>\n<p>進入編程這個行當也有些年月，或許你不會相信，只是在最近的這段時間，<br>我才稍稍發覺，寫程序這個苦逼行當也存在著趣味可言。<br>那麼過去一直以來，為什麼我就沒有過現在這麼高的覺悟呢？</p>\n<p>細細回想，覺得極有可能是被思維模式給“搞拐”了，<br>過去的多數時間都耗費在碎小雜亂的結果上，為了短期功利的結果而去妥協做一件事，<br>甚至於應付一件事，這樣的狀態是最糟糕的，這種背離初衷的做法最終也只會潛藏隱病，<br>慶幸年末果斷的選擇，離開了這種畸形的思維模式，從而避免了捲入漩渦，<br>寫這些只是希望今後自己能夠引以為戒，也希望給小夥伴們一個做事的考量。</p>\n<p>好了，我們的主題仍然是關於生活、關於探索趣味世界，我想接下來，會有更多的經歷值得分享，<br>所以我要記錄下去，拭目以待吧！</p>\n<hr>\n<p><em>「注」：</em><br><em>“Hello, World!”最早出現於1972年由貝爾實驗室成員Brian Kernighan撰寫的內部技術資料《Introduction to the Language B》中。</em><br><em>對於程序猿而言，它意味著美好的開始。</em></p>\n"},{"title":"遺忘的事","date":"2015-02-04T13:56:17.000Z","type":"tags","_content":"![](http://7u2pj1.com1.z0.glb.clouddn.com/ForgetThing/HuaYang.jpg)\n\n*遺忘，是最好的事，有時，也卻是最壞的事……*\n<!--more-->\n回到成都兩個月有餘，夜裏時常會醒來，\n每當望向窗外，看著遠處華陽河畔寂靜的街景，心中就會莫名的忐忑，略感缺失。\n或許是因為離開了北京，沒有了熟悉車流聲和地鐵的震動，\n讓我覺得反倒有些不適，又或許，是因為別的什麼⋯⋯\n這種感受若有若無反覆著，無法平息，無法清晰描述。\n就是在這樣的夜，在無法入眠時，我會常常想起過去的種種，\n關於已屬於曾經的，那些我以為遺忘的事。\n\n*選擇*\n\n想到三年之前，決定去北京，那個時候，應算第一次為了自己的想法去做的重要選擇，\n回顧這三年間的成長，苦悶不堪在所難免，但一路行走堅持到了現在，也有所獲得。\n時間開始漸漸讓我相信，專注於自己的想法不言放棄，定能獲得存在的真實價值。\n選擇，得失的權衡，不可避免的失去，有時是無可奈何，而有時是隱忍地堅持，\n即便會不捨會疼痛，但最終還是做了決斷。\n一次又一次，你說已找不到原來的樣子，他們卻說這才是生活的原樣。\n是否仍有意義去質問誰說了謊，可是選擇又從來都沒有對錯⋯⋯\n\n*遠方*\n\n路經西安，來到北京，然後輾轉成都，\n穿梭於一座座城池，活著卻仍然像個孩子。\n迷惘了問，下一站會是哪兒？\n徬徨無果後卻隱約聽到『亡命之徒』，\n李宗盛在耳邊喃喃說詞：“對此我並無更高明的解釋”。\n說道遠方，是歲月靜好，現世安穩，\n是晨鐘暮鼓，安之若素⋯⋯\n但想想或許，又並不只是這些。\n為何，要如一葉浮萍隨處游離，\n大概是因為，無法接受妥協於平庸的現在。\n\n\n\n\n\n","source":"_posts/ForgetThing.md","raw":"title: \"遺忘的事\"\ndate: 2015-02-04 21:56:17\ncategories: 心情\ntags: [个人日志]\ntype: \"tags\"\n---\n![](http://7u2pj1.com1.z0.glb.clouddn.com/ForgetThing/HuaYang.jpg)\n\n*遺忘，是最好的事，有時，也卻是最壞的事……*\n<!--more-->\n回到成都兩個月有餘，夜裏時常會醒來，\n每當望向窗外，看著遠處華陽河畔寂靜的街景，心中就會莫名的忐忑，略感缺失。\n或許是因為離開了北京，沒有了熟悉車流聲和地鐵的震動，\n讓我覺得反倒有些不適，又或許，是因為別的什麼⋯⋯\n這種感受若有若無反覆著，無法平息，無法清晰描述。\n就是在這樣的夜，在無法入眠時，我會常常想起過去的種種，\n關於已屬於曾經的，那些我以為遺忘的事。\n\n*選擇*\n\n想到三年之前，決定去北京，那個時候，應算第一次為了自己的想法去做的重要選擇，\n回顧這三年間的成長，苦悶不堪在所難免，但一路行走堅持到了現在，也有所獲得。\n時間開始漸漸讓我相信，專注於自己的想法不言放棄，定能獲得存在的真實價值。\n選擇，得失的權衡，不可避免的失去，有時是無可奈何，而有時是隱忍地堅持，\n即便會不捨會疼痛，但最終還是做了決斷。\n一次又一次，你說已找不到原來的樣子，他們卻說這才是生活的原樣。\n是否仍有意義去質問誰說了謊，可是選擇又從來都沒有對錯⋯⋯\n\n*遠方*\n\n路經西安，來到北京，然後輾轉成都，\n穿梭於一座座城池，活著卻仍然像個孩子。\n迷惘了問，下一站會是哪兒？\n徬徨無果後卻隱約聽到『亡命之徒』，\n李宗盛在耳邊喃喃說詞：“對此我並無更高明的解釋”。\n說道遠方，是歲月靜好，現世安穩，\n是晨鐘暮鼓，安之若素⋯⋯\n但想想或許，又並不只是這些。\n為何，要如一葉浮萍隨處游離，\n大概是因為，無法接受妥協於平庸的現在。\n\n\n\n\n\n","slug":"ForgetThing","published":1,"updated":"2017-04-06T13:18:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1nm194s000mrmupycjyis7f","content":"<p><img src=\"http://7u2pj1.com1.z0.glb.clouddn.com/ForgetThing/HuaYang.jpg\" alt=\"\"></p>\n<p><em>遺忘，是最好的事，有時，也卻是最壞的事……</em><br><a id=\"more\"></a><br>回到成都兩個月有餘，夜裏時常會醒來，<br>每當望向窗外，看著遠處華陽河畔寂靜的街景，心中就會莫名的忐忑，略感缺失。<br>或許是因為離開了北京，沒有了熟悉車流聲和地鐵的震動，<br>讓我覺得反倒有些不適，又或許，是因為別的什麼⋯⋯<br>這種感受若有若無反覆著，無法平息，無法清晰描述。<br>就是在這樣的夜，在無法入眠時，我會常常想起過去的種種，<br>關於已屬於曾經的，那些我以為遺忘的事。</p>\n<p><em>選擇</em></p>\n<p>想到三年之前，決定去北京，那個時候，應算第一次為了自己的想法去做的重要選擇，<br>回顧這三年間的成長，苦悶不堪在所難免，但一路行走堅持到了現在，也有所獲得。<br>時間開始漸漸讓我相信，專注於自己的想法不言放棄，定能獲得存在的真實價值。<br>選擇，得失的權衡，不可避免的失去，有時是無可奈何，而有時是隱忍地堅持，<br>即便會不捨會疼痛，但最終還是做了決斷。<br>一次又一次，你說已找不到原來的樣子，他們卻說這才是生活的原樣。<br>是否仍有意義去質問誰說了謊，可是選擇又從來都沒有對錯⋯⋯</p>\n<p><em>遠方</em></p>\n<p>路經西安，來到北京，然後輾轉成都，<br>穿梭於一座座城池，活著卻仍然像個孩子。<br>迷惘了問，下一站會是哪兒？<br>徬徨無果後卻隱約聽到『亡命之徒』，<br>李宗盛在耳邊喃喃說詞：“對此我並無更高明的解釋”。<br>說道遠方，是歲月靜好，現世安穩，<br>是晨鐘暮鼓，安之若素⋯⋯<br>但想想或許，又並不只是這些。<br>為何，要如一葉浮萍隨處游離，<br>大概是因為，無法接受妥協於平庸的現在。</p>\n","excerpt":"<p><img src=\"http://7u2pj1.com1.z0.glb.clouddn.com/ForgetThing/HuaYang.jpg\" alt=\"\"></p>\n<p><em>遺忘，是最好的事，有時，也卻是最壞的事……</em><br>","more":"<br>回到成都兩個月有餘，夜裏時常會醒來，<br>每當望向窗外，看著遠處華陽河畔寂靜的街景，心中就會莫名的忐忑，略感缺失。<br>或許是因為離開了北京，沒有了熟悉車流聲和地鐵的震動，<br>讓我覺得反倒有些不適，又或許，是因為別的什麼⋯⋯<br>這種感受若有若無反覆著，無法平息，無法清晰描述。<br>就是在這樣的夜，在無法入眠時，我會常常想起過去的種種，<br>關於已屬於曾經的，那些我以為遺忘的事。</p>\n<p><em>選擇</em></p>\n<p>想到三年之前，決定去北京，那個時候，應算第一次為了自己的想法去做的重要選擇，<br>回顧這三年間的成長，苦悶不堪在所難免，但一路行走堅持到了現在，也有所獲得。<br>時間開始漸漸讓我相信，專注於自己的想法不言放棄，定能獲得存在的真實價值。<br>選擇，得失的權衡，不可避免的失去，有時是無可奈何，而有時是隱忍地堅持，<br>即便會不捨會疼痛，但最終還是做了決斷。<br>一次又一次，你說已找不到原來的樣子，他們卻說這才是生活的原樣。<br>是否仍有意義去質問誰說了謊，可是選擇又從來都沒有對錯⋯⋯</p>\n<p><em>遠方</em></p>\n<p>路經西安，來到北京，然後輾轉成都，<br>穿梭於一座座城池，活著卻仍然像個孩子。<br>迷惘了問，下一站會是哪兒？<br>徬徨無果後卻隱約聽到『亡命之徒』，<br>李宗盛在耳邊喃喃說詞：“對此我並無更高明的解釋”。<br>說道遠方，是歲月靜好，現世安穩，<br>是晨鐘暮鼓，安之若素⋯⋯<br>但想想或許，又並不只是這些。<br>為何，要如一葉浮萍隨處游離，<br>大概是因為，無法接受妥協於平庸的現在。</p>"},{"title":"不要活在假相之中","date":"2015-04-06T07:14:17.000Z","type":"tags","_content":"\n*The Walking Dead 「season 5」*\n*\nI didn't bring it in. It got inside on its own. \nThey always will...\nThey dead and the living, Because we're in here. \nAnd the ones out there... \nThey'll hunt us. They'll find us. They'll try to use us. They'll try to kill us. \nBut we'll kill them. We'll survive. I’ll show you how. \nYou know, I was thinking...\nI was thinking how many of you do I have to kill. to save your lives?\nBut I'm not gonna do that. You're gonna change.\n*\n\n<!--more-->\n\n----\n\n*那個你所不知的真相，或者那個你不願接受的真相，\n也許並沒有想像那樣糟。*\n\n*真正的糟糕，是你誤陷於假相，卻認為那才是生活的原貌。*\n\n*真正的糟糕，是你的固執己見，追求著這時空本不存在的絕對。*\n\n*真正的糟糕，是你已被裹挾，再也沒有勇氣去面對這個\n亦真亦幻、或好或壞、非敵非友的真實世界。*\n\n*我們的生活，我們所經歷的，每天都在變動著。*\n\n*如果你還沒有做出絲毫改變，卻認為一切終會好轉。*\n\n*那麼假相，它會尾隨你、找到你，然後試著利用你，最終殺掉你。*\n\n*不要認為你的世界已築起高牆，不會有任何異端可以進入。*\n\n*要知道它們終將會進來，因為這個世界你在其中。*\n\n*你，必須做出改變！*\n\n*那些刺痛的真相，並不是要阻擋你繼續前行，*\n\n*而是要告訴你，前行的道路上需要更大的決心。*\n \n\n\n\n","source":"_posts/DontLiveInIllusion.md","raw":"title: \"不要活在假相之中\"\ndate: 2015-04-06 15:14:17\ncategories: 心情 \ntags: [个人日志] \ntype: \"tags\"\n---\n\n*The Walking Dead 「season 5」*\n*\nI didn't bring it in. It got inside on its own. \nThey always will...\nThey dead and the living, Because we're in here. \nAnd the ones out there... \nThey'll hunt us. They'll find us. They'll try to use us. They'll try to kill us. \nBut we'll kill them. We'll survive. I’ll show you how. \nYou know, I was thinking...\nI was thinking how many of you do I have to kill. to save your lives?\nBut I'm not gonna do that. You're gonna change.\n*\n\n<!--more-->\n\n----\n\n*那個你所不知的真相，或者那個你不願接受的真相，\n也許並沒有想像那樣糟。*\n\n*真正的糟糕，是你誤陷於假相，卻認為那才是生活的原貌。*\n\n*真正的糟糕，是你的固執己見，追求著這時空本不存在的絕對。*\n\n*真正的糟糕，是你已被裹挾，再也沒有勇氣去面對這個\n亦真亦幻、或好或壞、非敵非友的真實世界。*\n\n*我們的生活，我們所經歷的，每天都在變動著。*\n\n*如果你還沒有做出絲毫改變，卻認為一切終會好轉。*\n\n*那麼假相，它會尾隨你、找到你，然後試著利用你，最終殺掉你。*\n\n*不要認為你的世界已築起高牆，不會有任何異端可以進入。*\n\n*要知道它們終將會進來，因為這個世界你在其中。*\n\n*你，必須做出改變！*\n\n*那些刺痛的真相，並不是要阻擋你繼續前行，*\n\n*而是要告訴你，前行的道路上需要更大的決心。*\n \n\n\n\n","slug":"DontLiveInIllusion","published":1,"updated":"2017-04-06T13:18:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1nm194u000prmupeurbrz31","content":"<p><em>The Walking Dead 「season 5」</em><br><em><br>I didn’t bring it in. It got inside on its own.<br>They always will…<br>They dead and the living, Because we’re in here.<br>And the ones out there…<br>They’ll hunt us. They’ll find us. They’ll try to use us. They’ll try to kill us.<br>But we’ll kill them. We’ll survive. I’ll show you how.<br>You know, I was thinking…<br>I was thinking how many of you do I have to kill. to save your lives?<br>But I’m not gonna do that. You’re gonna change.\n</em></p>\n<a id=\"more\"></a>\n<hr>\n<p><em>那個你所不知的真相，或者那個你不願接受的真相，<br>也許並沒有想像那樣糟。</em></p>\n<p><em>真正的糟糕，是你誤陷於假相，卻認為那才是生活的原貌。</em></p>\n<p><em>真正的糟糕，是你的固執己見，追求著這時空本不存在的絕對。</em></p>\n<p><em>真正的糟糕，是你已被裹挾，再也沒有勇氣去面對這個<br>亦真亦幻、或好或壞、非敵非友的真實世界。</em></p>\n<p><em>我們的生活，我們所經歷的，每天都在變動著。</em></p>\n<p><em>如果你還沒有做出絲毫改變，卻認為一切終會好轉。</em></p>\n<p><em>那麼假相，它會尾隨你、找到你，然後試著利用你，最終殺掉你。</em></p>\n<p><em>不要認為你的世界已築起高牆，不會有任何異端可以進入。</em></p>\n<p><em>要知道它們終將會進來，因為這個世界你在其中。</em></p>\n<p><em>你，必須做出改變！</em></p>\n<p><em>那些刺痛的真相，並不是要阻擋你繼續前行，</em></p>\n<p><em>而是要告訴你，前行的道路上需要更大的決心。</em></p>\n","excerpt":"<p><em>The Walking Dead 「season 5」</em><br><em><br>I didn’t bring it in. It got inside on its own.<br>They always will…<br>They dead and the living, Because we’re in here.<br>And the ones out there…<br>They’ll hunt us. They’ll find us. They’ll try to use us. They’ll try to kill us.<br>But we’ll kill them. We’ll survive. I’ll show you how.<br>You know, I was thinking…<br>I was thinking how many of you do I have to kill. to save your lives?<br>But I’m not gonna do that. You’re gonna change.\n</em></p>","more":"<hr>\n<p><em>那個你所不知的真相，或者那個你不願接受的真相，<br>也許並沒有想像那樣糟。</em></p>\n<p><em>真正的糟糕，是你誤陷於假相，卻認為那才是生活的原貌。</em></p>\n<p><em>真正的糟糕，是你的固執己見，追求著這時空本不存在的絕對。</em></p>\n<p><em>真正的糟糕，是你已被裹挾，再也沒有勇氣去面對這個<br>亦真亦幻、或好或壞、非敵非友的真實世界。</em></p>\n<p><em>我們的生活，我們所經歷的，每天都在變動著。</em></p>\n<p><em>如果你還沒有做出絲毫改變，卻認為一切終會好轉。</em></p>\n<p><em>那麼假相，它會尾隨你、找到你，然後試著利用你，最終殺掉你。</em></p>\n<p><em>不要認為你的世界已築起高牆，不會有任何異端可以進入。</em></p>\n<p><em>要知道它們終將會進來，因為這個世界你在其中。</em></p>\n<p><em>你，必須做出改變！</em></p>\n<p><em>那些刺痛的真相，並不是要阻擋你繼續前行，</em></p>\n<p><em>而是要告訴你，前行的道路上需要更大的決心。</em></p>"},{"title":"Mac共享目录挂载","date":"2015-04-05T07:16:59.000Z","type":"tags","_content":"\n最近，这个共享目录挂载的问题一直困扰着我，妈蛋！\n我的目标很简单，就是需要将一个Mac共享目录mount到Linux中去，\n但为什么这般折磨……\n「上帝啊！請寬恕這個狂躁的機智少年！」\n\n<!--more-->\n\n#### 共享目录：\n\n1、 Mac系统“系统偏好设置”中，有个“共享”功能；\n2、进入“共享”后，勾选“文件共享”服务，然后在右侧，我们可以添加需要共享的文件夹以及相关用户访问权限；\n3、如果你需要“SMB”和“AFP”，那就点击“选项...”，添加该服务以及账户；\n\n#### 创建用户：\n\n1、Mac系统“系统偏好设置”中，有个“用户与群组”功能，添加一个共享用户；\n2、在添加前，需要解锁才能操作，解锁后，点击“＋”号，新账户选择“仅限共享”，其他随意，然后“创建用户”；\n\n#### 其余操作：\n\n1、需要讲你新创建的“仅限共享”的用户，添加到共享文件夹的用户中去，设置“读与写”权限，这样，该用户才能够访问该文件夹；\n2、在Linux终端中，首先需要安装cifs： \n    ``` bash    \n    yum install cifs-utils\n    ``` \n3、Linux创建挂载点： \n    ``` bash \n    sudo mkdir -p /mnt/MountPointName\n    ```  \n4、开始挂载： \n    ``` bash \n    mount -t cifs //MacHostOrMacIP/SharedDirectory /mnt/MountPointName/ -o username=UserName,password=Password,nounix,sec=ntlmssp\n    ``` \n#### 但是，最终当我执行的时候，它不好使了～ \n    ``` bash \n    # mount -t cifs //192.168.1.101/Github /mnt/jiangink/ -o username=jiangink,password=123456,nounix,sec=ntlmssp\n    mount error(13): Permission denied\n    Refer to the mount.cifs(8) manual page (e.g. man mount.cifs)\n    ``` \n","source":"_posts/MountMacSharedDir.md","raw":"title: \"Mac共享目录挂载\"\ndate: 2015-04-05 15:16:59\ncategories: \"技术\"   \ntags: \n  - Mac\n  - mount \ntype: \"tags\"\n---\n\n最近，这个共享目录挂载的问题一直困扰着我，妈蛋！\n我的目标很简单，就是需要将一个Mac共享目录mount到Linux中去，\n但为什么这般折磨……\n「上帝啊！請寬恕這個狂躁的機智少年！」\n\n<!--more-->\n\n#### 共享目录：\n\n1、 Mac系统“系统偏好设置”中，有个“共享”功能；\n2、进入“共享”后，勾选“文件共享”服务，然后在右侧，我们可以添加需要共享的文件夹以及相关用户访问权限；\n3、如果你需要“SMB”和“AFP”，那就点击“选项...”，添加该服务以及账户；\n\n#### 创建用户：\n\n1、Mac系统“系统偏好设置”中，有个“用户与群组”功能，添加一个共享用户；\n2、在添加前，需要解锁才能操作，解锁后，点击“＋”号，新账户选择“仅限共享”，其他随意，然后“创建用户”；\n\n#### 其余操作：\n\n1、需要讲你新创建的“仅限共享”的用户，添加到共享文件夹的用户中去，设置“读与写”权限，这样，该用户才能够访问该文件夹；\n2、在Linux终端中，首先需要安装cifs： \n    ``` bash    \n    yum install cifs-utils\n    ``` \n3、Linux创建挂载点： \n    ``` bash \n    sudo mkdir -p /mnt/MountPointName\n    ```  \n4、开始挂载： \n    ``` bash \n    mount -t cifs //MacHostOrMacIP/SharedDirectory /mnt/MountPointName/ -o username=UserName,password=Password,nounix,sec=ntlmssp\n    ``` \n#### 但是，最终当我执行的时候，它不好使了～ \n    ``` bash \n    # mount -t cifs //192.168.1.101/Github /mnt/jiangink/ -o username=jiangink,password=123456,nounix,sec=ntlmssp\n    mount error(13): Permission denied\n    Refer to the mount.cifs(8) manual page (e.g. man mount.cifs)\n    ``` \n","slug":"MountMacSharedDir","published":1,"updated":"2017-04-06T13:26:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1nm194w000qrmup431p5p9g","content":"<p>最近，这个共享目录挂载的问题一直困扰着我，妈蛋！<br>我的目标很简单，就是需要将一个Mac共享目录mount到Linux中去，<br>但为什么这般折磨……<br>「上帝啊！請寬恕這個狂躁的機智少年！」</p>\n<a id=\"more\"></a>\n<h4 id=\"共享目录：\"><a href=\"#共享目录：\" class=\"headerlink\" title=\"共享目录：\"></a>共享目录：</h4><p>1、 Mac系统“系统偏好设置”中，有个“共享”功能；<br>2、进入“共享”后，勾选“文件共享”服务，然后在右侧，我们可以添加需要共享的文件夹以及相关用户访问权限；<br>3、如果你需要“SMB”和“AFP”，那就点击“选项…”，添加该服务以及账户；</p>\n<h4 id=\"创建用户：\"><a href=\"#创建用户：\" class=\"headerlink\" title=\"创建用户：\"></a>创建用户：</h4><p>1、Mac系统“系统偏好设置”中，有个“用户与群组”功能，添加一个共享用户；<br>2、在添加前，需要解锁才能操作，解锁后，点击“＋”号，新账户选择“仅限共享”，其他随意，然后“创建用户”；</p>\n<h4 id=\"其余操作：\"><a href=\"#其余操作：\" class=\"headerlink\" title=\"其余操作：\"></a>其余操作：</h4><p>1、需要讲你新创建的“仅限共享”的用户，添加到共享文件夹的用户中去，设置“读与写”权限，这样，该用户才能够访问该文件夹；<br>2、在Linux终端中，首先需要安装cifs： </p>\n<pre><code>``` bash    \nyum install cifs-utils\n``` \n</code></pre><p>3、Linux创建挂载点： </p>\n<pre><code>``` bash \nsudo mkdir -p /mnt/MountPointName\n```  \n</code></pre><p>4、开始挂载： </p>\n<pre><code>``` bash \nmount -t cifs //MacHostOrMacIP/SharedDirectory /mnt/MountPointName/ -o username=UserName,password=Password,nounix,sec=ntlmssp\n``` \n</code></pre><h4 id=\"但是，最终当我执行的时候，它不好使了～\"><a href=\"#但是，最终当我执行的时候，它不好使了～\" class=\"headerlink\" title=\"但是，最终当我执行的时候，它不好使了～\"></a>但是，最终当我执行的时候，它不好使了～</h4><pre><code>``` bash \n# mount -t cifs //192.168.1.101/Github /mnt/jiangink/ -o username=jiangink,password=123456,nounix,sec=ntlmssp\nmount error(13): Permission denied\nRefer to the mount.cifs(8) manual page (e.g. man mount.cifs)\n``` \n</code></pre>","excerpt":"<p>最近，这个共享目录挂载的问题一直困扰着我，妈蛋！<br>我的目标很简单，就是需要将一个Mac共享目录mount到Linux中去，<br>但为什么这般折磨……<br>「上帝啊！請寬恕這個狂躁的機智少年！」</p>","more":"<h4 id=\"共享目录：\"><a href=\"#共享目录：\" class=\"headerlink\" title=\"共享目录：\"></a>共享目录：</h4><p>1、 Mac系统“系统偏好设置”中，有个“共享”功能；<br>2、进入“共享”后，勾选“文件共享”服务，然后在右侧，我们可以添加需要共享的文件夹以及相关用户访问权限；<br>3、如果你需要“SMB”和“AFP”，那就点击“选项…”，添加该服务以及账户；</p>\n<h4 id=\"创建用户：\"><a href=\"#创建用户：\" class=\"headerlink\" title=\"创建用户：\"></a>创建用户：</h4><p>1、Mac系统“系统偏好设置”中，有个“用户与群组”功能，添加一个共享用户；<br>2、在添加前，需要解锁才能操作，解锁后，点击“＋”号，新账户选择“仅限共享”，其他随意，然后“创建用户”；</p>\n<h4 id=\"其余操作：\"><a href=\"#其余操作：\" class=\"headerlink\" title=\"其余操作：\"></a>其余操作：</h4><p>1、需要讲你新创建的“仅限共享”的用户，添加到共享文件夹的用户中去，设置“读与写”权限，这样，该用户才能够访问该文件夹；<br>2、在Linux终端中，首先需要安装cifs： </p>\n<pre><code>``` bash    \nyum install cifs-utils\n``` \n</code></pre><p>3、Linux创建挂载点： </p>\n<pre><code>``` bash \nsudo mkdir -p /mnt/MountPointName\n```  \n</code></pre><p>4、开始挂载： </p>\n<pre><code>``` bash \nmount -t cifs //MacHostOrMacIP/SharedDirectory /mnt/MountPointName/ -o username=UserName,password=Password,nounix,sec=ntlmssp\n``` \n</code></pre><h4 id=\"但是，最终当我执行的时候，它不好使了～\"><a href=\"#但是，最终当我执行的时候，它不好使了～\" class=\"headerlink\" title=\"但是，最终当我执行的时候，它不好使了～\"></a>但是，最终当我执行的时候，它不好使了～</h4><pre><code>``` bash \n# mount -t cifs //192.168.1.101/Github /mnt/jiangink/ -o username=jiangink,password=123456,nounix,sec=ntlmssp\nmount error(13): Permission denied\nRefer to the mount.cifs(8) manual page (e.g. man mount.cifs)\n``` \n</code></pre>"},{"title":"MEAN学习笔记","date":"2015-04-08T09:22:59.000Z","type":"tags","_content":"\n(M)ongoDB——NoSQL的文档数据库，使用JSON风格来存储数据，甚至也是使用JS来进行sql查询；\n(E)xpress——基于Node的Web开发框架；\n(A)agular——JS的前端开发框架，提供了声明式的双向数据绑定；\n(N)ode——基于V8的运行时环境（JS语言开发），可以构建快速响应、可扩展的网络应用。\n\n<!--more-->\n\n---\n####  Express安装：\n\n1、如果需要安装express 3.x版本，可直接在待安装的包名后添加@版本数，命令行如下：\n``` bash\n$ npm install -g express-generator@3\n```\n\n2、Express 4.x版本后，将express命令行工具分离了出来，我们使用全局方式安装时，其命令行如下：\n``` bash\n$ npm install -g express-generator\n```\n\n3、在安装结束，我们想要创建一个应用app并进入工程目录：\n``` bash\n$ express -e app && cd app\n```\n\n4、初始化依赖环境：\n``` bash\n$ npm install\n```\n\n5、运行这个应用：\n``` bash\n$ npm start\n```\n\n####  MongoDB安装：\n\n这里没有用源码进行安装，用的是HomeBrew，它是一个缺省包管理器，类似于apt-get、yum这样的工具。\n\n1、我们首先需要更新一下homebrew的包数据库，这个过程可能需要几分钟，终端命令如下：\n``` bash    \n$ brew update\n```\n\n2、可以安装MongoDB了，命令行如下：\n``` bash\n$ brew install mongodb\n```\n\n3、安装成功后，终端会提示如何启动，大概命令如下：\n``` bash\n$ mongod --config /usr/local/etc/mongod.conf\n```\n\n4、若已启动，可以再启一个终端，命令行中键入“mongo”即可直接连接到MongoDB；\n\n---\n\n####  问题汇总：\n##### 新工程创建标准：\n    \n创建一个标准的package.json文件：\n``` bash\n$ npm init\n```\n该命令将以文本互动的方式生成一份简易的 package.json 文件；\n\n工程内模块的依赖生成；\n``` bash\n$ npm install modules_name --save\n```\n通过 --save 参数，就能够在你安装模块的同时，自动将模块的依赖写入 package.json。\n安装完成后，查看 package.json，会多了一项 dependencies 字段，该字段内将罗列具体的依赖模块；\n\n##### package.json中的dependencies字段与devDependencies字段：\n\nnode package存在两种依赖项，一种是dependencies，而另一种是devDependencies，\n其中前者的依赖项是正常运行该包时所需要的依赖项，而后者则是进行开发时所需要的依赖项，如一些单元测试的模块包。\n``` javascript\n\"dependencies\": {}      //生产环境\n\"devDependencies\": {}   //开发环境\n```\n在package.json所在目录执行npm install的时候，devDependencies里的模块同样会被安装。\n如果我们只想安装dependencies里面的包，可以执行\n``` bash\nnpm install –production\n```\n如果只安装devDependencies，可以执行\n``` bash\nnpm install –dev\n```\n同理\n自动更新dependencies字段值的依赖模块：\n``` bash\nnpm install node_module –save\n```\n自动更新devDependencies字段值的依赖模块：\n``` bash\nnpm install node_module –save-dev。\n```\n\n##### Most middleware (like session) is no longer bundled with Express and must be installed ……\n解决方法：\n大多数的中间件如session，在Express4.x版本之后不会再随着Express包本身一并被安装，而是被分离出来；原本3.x版本的写法，在这里将不再适用：\n``` javascript\nvar express = require('express');\nvar MongoStore = require('connect-mongo')(express);\n\napp.use(express.session({\n    secret: settings.cookie_secret,\n    store: new MongoStore({\n        db: settings.db\n    })\n}));\n```\n正确的做法应该首先安装中间件express-session，在package.json文件中添加中间件包名及版本，\n然后，命令行通过 npm install 来安装；\n最后修改代码：\n``` javascript\nvar session    = require('express-session');\nvar MongoStore = require('connect-mongo')(session);\n\napp.use(session({\n    secret: settings.cookie_secret,\n    store: new MongoStore({\n        db: settings.db\n    })\n}));\n```\n\n##### Redis的安装：\n到[官网](http://redis.io/download)下载最新源码，或者通过命令下载：\n```bash\n$ wget http://download.redis.io/releases/redis-3.0.1.tar.gz\n```\n\n解压源码包并编译安装：\n```bash\n$ tar xzf redis-3.0.1.tar.gz\n$ cd redis-3.0.1\n$ make\n```\n\n这里比较有意思的是，redis的源码编译与安装只需“make”即可，\n不像之前编译其他源码要再进行一步“make install”才能安装；\n安装好后将会在/usr/local/bin/路径下看得到几个命令执行程序：\n```bash\nredis-benchmark\t\nredis-cli\nredis-check-aof\t\nredis-sentinel\nredis-check-dump\t\nredis-server\n```\n\n---\n\n\n","source":"_posts/MEANNote.md","raw":"title: \"MEAN学习笔记\"\ndate: 2015-04-08 17:22:59\ncategories: \"技术\" \ntags: \n  - MEAN\ntype: \"tags\"\n---\n\n(M)ongoDB——NoSQL的文档数据库，使用JSON风格来存储数据，甚至也是使用JS来进行sql查询；\n(E)xpress——基于Node的Web开发框架；\n(A)agular——JS的前端开发框架，提供了声明式的双向数据绑定；\n(N)ode——基于V8的运行时环境（JS语言开发），可以构建快速响应、可扩展的网络应用。\n\n<!--more-->\n\n---\n####  Express安装：\n\n1、如果需要安装express 3.x版本，可直接在待安装的包名后添加@版本数，命令行如下：\n``` bash\n$ npm install -g express-generator@3\n```\n\n2、Express 4.x版本后，将express命令行工具分离了出来，我们使用全局方式安装时，其命令行如下：\n``` bash\n$ npm install -g express-generator\n```\n\n3、在安装结束，我们想要创建一个应用app并进入工程目录：\n``` bash\n$ express -e app && cd app\n```\n\n4、初始化依赖环境：\n``` bash\n$ npm install\n```\n\n5、运行这个应用：\n``` bash\n$ npm start\n```\n\n####  MongoDB安装：\n\n这里没有用源码进行安装，用的是HomeBrew，它是一个缺省包管理器，类似于apt-get、yum这样的工具。\n\n1、我们首先需要更新一下homebrew的包数据库，这个过程可能需要几分钟，终端命令如下：\n``` bash    \n$ brew update\n```\n\n2、可以安装MongoDB了，命令行如下：\n``` bash\n$ brew install mongodb\n```\n\n3、安装成功后，终端会提示如何启动，大概命令如下：\n``` bash\n$ mongod --config /usr/local/etc/mongod.conf\n```\n\n4、若已启动，可以再启一个终端，命令行中键入“mongo”即可直接连接到MongoDB；\n\n---\n\n####  问题汇总：\n##### 新工程创建标准：\n    \n创建一个标准的package.json文件：\n``` bash\n$ npm init\n```\n该命令将以文本互动的方式生成一份简易的 package.json 文件；\n\n工程内模块的依赖生成；\n``` bash\n$ npm install modules_name --save\n```\n通过 --save 参数，就能够在你安装模块的同时，自动将模块的依赖写入 package.json。\n安装完成后，查看 package.json，会多了一项 dependencies 字段，该字段内将罗列具体的依赖模块；\n\n##### package.json中的dependencies字段与devDependencies字段：\n\nnode package存在两种依赖项，一种是dependencies，而另一种是devDependencies，\n其中前者的依赖项是正常运行该包时所需要的依赖项，而后者则是进行开发时所需要的依赖项，如一些单元测试的模块包。\n``` javascript\n\"dependencies\": {}      //生产环境\n\"devDependencies\": {}   //开发环境\n```\n在package.json所在目录执行npm install的时候，devDependencies里的模块同样会被安装。\n如果我们只想安装dependencies里面的包，可以执行\n``` bash\nnpm install –production\n```\n如果只安装devDependencies，可以执行\n``` bash\nnpm install –dev\n```\n同理\n自动更新dependencies字段值的依赖模块：\n``` bash\nnpm install node_module –save\n```\n自动更新devDependencies字段值的依赖模块：\n``` bash\nnpm install node_module –save-dev。\n```\n\n##### Most middleware (like session) is no longer bundled with Express and must be installed ……\n解决方法：\n大多数的中间件如session，在Express4.x版本之后不会再随着Express包本身一并被安装，而是被分离出来；原本3.x版本的写法，在这里将不再适用：\n``` javascript\nvar express = require('express');\nvar MongoStore = require('connect-mongo')(express);\n\napp.use(express.session({\n    secret: settings.cookie_secret,\n    store: new MongoStore({\n        db: settings.db\n    })\n}));\n```\n正确的做法应该首先安装中间件express-session，在package.json文件中添加中间件包名及版本，\n然后，命令行通过 npm install 来安装；\n最后修改代码：\n``` javascript\nvar session    = require('express-session');\nvar MongoStore = require('connect-mongo')(session);\n\napp.use(session({\n    secret: settings.cookie_secret,\n    store: new MongoStore({\n        db: settings.db\n    })\n}));\n```\n\n##### Redis的安装：\n到[官网](http://redis.io/download)下载最新源码，或者通过命令下载：\n```bash\n$ wget http://download.redis.io/releases/redis-3.0.1.tar.gz\n```\n\n解压源码包并编译安装：\n```bash\n$ tar xzf redis-3.0.1.tar.gz\n$ cd redis-3.0.1\n$ make\n```\n\n这里比较有意思的是，redis的源码编译与安装只需“make”即可，\n不像之前编译其他源码要再进行一步“make install”才能安装；\n安装好后将会在/usr/local/bin/路径下看得到几个命令执行程序：\n```bash\nredis-benchmark\t\nredis-cli\nredis-check-aof\t\nredis-sentinel\nredis-check-dump\t\nredis-server\n```\n\n---\n\n\n","slug":"MEANNote","published":1,"updated":"2017-04-06T13:28:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1nm1951000srmupa5cgktfy","content":"<p>(M)ongoDB——NoSQL的文档数据库，使用JSON风格来存储数据，甚至也是使用JS来进行sql查询；<br>(E)xpress——基于Node的Web开发框架；<br>(A)agular——JS的前端开发框架，提供了声明式的双向数据绑定；<br>(N)ode——基于V8的运行时环境（JS语言开发），可以构建快速响应、可扩展的网络应用。</p>\n<a id=\"more\"></a>\n<hr>\n<h4 id=\"Express安装：\"><a href=\"#Express安装：\" class=\"headerlink\" title=\"Express安装：\"></a>Express安装：</h4><p>1、如果需要安装express 3.x版本，可直接在待安装的包名后添加@版本数，命令行如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g express-generator@3</div></pre></td></tr></table></figure></p>\n<p>2、Express 4.x版本后，将express命令行工具分离了出来，我们使用全局方式安装时，其命令行如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g express-generator</div></pre></td></tr></table></figure></p>\n<p>3、在安装结束，我们想要创建一个应用app并进入工程目录：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ express <span class=\"_\">-e</span> app &amp;&amp; <span class=\"built_in\">cd</span> app</div></pre></td></tr></table></figure></p>\n<p>4、初始化依赖环境：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install</div></pre></td></tr></table></figure></p>\n<p>5、运行这个应用：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm start</div></pre></td></tr></table></figure></p>\n<h4 id=\"MongoDB安装：\"><a href=\"#MongoDB安装：\" class=\"headerlink\" title=\"MongoDB安装：\"></a>MongoDB安装：</h4><p>这里没有用源码进行安装，用的是HomeBrew，它是一个缺省包管理器，类似于apt-get、yum这样的工具。</p>\n<p>1、我们首先需要更新一下homebrew的包数据库，这个过程可能需要几分钟，终端命令如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ brew update</div></pre></td></tr></table></figure></p>\n<p>2、可以安装MongoDB了，命令行如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ brew install mongodb</div></pre></td></tr></table></figure></p>\n<p>3、安装成功后，终端会提示如何启动，大概命令如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mongod --config /usr/<span class=\"built_in\">local</span>/etc/mongod.conf</div></pre></td></tr></table></figure></p>\n<p>4、若已启动，可以再启一个终端，命令行中键入“mongo”即可直接连接到MongoDB；</p>\n<hr>\n<h4 id=\"问题汇总：\"><a href=\"#问题汇总：\" class=\"headerlink\" title=\"问题汇总：\"></a>问题汇总：</h4><h5 id=\"新工程创建标准：\"><a href=\"#新工程创建标准：\" class=\"headerlink\" title=\"新工程创建标准：\"></a>新工程创建标准：</h5><p>创建一个标准的package.json文件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm init</div></pre></td></tr></table></figure></p>\n<p>该命令将以文本互动的方式生成一份简易的 package.json 文件；</p>\n<p>工程内模块的依赖生成；<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install modules_name --save</div></pre></td></tr></table></figure></p>\n<p>通过 –save 参数，就能够在你安装模块的同时，自动将模块的依赖写入 package.json。<br>安装完成后，查看 package.json，会多了一项 dependencies 字段，该字段内将罗列具体的依赖模块；</p>\n<h5 id=\"package-json中的dependencies字段与devDependencies字段：\"><a href=\"#package-json中的dependencies字段与devDependencies字段：\" class=\"headerlink\" title=\"package.json中的dependencies字段与devDependencies字段：\"></a>package.json中的dependencies字段与devDependencies字段：</h5><p>node package存在两种依赖项，一种是dependencies，而另一种是devDependencies，<br>其中前者的依赖项是正常运行该包时所需要的依赖项，而后者则是进行开发时所需要的依赖项，如一些单元测试的模块包。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"dependencies\"</span>: &#123;&#125;      <span class=\"comment\">//生产环境</span></div><div class=\"line\"><span class=\"string\">\"devDependencies\"</span>: &#123;&#125;   <span class=\"comment\">//开发环境</span></div></pre></td></tr></table></figure></p>\n<p>在package.json所在目录执行npm install的时候，devDependencies里的模块同样会被安装。<br>如果我们只想安装dependencies里面的包，可以执行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install –production</div></pre></td></tr></table></figure></p>\n<p>如果只安装devDependencies，可以执行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install –dev</div></pre></td></tr></table></figure></p>\n<p>同理<br>自动更新dependencies字段值的依赖模块：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install node_module –save</div></pre></td></tr></table></figure></p>\n<p>自动更新devDependencies字段值的依赖模块：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install node_module –save-dev。</div></pre></td></tr></table></figure></p>\n<h5 id=\"Most-middleware-like-session-is-no-longer-bundled-with-Express-and-must-be-installed-……\"><a href=\"#Most-middleware-like-session-is-no-longer-bundled-with-Express-and-must-be-installed-……\" class=\"headerlink\" title=\"Most middleware (like session) is no longer bundled with Express and must be installed ……\"></a>Most middleware (like session) is no longer bundled with Express and must be installed ……</h5><p>解决方法：<br>大多数的中间件如session，在Express4.x版本之后不会再随着Express包本身一并被安装，而是被分离出来；原本3.x版本的写法，在这里将不再适用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> MongoStore = <span class=\"built_in\">require</span>(<span class=\"string\">'connect-mongo'</span>)(express);</div><div class=\"line\"></div><div class=\"line\">app.use(express.session(&#123;</div><div class=\"line\">    <span class=\"attr\">secret</span>: settings.cookie_secret,</div><div class=\"line\">    <span class=\"attr\">store</span>: <span class=\"keyword\">new</span> MongoStore(&#123;</div><div class=\"line\">        <span class=\"attr\">db</span>: settings.db</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;));</div></pre></td></tr></table></figure></p>\n<p>正确的做法应该首先安装中间件express-session，在package.json文件中添加中间件包名及版本，<br>然后，命令行通过 npm install 来安装；<br>最后修改代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> session    = <span class=\"built_in\">require</span>(<span class=\"string\">'express-session'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> MongoStore = <span class=\"built_in\">require</span>(<span class=\"string\">'connect-mongo'</span>)(session);</div><div class=\"line\"></div><div class=\"line\">app.use(session(&#123;</div><div class=\"line\">    <span class=\"attr\">secret</span>: settings.cookie_secret,</div><div class=\"line\">    <span class=\"attr\">store</span>: <span class=\"keyword\">new</span> MongoStore(&#123;</div><div class=\"line\">        <span class=\"attr\">db</span>: settings.db</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;));</div></pre></td></tr></table></figure></p>\n<h5 id=\"Redis的安装：\"><a href=\"#Redis的安装：\" class=\"headerlink\" title=\"Redis的安装：\"></a>Redis的安装：</h5><p>到<a href=\"http://redis.io/download\" target=\"_blank\" rel=\"external\">官网</a>下载最新源码，或者通过命令下载：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ wget http://download.redis.io/releases/redis-3.0.1.tar.gz</div></pre></td></tr></table></figure></p>\n<p>解压源码包并编译安装：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ tar xzf redis-3.0.1.tar.gz</div><div class=\"line\">$ <span class=\"built_in\">cd</span> redis-3.0.1</div><div class=\"line\">$ make</div></pre></td></tr></table></figure></p>\n<p>这里比较有意思的是，redis的源码编译与安装只需“make”即可，<br>不像之前编译其他源码要再进行一步“make install”才能安装；<br>安装好后将会在/usr/local/bin/路径下看得到几个命令执行程序：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis-benchmark\t</div><div class=\"line\">redis-cli</div><div class=\"line\">redis-check-aof\t</div><div class=\"line\">redis-sentinel</div><div class=\"line\">redis-check-dump\t</div><div class=\"line\">redis-server</div></pre></td></tr></table></figure></p>\n<hr>\n","excerpt":"<p>(M)ongoDB——NoSQL的文档数据库，使用JSON风格来存储数据，甚至也是使用JS来进行sql查询；<br>(E)xpress——基于Node的Web开发框架；<br>(A)agular——JS的前端开发框架，提供了声明式的双向数据绑定；<br>(N)ode——基于V8的运行时环境（JS语言开发），可以构建快速响应、可扩展的网络应用。</p>","more":"<hr>\n<h4 id=\"Express安装：\"><a href=\"#Express安装：\" class=\"headerlink\" title=\"Express安装：\"></a>Express安装：</h4><p>1、如果需要安装express 3.x版本，可直接在待安装的包名后添加@版本数，命令行如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g express-generator@3</div></pre></td></tr></table></figure></p>\n<p>2、Express 4.x版本后，将express命令行工具分离了出来，我们使用全局方式安装时，其命令行如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g express-generator</div></pre></td></tr></table></figure></p>\n<p>3、在安装结束，我们想要创建一个应用app并进入工程目录：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ express <span class=\"_\">-e</span> app &amp;&amp; <span class=\"built_in\">cd</span> app</div></pre></td></tr></table></figure></p>\n<p>4、初始化依赖环境：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install</div></pre></td></tr></table></figure></p>\n<p>5、运行这个应用：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm start</div></pre></td></tr></table></figure></p>\n<h4 id=\"MongoDB安装：\"><a href=\"#MongoDB安装：\" class=\"headerlink\" title=\"MongoDB安装：\"></a>MongoDB安装：</h4><p>这里没有用源码进行安装，用的是HomeBrew，它是一个缺省包管理器，类似于apt-get、yum这样的工具。</p>\n<p>1、我们首先需要更新一下homebrew的包数据库，这个过程可能需要几分钟，终端命令如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ brew update</div></pre></td></tr></table></figure></p>\n<p>2、可以安装MongoDB了，命令行如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ brew install mongodb</div></pre></td></tr></table></figure></p>\n<p>3、安装成功后，终端会提示如何启动，大概命令如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mongod --config /usr/<span class=\"built_in\">local</span>/etc/mongod.conf</div></pre></td></tr></table></figure></p>\n<p>4、若已启动，可以再启一个终端，命令行中键入“mongo”即可直接连接到MongoDB；</p>\n<hr>\n<h4 id=\"问题汇总：\"><a href=\"#问题汇总：\" class=\"headerlink\" title=\"问题汇总：\"></a>问题汇总：</h4><h5 id=\"新工程创建标准：\"><a href=\"#新工程创建标准：\" class=\"headerlink\" title=\"新工程创建标准：\"></a>新工程创建标准：</h5><p>创建一个标准的package.json文件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm init</div></pre></td></tr></table></figure></p>\n<p>该命令将以文本互动的方式生成一份简易的 package.json 文件；</p>\n<p>工程内模块的依赖生成；<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install modules_name --save</div></pre></td></tr></table></figure></p>\n<p>通过 –save 参数，就能够在你安装模块的同时，自动将模块的依赖写入 package.json。<br>安装完成后，查看 package.json，会多了一项 dependencies 字段，该字段内将罗列具体的依赖模块；</p>\n<h5 id=\"package-json中的dependencies字段与devDependencies字段：\"><a href=\"#package-json中的dependencies字段与devDependencies字段：\" class=\"headerlink\" title=\"package.json中的dependencies字段与devDependencies字段：\"></a>package.json中的dependencies字段与devDependencies字段：</h5><p>node package存在两种依赖项，一种是dependencies，而另一种是devDependencies，<br>其中前者的依赖项是正常运行该包时所需要的依赖项，而后者则是进行开发时所需要的依赖项，如一些单元测试的模块包。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"dependencies\"</span>: &#123;&#125;      <span class=\"comment\">//生产环境</span></div><div class=\"line\"><span class=\"string\">\"devDependencies\"</span>: &#123;&#125;   <span class=\"comment\">//开发环境</span></div></pre></td></tr></table></figure></p>\n<p>在package.json所在目录执行npm install的时候，devDependencies里的模块同样会被安装。<br>如果我们只想安装dependencies里面的包，可以执行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install –production</div></pre></td></tr></table></figure></p>\n<p>如果只安装devDependencies，可以执行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install –dev</div></pre></td></tr></table></figure></p>\n<p>同理<br>自动更新dependencies字段值的依赖模块：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install node_module –save</div></pre></td></tr></table></figure></p>\n<p>自动更新devDependencies字段值的依赖模块：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install node_module –save-dev。</div></pre></td></tr></table></figure></p>\n<h5 id=\"Most-middleware-like-session-is-no-longer-bundled-with-Express-and-must-be-installed-……\"><a href=\"#Most-middleware-like-session-is-no-longer-bundled-with-Express-and-must-be-installed-……\" class=\"headerlink\" title=\"Most middleware (like session) is no longer bundled with Express and must be installed ……\"></a>Most middleware (like session) is no longer bundled with Express and must be installed ……</h5><p>解决方法：<br>大多数的中间件如session，在Express4.x版本之后不会再随着Express包本身一并被安装，而是被分离出来；原本3.x版本的写法，在这里将不再适用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> MongoStore = <span class=\"built_in\">require</span>(<span class=\"string\">'connect-mongo'</span>)(express);</div><div class=\"line\"></div><div class=\"line\">app.use(express.session(&#123;</div><div class=\"line\">    <span class=\"attr\">secret</span>: settings.cookie_secret,</div><div class=\"line\">    <span class=\"attr\">store</span>: <span class=\"keyword\">new</span> MongoStore(&#123;</div><div class=\"line\">        <span class=\"attr\">db</span>: settings.db</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;));</div></pre></td></tr></table></figure></p>\n<p>正确的做法应该首先安装中间件express-session，在package.json文件中添加中间件包名及版本，<br>然后，命令行通过 npm install 来安装；<br>最后修改代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> session    = <span class=\"built_in\">require</span>(<span class=\"string\">'express-session'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> MongoStore = <span class=\"built_in\">require</span>(<span class=\"string\">'connect-mongo'</span>)(session);</div><div class=\"line\"></div><div class=\"line\">app.use(session(&#123;</div><div class=\"line\">    <span class=\"attr\">secret</span>: settings.cookie_secret,</div><div class=\"line\">    <span class=\"attr\">store</span>: <span class=\"keyword\">new</span> MongoStore(&#123;</div><div class=\"line\">        <span class=\"attr\">db</span>: settings.db</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;));</div></pre></td></tr></table></figure></p>\n<h5 id=\"Redis的安装：\"><a href=\"#Redis的安装：\" class=\"headerlink\" title=\"Redis的安装：\"></a>Redis的安装：</h5><p>到<a href=\"http://redis.io/download\">官网</a>下载最新源码，或者通过命令下载：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ wget http://download.redis.io/releases/redis-3.0.1.tar.gz</div></pre></td></tr></table></figure></p>\n<p>解压源码包并编译安装：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ tar xzf redis-3.0.1.tar.gz</div><div class=\"line\">$ <span class=\"built_in\">cd</span> redis-3.0.1</div><div class=\"line\">$ make</div></pre></td></tr></table></figure></p>\n<p>这里比较有意思的是，redis的源码编译与安装只需“make”即可，<br>不像之前编译其他源码要再进行一步“make install”才能安装；<br>安装好后将会在/usr/local/bin/路径下看得到几个命令执行程序：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis-benchmark\t</div><div class=\"line\">redis-cli</div><div class=\"line\">redis-check-aof\t</div><div class=\"line\">redis-sentinel</div><div class=\"line\">redis-check-dump\t</div><div class=\"line\">redis-server</div></pre></td></tr></table></figure></p>\n<hr>"},{"title":"Node调试工具的使用","date":"2015-05-11T14:22:57.000Z","type":"tags","_content":"\n今天发现一个在浏览器上调试node代码的工具，分享一下.\n这个工具名叫：[Node Inspector](https://github.com/node-inspector/node-inspector)\n感兴趣的话可以点链接到Github看看详细文档说明，这里就简要介绍一二；\n<!--more-->\n\n#### 安装步骤\n安装命令：\n``` bash\nnpm install –g node-inspector\n```\n\n#### 运行步骤\n1）首先，需要启动node.js应用\n命令如下：\n``` bash\nnode --debug-brk=[app port] [app name]   \n```\n或者\n``` bash\nnode --debug=[app port] [app name]\n```\n例如：\n``` bash\nnode --debug-brk=3001 bin/www\n```\n[debug与debug-brk两种配参见[说明](https://github.com/node-inspector/node-inspector#troubleshooting)]\n\n2）然后，启动node-inspector调试工具：\n``` bash\nnode-inspector --web-port [web port] --debug-port [app port]\n```\n\n例如：\n``` bash\nnode-inspector --web-port 8081 --debug-port 3001\n```\n[注：8081为web访问端口；3001为应用调试端口]\n\n\n3)最后，访问chrome浏览器：\n具体访问的网址，其实在启动调试工具后会有输出提示，大致如下：\n``` bash\nhttp://127.0.0.1:8081/debug?ws=127.0.0.1:8081&port=3001\n```\n\n---\n具体也可参考如下：\n1. [百度经验](http://jingyan.baidu.com/article/dca1fa6fbd580ff1a44052de.html)\n2. [用node-inspector调试Node.js](http://www.noanylove.com/2011/12/node-the-inspector-debugging-node-js/)\n\n\n\n","source":"_posts/NodeInspector.md","raw":"title: \"Node调试工具的使用\"\ndate: 2015-05-11 22:22:57\ncategories: \"技术\" \ntags: \n  - node\n  - debug\ntype: \"tags\" \n---\n\n今天发现一个在浏览器上调试node代码的工具，分享一下.\n这个工具名叫：[Node Inspector](https://github.com/node-inspector/node-inspector)\n感兴趣的话可以点链接到Github看看详细文档说明，这里就简要介绍一二；\n<!--more-->\n\n#### 安装步骤\n安装命令：\n``` bash\nnpm install –g node-inspector\n```\n\n#### 运行步骤\n1）首先，需要启动node.js应用\n命令如下：\n``` bash\nnode --debug-brk=[app port] [app name]   \n```\n或者\n``` bash\nnode --debug=[app port] [app name]\n```\n例如：\n``` bash\nnode --debug-brk=3001 bin/www\n```\n[debug与debug-brk两种配参见[说明](https://github.com/node-inspector/node-inspector#troubleshooting)]\n\n2）然后，启动node-inspector调试工具：\n``` bash\nnode-inspector --web-port [web port] --debug-port [app port]\n```\n\n例如：\n``` bash\nnode-inspector --web-port 8081 --debug-port 3001\n```\n[注：8081为web访问端口；3001为应用调试端口]\n\n\n3)最后，访问chrome浏览器：\n具体访问的网址，其实在启动调试工具后会有输出提示，大致如下：\n``` bash\nhttp://127.0.0.1:8081/debug?ws=127.0.0.1:8081&port=3001\n```\n\n---\n具体也可参考如下：\n1. [百度经验](http://jingyan.baidu.com/article/dca1fa6fbd580ff1a44052de.html)\n2. [用node-inspector调试Node.js](http://www.noanylove.com/2011/12/node-the-inspector-debugging-node-js/)\n\n\n\n","slug":"NodeInspector","published":1,"updated":"2017-04-06T13:26:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1nm1953000urmup62h62w4a","content":"<p>今天发现一个在浏览器上调试node代码的工具，分享一下.<br>这个工具名叫：<a href=\"https://github.com/node-inspector/node-inspector\" target=\"_blank\" rel=\"external\">Node Inspector</a><br>感兴趣的话可以点链接到Github看看详细文档说明，这里就简要介绍一二；<br><a id=\"more\"></a></p>\n<h4 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h4><p>安装命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install –g node-inspector</div></pre></td></tr></table></figure></p>\n<h4 id=\"运行步骤\"><a href=\"#运行步骤\" class=\"headerlink\" title=\"运行步骤\"></a>运行步骤</h4><p>1）首先，需要启动node.js应用<br>命令如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">node --debug-brk=[app port] [app name]</div></pre></td></tr></table></figure></p>\n<p>或者<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">node --debug=[app port] [app name]</div></pre></td></tr></table></figure></p>\n<p>例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">node --debug-brk=3001 bin/www</div></pre></td></tr></table></figure></p>\n<p>[debug与debug-brk两种配参见<a href=\"https://github.com/node-inspector/node-inspector#troubleshooting\" target=\"_blank\" rel=\"external\">说明</a>]</p>\n<p>2）然后，启动node-inspector调试工具：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">node-inspector --web-port [web port] --debug-port [app port]</div></pre></td></tr></table></figure></p>\n<p>例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">node-inspector --web-port 8081 --debug-port 3001</div></pre></td></tr></table></figure></p>\n<p>[注：8081为web访问端口；3001为应用调试端口]</p>\n<p>3)最后，访问chrome浏览器：<br>具体访问的网址，其实在启动调试工具后会有输出提示，大致如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://127.0.0.1:8081/debug?ws=127.0.0.1:8081&amp;port=3001</div></pre></td></tr></table></figure></p>\n<hr>\n<p>具体也可参考如下：</p>\n<ol>\n<li><a href=\"http://jingyan.baidu.com/article/dca1fa6fbd580ff1a44052de.html\" target=\"_blank\" rel=\"external\">百度经验</a></li>\n<li><a href=\"http://www.noanylove.com/2011/12/node-the-inspector-debugging-node-js/\" target=\"_blank\" rel=\"external\">用node-inspector调试Node.js</a></li>\n</ol>\n","excerpt":"<p>今天发现一个在浏览器上调试node代码的工具，分享一下.<br>这个工具名叫：<a href=\"https://github.com/node-inspector/node-inspector\">Node Inspector</a><br>感兴趣的话可以点链接到Github看看详细文档说明，这里就简要介绍一二；<br>","more":"</p>\n<h4 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h4><p>安装命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install –g node-inspector</div></pre></td></tr></table></figure></p>\n<h4 id=\"运行步骤\"><a href=\"#运行步骤\" class=\"headerlink\" title=\"运行步骤\"></a>运行步骤</h4><p>1）首先，需要启动node.js应用<br>命令如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">node --debug-brk=[app port] [app name]</div></pre></td></tr></table></figure></p>\n<p>或者<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">node --debug=[app port] [app name]</div></pre></td></tr></table></figure></p>\n<p>例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">node --debug-brk=3001 bin/www</div></pre></td></tr></table></figure></p>\n<p>[debug与debug-brk两种配参见<a href=\"https://github.com/node-inspector/node-inspector#troubleshooting\">说明</a>]</p>\n<p>2）然后，启动node-inspector调试工具：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">node-inspector --web-port [web port] --debug-port [app port]</div></pre></td></tr></table></figure></p>\n<p>例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">node-inspector --web-port 8081 --debug-port 3001</div></pre></td></tr></table></figure></p>\n<p>[注：8081为web访问端口；3001为应用调试端口]</p>\n<p>3)最后，访问chrome浏览器：<br>具体访问的网址，其实在启动调试工具后会有输出提示，大致如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://127.0.0.1:8081/debug?ws=127.0.0.1:8081&amp;port=3001</div></pre></td></tr></table></figure></p>\n<hr>\n<p>具体也可参考如下：</p>\n<ol>\n<li><a href=\"http://jingyan.baidu.com/article/dca1fa6fbd580ff1a44052de.html\">百度经验</a></li>\n<li><a href=\"http://www.noanylove.com/2011/12/node-the-inspector-debugging-node-js/\">用node-inspector调试Node.js</a></li>\n</ol>"},{"title":"離開，為了更好的前行","date":"2015-01-27T15:01:51.000Z","type":"tags","_content":"\n![](http://7u2pj1.com1.z0.glb.clouddn.com/MoveForward/BeijingCity.jpg)\n\n*在不經意的某個時刻，*\n*我所追逐的，或許已不再是你，而是我以為的你，*\n*再見，北京。*\n\n<!--more-->\n\n----\n甲：“我說，還記得我們剛來這裏的時候嗎？天氣像今天一樣好。”\n\n乙：“對啊，可是今天，卻是要離開。”\n\n甲：“來的時候就會知道有離開的一天，這個心理準備我以為我們都有。”\n\n乙：“你好像看的很透，但我覺得，你不會像你說的那樣捨得。”\n\n甲：“這幾年間的記憶都在這裏了，而這裏，將要成為你我的舊時光，說捨得，怎麼可能。”\n\n乙：“我這段時間有時在想，這裏的舊時光會不會只是場夢，只是夢醒了，你我也該走了。”\n\n甲：“如果是場夢，那我倒覺得連夢本身都不屬於我，長達幾年的夢，最終醒來，不多不少，我還是我。”\n\n乙：“那你覺得，這場夢是為了什麼？”\n\n甲：“拜託，不要什麼事都要問為什麼，那你告訴我人的一生是為了什麼？”\n\n沈默⋯⋯\n\n甲：“我不知道為了什麼，我也不記得來到這裏是為了什麼？”\n\n乙：“我還記得，但我已不想在這裏提及，再也沒有這個必要了⋯⋯”\n\n甲：“是因為要離開嗎？”\n\n乙：“離開只是一個結果。”\n\n甲：“那麼原因呢？”\n\n乙：“因為我所追逐的，已不再是我以為的樣子。”\n\n\n","source":"_posts/MoveForward.md","raw":"title: \"離開，為了更好的前行\"\ndate: 2015-01-27 23:01:51\ncategories: 心情 \ntags: [个人日志] \ntype: \"tags\"\n---\n\n![](http://7u2pj1.com1.z0.glb.clouddn.com/MoveForward/BeijingCity.jpg)\n\n*在不經意的某個時刻，*\n*我所追逐的，或許已不再是你，而是我以為的你，*\n*再見，北京。*\n\n<!--more-->\n\n----\n甲：“我說，還記得我們剛來這裏的時候嗎？天氣像今天一樣好。”\n\n乙：“對啊，可是今天，卻是要離開。”\n\n甲：“來的時候就會知道有離開的一天，這個心理準備我以為我們都有。”\n\n乙：“你好像看的很透，但我覺得，你不會像你說的那樣捨得。”\n\n甲：“這幾年間的記憶都在這裏了，而這裏，將要成為你我的舊時光，說捨得，怎麼可能。”\n\n乙：“我這段時間有時在想，這裏的舊時光會不會只是場夢，只是夢醒了，你我也該走了。”\n\n甲：“如果是場夢，那我倒覺得連夢本身都不屬於我，長達幾年的夢，最終醒來，不多不少，我還是我。”\n\n乙：“那你覺得，這場夢是為了什麼？”\n\n甲：“拜託，不要什麼事都要問為什麼，那你告訴我人的一生是為了什麼？”\n\n沈默⋯⋯\n\n甲：“我不知道為了什麼，我也不記得來到這裏是為了什麼？”\n\n乙：“我還記得，但我已不想在這裏提及，再也沒有這個必要了⋯⋯”\n\n甲：“是因為要離開嗎？”\n\n乙：“離開只是一個結果。”\n\n甲：“那麼原因呢？”\n\n乙：“因為我所追逐的，已不再是我以為的樣子。”\n\n\n","slug":"MoveForward","published":1,"updated":"2017-04-06T13:19:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1nm1956000xrmupwt49esz0","content":"<p><img src=\"http://7u2pj1.com1.z0.glb.clouddn.com/MoveForward/BeijingCity.jpg\" alt=\"\"></p>\n<p><em>在不經意的某個時刻，</em><br><em>我所追逐的，或許已不再是你，而是我以為的你，</em><br><em>再見，北京。</em></p>\n<a id=\"more\"></a>\n<hr>\n<p>甲：“我說，還記得我們剛來這裏的時候嗎？天氣像今天一樣好。”</p>\n<p>乙：“對啊，可是今天，卻是要離開。”</p>\n<p>甲：“來的時候就會知道有離開的一天，這個心理準備我以為我們都有。”</p>\n<p>乙：“你好像看的很透，但我覺得，你不會像你說的那樣捨得。”</p>\n<p>甲：“這幾年間的記憶都在這裏了，而這裏，將要成為你我的舊時光，說捨得，怎麼可能。”</p>\n<p>乙：“我這段時間有時在想，這裏的舊時光會不會只是場夢，只是夢醒了，你我也該走了。”</p>\n<p>甲：“如果是場夢，那我倒覺得連夢本身都不屬於我，長達幾年的夢，最終醒來，不多不少，我還是我。”</p>\n<p>乙：“那你覺得，這場夢是為了什麼？”</p>\n<p>甲：“拜託，不要什麼事都要問為什麼，那你告訴我人的一生是為了什麼？”</p>\n<p>沈默⋯⋯</p>\n<p>甲：“我不知道為了什麼，我也不記得來到這裏是為了什麼？”</p>\n<p>乙：“我還記得，但我已不想在這裏提及，再也沒有這個必要了⋯⋯”</p>\n<p>甲：“是因為要離開嗎？”</p>\n<p>乙：“離開只是一個結果。”</p>\n<p>甲：“那麼原因呢？”</p>\n<p>乙：“因為我所追逐的，已不再是我以為的樣子。”</p>\n","excerpt":"<p><img src=\"http://7u2pj1.com1.z0.glb.clouddn.com/MoveForward/BeijingCity.jpg\" alt=\"\"></p>\n<p><em>在不經意的某個時刻，</em><br><em>我所追逐的，或許已不再是你，而是我以為的你，</em><br><em>再見，北京。</em></p>","more":"<hr>\n<p>甲：“我說，還記得我們剛來這裏的時候嗎？天氣像今天一樣好。”</p>\n<p>乙：“對啊，可是今天，卻是要離開。”</p>\n<p>甲：“來的時候就會知道有離開的一天，這個心理準備我以為我們都有。”</p>\n<p>乙：“你好像看的很透，但我覺得，你不會像你說的那樣捨得。”</p>\n<p>甲：“這幾年間的記憶都在這裏了，而這裏，將要成為你我的舊時光，說捨得，怎麼可能。”</p>\n<p>乙：“我這段時間有時在想，這裏的舊時光會不會只是場夢，只是夢醒了，你我也該走了。”</p>\n<p>甲：“如果是場夢，那我倒覺得連夢本身都不屬於我，長達幾年的夢，最終醒來，不多不少，我還是我。”</p>\n<p>乙：“那你覺得，這場夢是為了什麼？”</p>\n<p>甲：“拜託，不要什麼事都要問為什麼，那你告訴我人的一生是為了什麼？”</p>\n<p>沈默⋯⋯</p>\n<p>甲：“我不知道為了什麼，我也不記得來到這裏是為了什麼？”</p>\n<p>乙：“我還記得，但我已不想在這裏提及，再也沒有這個必要了⋯⋯”</p>\n<p>甲：“是因為要離開嗎？”</p>\n<p>乙：“離開只是一個結果。”</p>\n<p>甲：“那麼原因呢？”</p>\n<p>乙：“因為我所追逐的，已不再是我以為的樣子。”</p>"},{"title":"有关域名解析","date":"2015-03-18T13:08:06.000Z","type":"tags","_content":"\n\n*这里纪录一下服务端环境，单个域名在对应的多条IP信息情况下，配置与解析处理。*\n\n<!--more-->\n\n#### 关于hosts允许主机对应多条IP的参数配置\n---\n我们知道 *gethostbyname()* 函数会使用到 hosts 文件进行域名解析，而在解析过程中将按照顺序读取文件内容；\n\n`/etc/hosts` 文件内容如下所示： \n\n````\n    192.168.1.1\t\twww.dns.com\n    192.168.1.2\t\twww.dns.com\n    192.168.1.3\t\twww.dns.com\n    192.168.1.4\t\twww.dns.com\n\n````\n\n一般情况下，若未做任何host参数配置的话，仅能够解析到第一条内容(即：192.168.1.1)，\n但如果在 */etc/host.conf* 配置文件中添加 *multi on* (允许主机存在多条IP)，则能够解析到关于该域名的多条IP信息；\n\n#### 主机信息及IP地址列表\n---\nhostent(host entry)，该结构体记录主机的信息，包括主机名、别名、地址类型、地址长度和地址列表。之所以主机的地址是一个列表的形式，原因是当一个主机对应多个网络接口时，就存在多个地址。\n\n````\n    struct hostent\n    {\n        char*\th_name;         /* official name of host */\n        char*\th_aliases;      /* alias list */\n        short\th_addrtype;     /* host address type */\n        short\th_length;       /* length of address */\n        char**\th_addr_list;    /* list of addresses */\n#define\th_addr\th_addr_list[0]  /* address, for backward compat */\n    };\n\n````\n\n*h\\_addr\\_list* 为指针数组，数组中每个元素都是 *in\\_addr* 型指针。\n\n具体域名IP解析的代码如下：\n\n```cpp\nvoid resolve_domain_name(const unsigned char* host_name)\n{\n    struct hostent *host_info = NULL;\n    char target_ip[32];\n    char **pptr;\n    char *address = NULL;\n\n    memset(target_ip, 0, sizeof(target_ip));\n    //获取主机信息\n    host_info = gethostbyname(host_name);\n    if (NULL == host_info)\n    {\n        printf(\"DNS resolve error![%s]\\n\", host_name);\n        return;\n    }\n\n    //获取IP地址列表\n    pptr = host_info->h_addr_list;\n    while(NULL != *pptr)\n    {\n        //[二进制整数] 转换为 [点分十进制]\n        address = inet_ntoa(*(struct in_addr *)*pptr);\n        //address = inet_ntop(host_info->h_addrtype, *pptr, target_ip, sizeof(target_ip));\n        if (NULL == address)\n        {\n            printf(\"Addr convert error!\\n\");\n            return;\n        }\n        printf(\"IP Address = [%s]\\n\", address);\n        pptr ++;\n    }\n}\n\n``` \n\n嗯，到这里，另外需要补充的是二进制整数转点分十进制时，“inet_ntoa函数陷阱”的问题，\ninet_ntoa() 函数返回值为一个指向字符的指针，且是一个由inet_ntoa()函数控制的静态固定指针，\n在每次调用 inet_ntoa() 后，它将会覆盖上次调用时所得的IP地址。\n所以如果上一次返回的结果仍然需要，则最好定义一个缓存来做保留。\n\n\n","source":"_posts/ResolveDomain.md","raw":"title: \"有关域名解析\"\ndate: 2015-03-18 21:08:06\ncategories: \"技术\" \ntags:\n  - c\n  - DNS \ntype: \"tags\"\n---\n\n\n*这里纪录一下服务端环境，单个域名在对应的多条IP信息情况下，配置与解析处理。*\n\n<!--more-->\n\n#### 关于hosts允许主机对应多条IP的参数配置\n---\n我们知道 *gethostbyname()* 函数会使用到 hosts 文件进行域名解析，而在解析过程中将按照顺序读取文件内容；\n\n`/etc/hosts` 文件内容如下所示： \n\n````\n    192.168.1.1\t\twww.dns.com\n    192.168.1.2\t\twww.dns.com\n    192.168.1.3\t\twww.dns.com\n    192.168.1.4\t\twww.dns.com\n\n````\n\n一般情况下，若未做任何host参数配置的话，仅能够解析到第一条内容(即：192.168.1.1)，\n但如果在 */etc/host.conf* 配置文件中添加 *multi on* (允许主机存在多条IP)，则能够解析到关于该域名的多条IP信息；\n\n#### 主机信息及IP地址列表\n---\nhostent(host entry)，该结构体记录主机的信息，包括主机名、别名、地址类型、地址长度和地址列表。之所以主机的地址是一个列表的形式，原因是当一个主机对应多个网络接口时，就存在多个地址。\n\n````\n    struct hostent\n    {\n        char*\th_name;         /* official name of host */\n        char*\th_aliases;      /* alias list */\n        short\th_addrtype;     /* host address type */\n        short\th_length;       /* length of address */\n        char**\th_addr_list;    /* list of addresses */\n#define\th_addr\th_addr_list[0]  /* address, for backward compat */\n    };\n\n````\n\n*h\\_addr\\_list* 为指针数组，数组中每个元素都是 *in\\_addr* 型指针。\n\n具体域名IP解析的代码如下：\n\n```cpp\nvoid resolve_domain_name(const unsigned char* host_name)\n{\n    struct hostent *host_info = NULL;\n    char target_ip[32];\n    char **pptr;\n    char *address = NULL;\n\n    memset(target_ip, 0, sizeof(target_ip));\n    //获取主机信息\n    host_info = gethostbyname(host_name);\n    if (NULL == host_info)\n    {\n        printf(\"DNS resolve error![%s]\\n\", host_name);\n        return;\n    }\n\n    //获取IP地址列表\n    pptr = host_info->h_addr_list;\n    while(NULL != *pptr)\n    {\n        //[二进制整数] 转换为 [点分十进制]\n        address = inet_ntoa(*(struct in_addr *)*pptr);\n        //address = inet_ntop(host_info->h_addrtype, *pptr, target_ip, sizeof(target_ip));\n        if (NULL == address)\n        {\n            printf(\"Addr convert error!\\n\");\n            return;\n        }\n        printf(\"IP Address = [%s]\\n\", address);\n        pptr ++;\n    }\n}\n\n``` \n\n嗯，到这里，另外需要补充的是二进制整数转点分十进制时，“inet_ntoa函数陷阱”的问题，\ninet_ntoa() 函数返回值为一个指向字符的指针，且是一个由inet_ntoa()函数控制的静态固定指针，\n在每次调用 inet_ntoa() 后，它将会覆盖上次调用时所得的IP地址。\n所以如果上一次返回的结果仍然需要，则最好定义一个缓存来做保留。\n\n\n","slug":"ResolveDomain","published":1,"updated":"2017-04-06T13:28:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1nm19590010rmupyh73492s","content":"<p><em>这里纪录一下服务端环境，单个域名在对应的多条IP信息情况下，配置与解析处理。</em></p>\n<a id=\"more\"></a>\n<h4 id=\"关于hosts允许主机对应多条IP的参数配置\"><a href=\"#关于hosts允许主机对应多条IP的参数配置\" class=\"headerlink\" title=\"关于hosts允许主机对应多条IP的参数配置\"></a>关于hosts允许主机对应多条IP的参数配置</h4><hr>\n<p>我们知道 <em>gethostbyname()</em> 函数会使用到 hosts 文件进行域名解析，而在解析过程中将按照顺序读取文件内容；</p>\n<p><code>/etc/hosts</code> 文件内容如下所示： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">192.168.1.1\t\twww.dns.com</div><div class=\"line\">192.168.1.2\t\twww.dns.com</div><div class=\"line\">192.168.1.3\t\twww.dns.com</div><div class=\"line\">192.168.1.4\t\twww.dns.com</div></pre></td></tr></table></figure>\n<p>一般情况下，若未做任何host参数配置的话，仅能够解析到第一条内容(即：192.168.1.1)，<br>但如果在 <em>/etc/host.conf</em> 配置文件中添加 <em>multi on</em> (允许主机存在多条IP)，则能够解析到关于该域名的多条IP信息；</p>\n<h4 id=\"主机信息及IP地址列表\"><a href=\"#主机信息及IP地址列表\" class=\"headerlink\" title=\"主机信息及IP地址列表\"></a>主机信息及IP地址列表</h4><hr>\n<p>hostent(host entry)，该结构体记录主机的信息，包括主机名、别名、地址类型、地址长度和地址列表。之所以主机的地址是一个列表的形式，原因是当一个主机对应多个网络接口时，就存在多个地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">    struct hostent</div><div class=\"line\">    &#123;</div><div class=\"line\">        char*\th_name;         /* official name of host */</div><div class=\"line\">        char*\th_aliases;      /* alias list */</div><div class=\"line\">        short\th_addrtype;     /* host address type */</div><div class=\"line\">        short\th_length;       /* length of address */</div><div class=\"line\">        char**\th_addr_list;    /* list of addresses */</div><div class=\"line\">#define\th_addr\th_addr_list[0]  /* address, for backward compat */</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<p><em>h_addr_list</em> 为指针数组，数组中每个元素都是 <em>in_addr</em> 型指针。</p>\n<p>具体域名IP解析的代码如下：</p>\n<pre><code class=\"cpp\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resolve_domain_name</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>* host_name)</span>\n</span>{\n    <span class=\"keyword\">struct</span> hostent *host_info = <span class=\"literal\">NULL</span>;\n    <span class=\"keyword\">char</span> target_ip[<span class=\"number\">32</span>];\n    <span class=\"keyword\">char</span> **pptr;\n    <span class=\"keyword\">char</span> *address = <span class=\"literal\">NULL</span>;\n\n    <span class=\"built_in\">memset</span>(target_ip, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(target_ip));\n    <span class=\"comment\">//获取主机信息</span>\n    host_info = gethostbyname(host_name);\n    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == host_info)\n    {\n        <span class=\"built_in\">printf</span>(<span class=\"string\">\"DNS resolve error![%s]\\n\"</span>, host_name);\n        <span class=\"keyword\">return</span>;\n    }\n\n    <span class=\"comment\">//获取IP地址列表</span>\n    pptr = host_info-&gt;h_addr_list;\n    <span class=\"keyword\">while</span>(<span class=\"literal\">NULL</span> != *pptr)\n    {\n        <span class=\"comment\">//[二进制整数] 转换为 [点分十进制]</span>\n        address = inet_ntoa(*(<span class=\"keyword\">struct</span> in_addr *)*pptr);\n        <span class=\"comment\">//address = inet_ntop(host_info-&gt;h_addrtype, *pptr, target_ip, sizeof(target_ip));</span>\n        <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == address)\n        {\n            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Addr convert error!\\n\"</span>);\n            <span class=\"keyword\">return</span>;\n        }\n        <span class=\"built_in\">printf</span>(<span class=\"string\">\"IP Address = [%s]\\n\"</span>, address);\n        pptr ++;\n    }\n}\n</code></pre>\n<p>嗯，到这里，另外需要补充的是二进制整数转点分十进制时，“inet_ntoa函数陷阱”的问题，<br>inet_ntoa() 函数返回值为一个指向字符的指针，且是一个由inet_ntoa()函数控制的静态固定指针，<br>在每次调用 inet_ntoa() 后，它将会覆盖上次调用时所得的IP地址。<br>所以如果上一次返回的结果仍然需要，则最好定义一个缓存来做保留。</p>\n","excerpt":"<p><em>这里纪录一下服务端环境，单个域名在对应的多条IP信息情况下，配置与解析处理。</em></p>","more":"<h4 id=\"关于hosts允许主机对应多条IP的参数配置\"><a href=\"#关于hosts允许主机对应多条IP的参数配置\" class=\"headerlink\" title=\"关于hosts允许主机对应多条IP的参数配置\"></a>关于hosts允许主机对应多条IP的参数配置</h4><hr>\n<p>我们知道 <em>gethostbyname()</em> 函数会使用到 hosts 文件进行域名解析，而在解析过程中将按照顺序读取文件内容；</p>\n<p><code>/etc/hosts</code> 文件内容如下所示： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">192.168.1.1\t\twww.dns.com</div><div class=\"line\">192.168.1.2\t\twww.dns.com</div><div class=\"line\">192.168.1.3\t\twww.dns.com</div><div class=\"line\">192.168.1.4\t\twww.dns.com</div></pre></td></tr></table></figure>\n<p>一般情况下，若未做任何host参数配置的话，仅能够解析到第一条内容(即：192.168.1.1)，<br>但如果在 <em>/etc/host.conf</em> 配置文件中添加 <em>multi on</em> (允许主机存在多条IP)，则能够解析到关于该域名的多条IP信息；</p>\n<h4 id=\"主机信息及IP地址列表\"><a href=\"#主机信息及IP地址列表\" class=\"headerlink\" title=\"主机信息及IP地址列表\"></a>主机信息及IP地址列表</h4><hr>\n<p>hostent(host entry)，该结构体记录主机的信息，包括主机名、别名、地址类型、地址长度和地址列表。之所以主机的地址是一个列表的形式，原因是当一个主机对应多个网络接口时，就存在多个地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">    struct hostent</div><div class=\"line\">    &#123;</div><div class=\"line\">        char*\th_name;         /* official name of host */</div><div class=\"line\">        char*\th_aliases;      /* alias list */</div><div class=\"line\">        short\th_addrtype;     /* host address type */</div><div class=\"line\">        short\th_length;       /* length of address */</div><div class=\"line\">        char**\th_addr_list;    /* list of addresses */</div><div class=\"line\">#define\th_addr\th_addr_list[0]  /* address, for backward compat */</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<p><em>h_addr_list</em> 为指针数组，数组中每个元素都是 <em>in_addr</em> 型指针。</p>\n<p>具体域名IP解析的代码如下：</p>\n<pre><code class=\"cpp\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resolve_domain_name</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>* host_name)</span>\n</span>{\n    <span class=\"keyword\">struct</span> hostent *host_info = <span class=\"literal\">NULL</span>;\n    <span class=\"keyword\">char</span> target_ip[<span class=\"number\">32</span>];\n    <span class=\"keyword\">char</span> **pptr;\n    <span class=\"keyword\">char</span> *address = <span class=\"literal\">NULL</span>;\n\n    <span class=\"built_in\">memset</span>(target_ip, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(target_ip));\n    <span class=\"comment\">//获取主机信息</span>\n    host_info = gethostbyname(host_name);\n    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == host_info)\n    {\n        <span class=\"built_in\">printf</span>(<span class=\"string\">\"DNS resolve error![%s]\\n\"</span>, host_name);\n        <span class=\"keyword\">return</span>;\n    }\n\n    <span class=\"comment\">//获取IP地址列表</span>\n    pptr = host_info-&gt;h_addr_list;\n    <span class=\"keyword\">while</span>(<span class=\"literal\">NULL</span> != *pptr)\n    {\n        <span class=\"comment\">//[二进制整数] 转换为 [点分十进制]</span>\n        address = inet_ntoa(*(<span class=\"keyword\">struct</span> in_addr *)*pptr);\n        <span class=\"comment\">//address = inet_ntop(host_info-&gt;h_addrtype, *pptr, target_ip, sizeof(target_ip));</span>\n        <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == address)\n        {\n            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Addr convert error!\\n\"</span>);\n            <span class=\"keyword\">return</span>;\n        }\n        <span class=\"built_in\">printf</span>(<span class=\"string\">\"IP Address = [%s]\\n\"</span>, address);\n        pptr ++;\n    }\n}\n</code></pre>\n<p>嗯，到这里，另外需要补充的是二进制整数转点分十进制时，“inet_ntoa函数陷阱”的问题，<br>inet_ntoa() 函数返回值为一个指向字符的指针，且是一个由inet_ntoa()函数控制的静态固定指针，<br>在每次调用 inet_ntoa() 后，它将会覆盖上次调用时所得的IP地址。<br>所以如果上一次返回的结果仍然需要，则最好定义一个缓存来做保留。</p>"},{"title":"Redis学习笔记","date":"2016-01-05T06:12:24.000Z","type":"tags","_content":"\nRedis是一个开源、支持网络、基于内存、键值对存储数据库，使用ANSI C编写。Redis是时下最流行的键值对存储数据库。\n\n历史：\n> 2015年6月至今：Redis 的开发由Redis Labs赞助。\n\n> 2013年5月至2015年6月期间：其开发由Pivotal赞助。\n\n> 2013年5月之前：其开发由VMware赞助。\n\n<!--more-->\n\n---\n\n### 如何安装 Redis ：\n\n在 Linux、Unix、Mac 中源码编译的安装方式：\n\n\t$ wget http://download.redis.io/releases/redis-3.0.6.tar.gz\n\t$ tar xzf redis-3.0.6.tar.gz\n\t$ cd redis-3.0.6\n\t$ make\n\t\n在 Mac 中可使用 Homebrew 管理工具进行安装：\n\t\n\t$ brew install redis\n\t\n\n### 如何运行 Redis ：\n\n首先需要运行 redis 服务端：\n\n\t$ redis-server\n\t\n然后切换到另一终端命令行，运行客户端可执行程序：\n\n\t$ redis-cli\n\t\n注意，redis默认使用 6379 端口，如果想指定其它端口：\n\n\t$ redis-cli --port 1234\t\t//指定端口为：1234\n\t\n然后可输入 `info` 命令查看所有信息，确认 redis 是否已被正确安装；\n\n同时，还可以使用 redis 提供的 `ping` 命令来测试客户端与 redis 服务是否连接正常：\n\n\tredis 127.0.0.1:6379> PING\n\tPONG \n\t\n\t\n### 关于 Redis 的数据类型：\n\nredis 存在五种数据类型，包括 string（字符串类型），hash（哈希类型），list（链表类型），set（无序集合类型）及 zset（有序集合类型）；\n\n1. 字符串类型 [string] 是 Redis 中最基本的数据类型，也是其他 4 种数据类型的基础，它能存储任何形式的字符串，包括二进制数据。\n2. 哈希类型 [hash] 是一个 string 类型的字段和字段值的映射表。哈希类型适合存储对象。相较于将对象的每个字段存成单个 string 类型，将一个对象存储在 hash 类型中会占用更少的内存，并且可以更方便的存取整个对象。\n3. 链表类型 [list] 可以存储一个有序的字符串列表，内部是使用双向链表实现的。所以我们通常用链表类型的 LPUSH 和 LPOP 或者 RPUSH 和 RPOP 实现栈的功能，用 LPUSH 和 RPOP 或者 RPUSH 和 LPOP 实现队列的功能。\n4. 集合类型 [set] 和数学中的集合概念相似，比如集合中的元素是唯一的、无序的，集合与集合之间可以进行交并差等操作。\n5. 有序集合类型 [zset] 与集合类型一样，只不过多了个 “有序” ，有序集合中每一个元素都关联了一个分数，虽然集合中每个元素都是不同的，但是它们的分数却可以相同。\n  \n  \n### 关于 Redis 的基本使用：\n  \n#### string［字符串类型］：\n\n字符串类型的操作中，SET、GET 以及 INCR 是三个常用的命令。\n\n用法：\n\n* SET key value : 设置 key 的值为 value，成功时返回 OK。\n* GET key : 获取 key 的值，成功时返回 key 的值。\n* INCR key : 给 key 的值加 1，成功时返回更新后的 key 值。\n* KEYS pattern : 查找当前所有符合给定模式 pattern 的 key（该命令适用于 redis 五种数据类型）\n\n\n#### hash［哈希类型］：\n\n哈希类型适合于存储对象。\n\n用法：\n\n* HSET key field value : 设置 key 的 field 字段值为 value，成功时返回 1，如果 key 中 field 字段已经存在且旧值已被新值覆盖，则返回 0 。\n* HGET key field : 获取 key 的 field 字段的值，成功时返回 field 字段的值。\n* HGETALL key : 获取 key 中所有的字段和其值，若 key 不存在，返回空。\n\n\n#### list［链表类型］：\n\n链表类型适合存储如社交网站的新鲜事，假如有一个存储了几千万个新鲜事的链表，获取头部或尾部的 10 条记录也是极快的。以下是链表类型常用的几个命令：\n\n* LPUSH key value [value ...] : 往 key 链表左边添加元素，返回链表的长度。\n* RPUSH key value [value ...] : 往 key 链表右边添加元素，返回链表的长度。\n* LPOP key : 移除 key 链表左边第一个元素，并返回被移除元素的值。\n* RPOP key : 移除 key 链表右边第一个元素，并返回被移除元素的值。\n* LRANGE key start stop : 获取链表中某一片段，但不会修改原链表的值。另外，与很多语言中截取数组片段的 slice 方法不同的是 LRANGE 返回的值包含最右边的元素。LRANGE 命令也支持负索引，即 -1 表示最后一个元素，所以 LRANGE key 0 -1 可以获取链表 key 中所有的元素。如果 start 的位置比 stop 的位置靠后，则返回空，如果 stop 大于实际链表范围，则会返回到链表最后的元素。\n\n\n#### set［集合类型］：\n\n集合类型非常适合存储如文章的标签，这样我们在获取标签的时候就可以避免获取重复的标签了。以下是集合类型常用的几个命令：\n\n* SADD key member [member ...] : 向集合中添加一个或多个元素，若要添加的元素集合中已经存在，则忽略这个元素。返回成功加入的元素数量（不包含忽略的）。\n* SREM key member [member ...] : 从集合中删除一个或多个元素，返回成功移除的元素的数量。\n* SMEMBERS key : 返回集合中所有元素。\n\n集合类型还支持交集、差集和并集的运算，命令如下：\n\n* SINTER key [key ...] : 多个集合执行交集运算，并返回运算结果。\n* SDIFF key [key ...] : 多个集合执行差集运算，并返回运算结果。\n* SUNION key [key ...] : 多个集合执行并集运算，并返回运算结果。\n\n\n#### zset［有序集合类型］：\n\n有序集合类型中每一个元素都关联了一个分数。这使得我们不仅可以进行大部分集合类型的操作，还可以通过分数获取指定分数范围内的元素等与分数有关的操作。有序集合类型适用于比如通过文章访问量排序的功能。常用命令如下：\n\n* ZADD key score member [score member ...] ： 向有序集合中加入一个或多个元素和该元素的值，如果该元素已存在则用新的分数替换原来的分数。返回新加入的元素个数（不包含已存在的元素）。\n* ZREM key member [member ...] ： 删除集合中一个或多个元素，返回成功删除的元素的个数（不包含本来就不存在的元素）。\n* ZRANGE key start stop [WITHSCORES] ： 按元素分数从小到大顺序返回从 start 到 stop 之间所有的元素（同样包含两端的元素）。如果需要同时获得对应元素的分数的话，在尾部加上 WITHSCORES 参数。如果两个元素分数相同，则按照元素的字典序排列。\n* ZREVRANGE key start stop [WITHSCORES] ： 同上，只不过 ZREVRANGE 是按照元素分数从大到小顺序给出结果的。\n\n---\n参考：\n\n* [ZhiCun Github](https://github.com/island205 \"zhicun\")\n\n\n","source":"_posts/RedisNote.md","raw":"title: \"Redis学习笔记\"\ndate: 2016-01-05 14:12:24\ncategories: \"技术\" \ntags:\n  - redis \ntype: \"tags\"\n---\n\nRedis是一个开源、支持网络、基于内存、键值对存储数据库，使用ANSI C编写。Redis是时下最流行的键值对存储数据库。\n\n历史：\n> 2015年6月至今：Redis 的开发由Redis Labs赞助。\n\n> 2013年5月至2015年6月期间：其开发由Pivotal赞助。\n\n> 2013年5月之前：其开发由VMware赞助。\n\n<!--more-->\n\n---\n\n### 如何安装 Redis ：\n\n在 Linux、Unix、Mac 中源码编译的安装方式：\n\n\t$ wget http://download.redis.io/releases/redis-3.0.6.tar.gz\n\t$ tar xzf redis-3.0.6.tar.gz\n\t$ cd redis-3.0.6\n\t$ make\n\t\n在 Mac 中可使用 Homebrew 管理工具进行安装：\n\t\n\t$ brew install redis\n\t\n\n### 如何运行 Redis ：\n\n首先需要运行 redis 服务端：\n\n\t$ redis-server\n\t\n然后切换到另一终端命令行，运行客户端可执行程序：\n\n\t$ redis-cli\n\t\n注意，redis默认使用 6379 端口，如果想指定其它端口：\n\n\t$ redis-cli --port 1234\t\t//指定端口为：1234\n\t\n然后可输入 `info` 命令查看所有信息，确认 redis 是否已被正确安装；\n\n同时，还可以使用 redis 提供的 `ping` 命令来测试客户端与 redis 服务是否连接正常：\n\n\tredis 127.0.0.1:6379> PING\n\tPONG \n\t\n\t\n### 关于 Redis 的数据类型：\n\nredis 存在五种数据类型，包括 string（字符串类型），hash（哈希类型），list（链表类型），set（无序集合类型）及 zset（有序集合类型）；\n\n1. 字符串类型 [string] 是 Redis 中最基本的数据类型，也是其他 4 种数据类型的基础，它能存储任何形式的字符串，包括二进制数据。\n2. 哈希类型 [hash] 是一个 string 类型的字段和字段值的映射表。哈希类型适合存储对象。相较于将对象的每个字段存成单个 string 类型，将一个对象存储在 hash 类型中会占用更少的内存，并且可以更方便的存取整个对象。\n3. 链表类型 [list] 可以存储一个有序的字符串列表，内部是使用双向链表实现的。所以我们通常用链表类型的 LPUSH 和 LPOP 或者 RPUSH 和 RPOP 实现栈的功能，用 LPUSH 和 RPOP 或者 RPUSH 和 LPOP 实现队列的功能。\n4. 集合类型 [set] 和数学中的集合概念相似，比如集合中的元素是唯一的、无序的，集合与集合之间可以进行交并差等操作。\n5. 有序集合类型 [zset] 与集合类型一样，只不过多了个 “有序” ，有序集合中每一个元素都关联了一个分数，虽然集合中每个元素都是不同的，但是它们的分数却可以相同。\n  \n  \n### 关于 Redis 的基本使用：\n  \n#### string［字符串类型］：\n\n字符串类型的操作中，SET、GET 以及 INCR 是三个常用的命令。\n\n用法：\n\n* SET key value : 设置 key 的值为 value，成功时返回 OK。\n* GET key : 获取 key 的值，成功时返回 key 的值。\n* INCR key : 给 key 的值加 1，成功时返回更新后的 key 值。\n* KEYS pattern : 查找当前所有符合给定模式 pattern 的 key（该命令适用于 redis 五种数据类型）\n\n\n#### hash［哈希类型］：\n\n哈希类型适合于存储对象。\n\n用法：\n\n* HSET key field value : 设置 key 的 field 字段值为 value，成功时返回 1，如果 key 中 field 字段已经存在且旧值已被新值覆盖，则返回 0 。\n* HGET key field : 获取 key 的 field 字段的值，成功时返回 field 字段的值。\n* HGETALL key : 获取 key 中所有的字段和其值，若 key 不存在，返回空。\n\n\n#### list［链表类型］：\n\n链表类型适合存储如社交网站的新鲜事，假如有一个存储了几千万个新鲜事的链表，获取头部或尾部的 10 条记录也是极快的。以下是链表类型常用的几个命令：\n\n* LPUSH key value [value ...] : 往 key 链表左边添加元素，返回链表的长度。\n* RPUSH key value [value ...] : 往 key 链表右边添加元素，返回链表的长度。\n* LPOP key : 移除 key 链表左边第一个元素，并返回被移除元素的值。\n* RPOP key : 移除 key 链表右边第一个元素，并返回被移除元素的值。\n* LRANGE key start stop : 获取链表中某一片段，但不会修改原链表的值。另外，与很多语言中截取数组片段的 slice 方法不同的是 LRANGE 返回的值包含最右边的元素。LRANGE 命令也支持负索引，即 -1 表示最后一个元素，所以 LRANGE key 0 -1 可以获取链表 key 中所有的元素。如果 start 的位置比 stop 的位置靠后，则返回空，如果 stop 大于实际链表范围，则会返回到链表最后的元素。\n\n\n#### set［集合类型］：\n\n集合类型非常适合存储如文章的标签，这样我们在获取标签的时候就可以避免获取重复的标签了。以下是集合类型常用的几个命令：\n\n* SADD key member [member ...] : 向集合中添加一个或多个元素，若要添加的元素集合中已经存在，则忽略这个元素。返回成功加入的元素数量（不包含忽略的）。\n* SREM key member [member ...] : 从集合中删除一个或多个元素，返回成功移除的元素的数量。\n* SMEMBERS key : 返回集合中所有元素。\n\n集合类型还支持交集、差集和并集的运算，命令如下：\n\n* SINTER key [key ...] : 多个集合执行交集运算，并返回运算结果。\n* SDIFF key [key ...] : 多个集合执行差集运算，并返回运算结果。\n* SUNION key [key ...] : 多个集合执行并集运算，并返回运算结果。\n\n\n#### zset［有序集合类型］：\n\n有序集合类型中每一个元素都关联了一个分数。这使得我们不仅可以进行大部分集合类型的操作，还可以通过分数获取指定分数范围内的元素等与分数有关的操作。有序集合类型适用于比如通过文章访问量排序的功能。常用命令如下：\n\n* ZADD key score member [score member ...] ： 向有序集合中加入一个或多个元素和该元素的值，如果该元素已存在则用新的分数替换原来的分数。返回新加入的元素个数（不包含已存在的元素）。\n* ZREM key member [member ...] ： 删除集合中一个或多个元素，返回成功删除的元素的个数（不包含本来就不存在的元素）。\n* ZRANGE key start stop [WITHSCORES] ： 按元素分数从小到大顺序返回从 start 到 stop 之间所有的元素（同样包含两端的元素）。如果需要同时获得对应元素的分数的话，在尾部加上 WITHSCORES 参数。如果两个元素分数相同，则按照元素的字典序排列。\n* ZREVRANGE key start stop [WITHSCORES] ： 同上，只不过 ZREVRANGE 是按照元素分数从大到小顺序给出结果的。\n\n---\n参考：\n\n* [ZhiCun Github](https://github.com/island205 \"zhicun\")\n\n\n","slug":"RedisNote","published":1,"updated":"2017-04-06T13:27:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1nm195d0013rmupkhuj552i","content":"<p>Redis是一个开源、支持网络、基于内存、键值对存储数据库，使用ANSI C编写。Redis是时下最流行的键值对存储数据库。</p>\n<p>历史：</p>\n<blockquote>\n<p>2015年6月至今：Redis 的开发由Redis Labs赞助。</p>\n<p>2013年5月至2015年6月期间：其开发由Pivotal赞助。</p>\n<p>2013年5月之前：其开发由VMware赞助。</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"如何安装-Redis-：\"><a href=\"#如何安装-Redis-：\" class=\"headerlink\" title=\"如何安装 Redis ：\"></a>如何安装 Redis ：</h3><p>在 Linux、Unix、Mac 中源码编译的安装方式：</p>\n<pre><code>$ wget http://download.redis.io/releases/redis-3.0.6.tar.gz\n$ tar xzf redis-3.0.6.tar.gz\n$ cd redis-3.0.6\n$ make\n</code></pre><p>在 Mac 中可使用 Homebrew 管理工具进行安装：</p>\n<pre><code>$ brew install redis\n</code></pre><h3 id=\"如何运行-Redis-：\"><a href=\"#如何运行-Redis-：\" class=\"headerlink\" title=\"如何运行 Redis ：\"></a>如何运行 Redis ：</h3><p>首先需要运行 redis 服务端：</p>\n<pre><code>$ redis-server\n</code></pre><p>然后切换到另一终端命令行，运行客户端可执行程序：</p>\n<pre><code>$ redis-cli\n</code></pre><p>注意，redis默认使用 6379 端口，如果想指定其它端口：</p>\n<pre><code>$ redis-cli --port 1234        //指定端口为：1234\n</code></pre><p>然后可输入 <code>info</code> 命令查看所有信息，确认 redis 是否已被正确安装；</p>\n<p>同时，还可以使用 redis 提供的 <code>ping</code> 命令来测试客户端与 redis 服务是否连接正常：</p>\n<pre><code>redis 127.0.0.1:6379&gt; PING\nPONG \n</code></pre><h3 id=\"关于-Redis-的数据类型：\"><a href=\"#关于-Redis-的数据类型：\" class=\"headerlink\" title=\"关于 Redis 的数据类型：\"></a>关于 Redis 的数据类型：</h3><p>redis 存在五种数据类型，包括 string（字符串类型），hash（哈希类型），list（链表类型），set（无序集合类型）及 zset（有序集合类型）；</p>\n<ol>\n<li>字符串类型 [string] 是 Redis 中最基本的数据类型，也是其他 4 种数据类型的基础，它能存储任何形式的字符串，包括二进制数据。</li>\n<li>哈希类型 [hash] 是一个 string 类型的字段和字段值的映射表。哈希类型适合存储对象。相较于将对象的每个字段存成单个 string 类型，将一个对象存储在 hash 类型中会占用更少的内存，并且可以更方便的存取整个对象。</li>\n<li>链表类型 [list] 可以存储一个有序的字符串列表，内部是使用双向链表实现的。所以我们通常用链表类型的 LPUSH 和 LPOP 或者 RPUSH 和 RPOP 实现栈的功能，用 LPUSH 和 RPOP 或者 RPUSH 和 LPOP 实现队列的功能。</li>\n<li>集合类型 [set] 和数学中的集合概念相似，比如集合中的元素是唯一的、无序的，集合与集合之间可以进行交并差等操作。</li>\n<li>有序集合类型 [zset] 与集合类型一样，只不过多了个 “有序” ，有序集合中每一个元素都关联了一个分数，虽然集合中每个元素都是不同的，但是它们的分数却可以相同。</li>\n</ol>\n<h3 id=\"关于-Redis-的基本使用：\"><a href=\"#关于-Redis-的基本使用：\" class=\"headerlink\" title=\"关于 Redis 的基本使用：\"></a>关于 Redis 的基本使用：</h3><h4 id=\"string［字符串类型］：\"><a href=\"#string［字符串类型］：\" class=\"headerlink\" title=\"string［字符串类型］：\"></a>string［字符串类型］：</h4><p>字符串类型的操作中，SET、GET 以及 INCR 是三个常用的命令。</p>\n<p>用法：</p>\n<ul>\n<li>SET key value : 设置 key 的值为 value，成功时返回 OK。</li>\n<li>GET key : 获取 key 的值，成功时返回 key 的值。</li>\n<li>INCR key : 给 key 的值加 1，成功时返回更新后的 key 值。</li>\n<li>KEYS pattern : 查找当前所有符合给定模式 pattern 的 key（该命令适用于 redis 五种数据类型）</li>\n</ul>\n<h4 id=\"hash［哈希类型］：\"><a href=\"#hash［哈希类型］：\" class=\"headerlink\" title=\"hash［哈希类型］：\"></a>hash［哈希类型］：</h4><p>哈希类型适合于存储对象。</p>\n<p>用法：</p>\n<ul>\n<li>HSET key field value : 设置 key 的 field 字段值为 value，成功时返回 1，如果 key 中 field 字段已经存在且旧值已被新值覆盖，则返回 0 。</li>\n<li>HGET key field : 获取 key 的 field 字段的值，成功时返回 field 字段的值。</li>\n<li>HGETALL key : 获取 key 中所有的字段和其值，若 key 不存在，返回空。</li>\n</ul>\n<h4 id=\"list［链表类型］：\"><a href=\"#list［链表类型］：\" class=\"headerlink\" title=\"list［链表类型］：\"></a>list［链表类型］：</h4><p>链表类型适合存储如社交网站的新鲜事，假如有一个存储了几千万个新鲜事的链表，获取头部或尾部的 10 条记录也是极快的。以下是链表类型常用的几个命令：</p>\n<ul>\n<li>LPUSH key value [value …] : 往 key 链表左边添加元素，返回链表的长度。</li>\n<li>RPUSH key value [value …] : 往 key 链表右边添加元素，返回链表的长度。</li>\n<li>LPOP key : 移除 key 链表左边第一个元素，并返回被移除元素的值。</li>\n<li>RPOP key : 移除 key 链表右边第一个元素，并返回被移除元素的值。</li>\n<li>LRANGE key start stop : 获取链表中某一片段，但不会修改原链表的值。另外，与很多语言中截取数组片段的 slice 方法不同的是 LRANGE 返回的值包含最右边的元素。LRANGE 命令也支持负索引，即 -1 表示最后一个元素，所以 LRANGE key 0 -1 可以获取链表 key 中所有的元素。如果 start 的位置比 stop 的位置靠后，则返回空，如果 stop 大于实际链表范围，则会返回到链表最后的元素。</li>\n</ul>\n<h4 id=\"set［集合类型］：\"><a href=\"#set［集合类型］：\" class=\"headerlink\" title=\"set［集合类型］：\"></a>set［集合类型］：</h4><p>集合类型非常适合存储如文章的标签，这样我们在获取标签的时候就可以避免获取重复的标签了。以下是集合类型常用的几个命令：</p>\n<ul>\n<li>SADD key member [member …] : 向集合中添加一个或多个元素，若要添加的元素集合中已经存在，则忽略这个元素。返回成功加入的元素数量（不包含忽略的）。</li>\n<li>SREM key member [member …] : 从集合中删除一个或多个元素，返回成功移除的元素的数量。</li>\n<li>SMEMBERS key : 返回集合中所有元素。</li>\n</ul>\n<p>集合类型还支持交集、差集和并集的运算，命令如下：</p>\n<ul>\n<li>SINTER key [key …] : 多个集合执行交集运算，并返回运算结果。</li>\n<li>SDIFF key [key …] : 多个集合执行差集运算，并返回运算结果。</li>\n<li>SUNION key [key …] : 多个集合执行并集运算，并返回运算结果。</li>\n</ul>\n<h4 id=\"zset［有序集合类型］：\"><a href=\"#zset［有序集合类型］：\" class=\"headerlink\" title=\"zset［有序集合类型］：\"></a>zset［有序集合类型］：</h4><p>有序集合类型中每一个元素都关联了一个分数。这使得我们不仅可以进行大部分集合类型的操作，还可以通过分数获取指定分数范围内的元素等与分数有关的操作。有序集合类型适用于比如通过文章访问量排序的功能。常用命令如下：</p>\n<ul>\n<li>ZADD key score member [score member …] ： 向有序集合中加入一个或多个元素和该元素的值，如果该元素已存在则用新的分数替换原来的分数。返回新加入的元素个数（不包含已存在的元素）。</li>\n<li>ZREM key member [member …] ： 删除集合中一个或多个元素，返回成功删除的元素的个数（不包含本来就不存在的元素）。</li>\n<li>ZRANGE key start stop [WITHSCORES] ： 按元素分数从小到大顺序返回从 start 到 stop 之间所有的元素（同样包含两端的元素）。如果需要同时获得对应元素的分数的话，在尾部加上 WITHSCORES 参数。如果两个元素分数相同，则按照元素的字典序排列。</li>\n<li>ZREVRANGE key start stop [WITHSCORES] ： 同上，只不过 ZREVRANGE 是按照元素分数从大到小顺序给出结果的。</li>\n</ul>\n<hr>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/island205\" title=\"zhicun\" target=\"_blank\" rel=\"external\">ZhiCun Github</a></li>\n</ul>\n","excerpt":"<p>Redis是一个开源、支持网络、基于内存、键值对存储数据库，使用ANSI C编写。Redis是时下最流行的键值对存储数据库。</p>\n<p>历史：</p>\n<blockquote>\n<p>2015年6月至今：Redis 的开发由Redis Labs赞助。</p>\n<p>2013年5月至2015年6月期间：其开发由Pivotal赞助。</p>\n<p>2013年5月之前：其开发由VMware赞助。</p>\n</blockquote>","more":"<hr>\n<h3 id=\"如何安装-Redis-：\"><a href=\"#如何安装-Redis-：\" class=\"headerlink\" title=\"如何安装 Redis ：\"></a>如何安装 Redis ：</h3><p>在 Linux、Unix、Mac 中源码编译的安装方式：</p>\n<pre><code>$ wget http://download.redis.io/releases/redis-3.0.6.tar.gz\n$ tar xzf redis-3.0.6.tar.gz\n$ cd redis-3.0.6\n$ make\n</code></pre><p>在 Mac 中可使用 Homebrew 管理工具进行安装：</p>\n<pre><code>$ brew install redis\n</code></pre><h3 id=\"如何运行-Redis-：\"><a href=\"#如何运行-Redis-：\" class=\"headerlink\" title=\"如何运行 Redis ：\"></a>如何运行 Redis ：</h3><p>首先需要运行 redis 服务端：</p>\n<pre><code>$ redis-server\n</code></pre><p>然后切换到另一终端命令行，运行客户端可执行程序：</p>\n<pre><code>$ redis-cli\n</code></pre><p>注意，redis默认使用 6379 端口，如果想指定其它端口：</p>\n<pre><code>$ redis-cli --port 1234        //指定端口为：1234\n</code></pre><p>然后可输入 <code>info</code> 命令查看所有信息，确认 redis 是否已被正确安装；</p>\n<p>同时，还可以使用 redis 提供的 <code>ping</code> 命令来测试客户端与 redis 服务是否连接正常：</p>\n<pre><code>redis 127.0.0.1:6379&gt; PING\nPONG \n</code></pre><h3 id=\"关于-Redis-的数据类型：\"><a href=\"#关于-Redis-的数据类型：\" class=\"headerlink\" title=\"关于 Redis 的数据类型：\"></a>关于 Redis 的数据类型：</h3><p>redis 存在五种数据类型，包括 string（字符串类型），hash（哈希类型），list（链表类型），set（无序集合类型）及 zset（有序集合类型）；</p>\n<ol>\n<li>字符串类型 [string] 是 Redis 中最基本的数据类型，也是其他 4 种数据类型的基础，它能存储任何形式的字符串，包括二进制数据。</li>\n<li>哈希类型 [hash] 是一个 string 类型的字段和字段值的映射表。哈希类型适合存储对象。相较于将对象的每个字段存成单个 string 类型，将一个对象存储在 hash 类型中会占用更少的内存，并且可以更方便的存取整个对象。</li>\n<li>链表类型 [list] 可以存储一个有序的字符串列表，内部是使用双向链表实现的。所以我们通常用链表类型的 LPUSH 和 LPOP 或者 RPUSH 和 RPOP 实现栈的功能，用 LPUSH 和 RPOP 或者 RPUSH 和 LPOP 实现队列的功能。</li>\n<li>集合类型 [set] 和数学中的集合概念相似，比如集合中的元素是唯一的、无序的，集合与集合之间可以进行交并差等操作。</li>\n<li>有序集合类型 [zset] 与集合类型一样，只不过多了个 “有序” ，有序集合中每一个元素都关联了一个分数，虽然集合中每个元素都是不同的，但是它们的分数却可以相同。</li>\n</ol>\n<h3 id=\"关于-Redis-的基本使用：\"><a href=\"#关于-Redis-的基本使用：\" class=\"headerlink\" title=\"关于 Redis 的基本使用：\"></a>关于 Redis 的基本使用：</h3><h4 id=\"string［字符串类型］：\"><a href=\"#string［字符串类型］：\" class=\"headerlink\" title=\"string［字符串类型］：\"></a>string［字符串类型］：</h4><p>字符串类型的操作中，SET、GET 以及 INCR 是三个常用的命令。</p>\n<p>用法：</p>\n<ul>\n<li>SET key value : 设置 key 的值为 value，成功时返回 OK。</li>\n<li>GET key : 获取 key 的值，成功时返回 key 的值。</li>\n<li>INCR key : 给 key 的值加 1，成功时返回更新后的 key 值。</li>\n<li>KEYS pattern : 查找当前所有符合给定模式 pattern 的 key（该命令适用于 redis 五种数据类型）</li>\n</ul>\n<h4 id=\"hash［哈希类型］：\"><a href=\"#hash［哈希类型］：\" class=\"headerlink\" title=\"hash［哈希类型］：\"></a>hash［哈希类型］：</h4><p>哈希类型适合于存储对象。</p>\n<p>用法：</p>\n<ul>\n<li>HSET key field value : 设置 key 的 field 字段值为 value，成功时返回 1，如果 key 中 field 字段已经存在且旧值已被新值覆盖，则返回 0 。</li>\n<li>HGET key field : 获取 key 的 field 字段的值，成功时返回 field 字段的值。</li>\n<li>HGETALL key : 获取 key 中所有的字段和其值，若 key 不存在，返回空。</li>\n</ul>\n<h4 id=\"list［链表类型］：\"><a href=\"#list［链表类型］：\" class=\"headerlink\" title=\"list［链表类型］：\"></a>list［链表类型］：</h4><p>链表类型适合存储如社交网站的新鲜事，假如有一个存储了几千万个新鲜事的链表，获取头部或尾部的 10 条记录也是极快的。以下是链表类型常用的几个命令：</p>\n<ul>\n<li>LPUSH key value [value …] : 往 key 链表左边添加元素，返回链表的长度。</li>\n<li>RPUSH key value [value …] : 往 key 链表右边添加元素，返回链表的长度。</li>\n<li>LPOP key : 移除 key 链表左边第一个元素，并返回被移除元素的值。</li>\n<li>RPOP key : 移除 key 链表右边第一个元素，并返回被移除元素的值。</li>\n<li>LRANGE key start stop : 获取链表中某一片段，但不会修改原链表的值。另外，与很多语言中截取数组片段的 slice 方法不同的是 LRANGE 返回的值包含最右边的元素。LRANGE 命令也支持负索引，即 -1 表示最后一个元素，所以 LRANGE key 0 -1 可以获取链表 key 中所有的元素。如果 start 的位置比 stop 的位置靠后，则返回空，如果 stop 大于实际链表范围，则会返回到链表最后的元素。</li>\n</ul>\n<h4 id=\"set［集合类型］：\"><a href=\"#set［集合类型］：\" class=\"headerlink\" title=\"set［集合类型］：\"></a>set［集合类型］：</h4><p>集合类型非常适合存储如文章的标签，这样我们在获取标签的时候就可以避免获取重复的标签了。以下是集合类型常用的几个命令：</p>\n<ul>\n<li>SADD key member [member …] : 向集合中添加一个或多个元素，若要添加的元素集合中已经存在，则忽略这个元素。返回成功加入的元素数量（不包含忽略的）。</li>\n<li>SREM key member [member …] : 从集合中删除一个或多个元素，返回成功移除的元素的数量。</li>\n<li>SMEMBERS key : 返回集合中所有元素。</li>\n</ul>\n<p>集合类型还支持交集、差集和并集的运算，命令如下：</p>\n<ul>\n<li>SINTER key [key …] : 多个集合执行交集运算，并返回运算结果。</li>\n<li>SDIFF key [key …] : 多个集合执行差集运算，并返回运算结果。</li>\n<li>SUNION key [key …] : 多个集合执行并集运算，并返回运算结果。</li>\n</ul>\n<h4 id=\"zset［有序集合类型］：\"><a href=\"#zset［有序集合类型］：\" class=\"headerlink\" title=\"zset［有序集合类型］：\"></a>zset［有序集合类型］：</h4><p>有序集合类型中每一个元素都关联了一个分数。这使得我们不仅可以进行大部分集合类型的操作，还可以通过分数获取指定分数范围内的元素等与分数有关的操作。有序集合类型适用于比如通过文章访问量排序的功能。常用命令如下：</p>\n<ul>\n<li>ZADD key score member [score member …] ： 向有序集合中加入一个或多个元素和该元素的值，如果该元素已存在则用新的分数替换原来的分数。返回新加入的元素个数（不包含已存在的元素）。</li>\n<li>ZREM key member [member …] ： 删除集合中一个或多个元素，返回成功删除的元素的个数（不包含本来就不存在的元素）。</li>\n<li>ZRANGE key start stop [WITHSCORES] ： 按元素分数从小到大顺序返回从 start 到 stop 之间所有的元素（同样包含两端的元素）。如果需要同时获得对应元素的分数的话，在尾部加上 WITHSCORES 参数。如果两个元素分数相同，则按照元素的字典序排列。</li>\n<li>ZREVRANGE key start stop [WITHSCORES] ： 同上，只不过 ZREVRANGE 是按照元素分数从大到小顺序给出结果的。</li>\n</ul>\n<hr>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/island205\" title=\"zhicun\">ZhiCun Github</a></li>\n</ul>"},{"title":"Node 任务定时器的使用","date":"2017-04-02T06:12:24.000Z","type":"tags","_content":"\n## 什么是任务定时器：\n\n> 能够在指定时间定期地执行命令、脚本或者程序，可以被用于系统的自动化维护及管理的工具；\n\n最常见的任务定时器当属 `Cron` ，该词源于希腊语 chronos，原意是时间；\n在类 Unix 系统中，可以通过 `crontab` 命令设置定时任务执行的时间周期，然后 `cron` 的守护进程会在后台实时的检测是否有需要执行的任务，通常这些需要执行的任务被称为 `cron jobs`;\n\n<!--more-->\n\n## 定时器的参数说明：\n\n`Cron` 在类 Unix 系统中有很多的实现，如：cronie、bcron、dcron、fcron 等；\n虽然实现有多种，但是基于 `cron` 风格的时序参数结构却是相似的；\n\n这里展示了一个 cron 的时序参数格式：\n\n```\n*    *    *    *    *    *\n┬    ┬    ┬    ┬    ┬    ┬\n│    │    │    │    │    |\n│    │    │    │    │    └ day of week (0 - 7) (0 or 7 is Sun)\n│    │    │    │    └───── month (1 - 12)\n│    │    │    └────────── day of month (1 - 31)\n│    │    └─────────────── hour (0 - 23)\n│    └──────────────────── minute (0 - 59)\n└───────────────────────── second (0 - 59, OPTIONAL)\n```\n\n`*` 表示通配符，匹配任意，当秒为 '*' 时，代表任意秒数都会触发执行；\n\n观察这组参数说明的过程中，发现了一个有趣的问题:\n\n`Q`: 在 `day of week` 参数上，0 或 7 其实都可以代表星期日(Sunday)，WHY?\n`A`: 原因在于 `cron` 的众多实现版本里，对于这个参数，部分实现的设置为：0 - 6 => Sunday - Saturday，而另一部分实现的设置为：1 - 7 => Monday - Sunday，为了兼容，确保两种设置都正确，所以如上；\n\n## 具体参数设置的试例：\n```\n\n* * * * *           # 例1: 每1分钟执行一次\n\n3,15 * * * *        # 例2: 每小时的第3和第15分钟执行\n\n3,15 8-11 * * *     # 例3: 在每天上午8点到11点的第3和第15分钟执行\n\n3,15 8-11 */2 * *   # 例4：每隔两天的上午8点到11点的第3和第15分钟执行\n\n3,15 8-11 * * 1     # 例5：每周一的上午8点到11点的第3和第15分钟执行\n\n30 21 * * *         # 例6：每晚的21时30分执行\n\n45 4 1,10,22 * *    # 例7：每月的1、10、22日的4时45分执行\n \n10 1 * * 6,0        # 例8：每周六、周日的1时10分执行\n\n0,30 18-23 * * *    # 例9：每天 18:00 至 23:00 之间每隔30分钟执行\n\n0 23 * * 6          # 例10：每星期六晚 23:00 执行\n\n* */1 * * *         # 例11：每隔1小时执行\n\n* 23-7/1 * * *      # 例12：晚上23时到次日7时之间每隔1小时执行\n \n```\n\n## 任务定时器在 Node 中的使用\n\n在 Node.JS 中，可以使用 [`Node-Schedule`](https://github.com/node-schedule/node-schedule) 这个 npm 包来进行任务定时器的操作：\n\n\n\n> 描述： A cron-like and not-cron-like job scheduler for Node.\n\n### 安装方式：\n```\nnpm install node-schdule\n```\n\n### 如何使用：\n\n#### 任务定时器的创建：\n```js\nvar schedule = require('node-schedule');\n\nvar j = schedule.scheduleJob('42 * * * *', function(){\n    // 每小时的第42分钟被执行\n  console.log('The answer to life, the universe, and everything!');\n});\n```\n`scheduleJob()` 方法的回调函数用于实现具体定时任务执行的内容;\n\n#### 任务定时器的注销：\n```js\nj.cancel();\n```\n\n#### 基于JS Date类型的时间参数设置：\n```js\nvar schedule = require('node-schedule');\n// 2012年12月21日5时30分执行\nvar date = new Date(2012, 11, 21, 5, 30, 0);\n\nvar j = schedule.scheduleJob(date, function(){\n  console.log('The world is going to end today.');\n});\n```\n注意： 在使用 Date 设置参数是，月份的设定范围是 0~11 ，其中0代表一月，11代表十二月；\n\n#### 4.2.4 递归循环任务的设置：\n```js\nvar schedule = require('node-schedule');\n\nvar rule = new schedule.RecurrenceRule();\n// 每小时的第 42 分钟执行\nrule.minute = 42;\n// rule.dayOfWeek = 5;\n// rule.month = 6;\n// rule.dayOfMonth = 15;\n// rule.hour = 1;\n// rule.second = 0\n\nvar j = schedule.scheduleJob(rule, function(){\n  console.log('The answer to life, the universe, and everything!');\n});\n```\n\n#### 指定时间范围的设置：\n```js\nvar rule = new schedule.RecurrenceRule();\n// 每个月的星期四、五、六、日的17点整执行\nrule.dayOfWeek = [0, new schedule.Range(4, 6)];\nrule.hour = 17;\nrule.minute = 0;\n\nvar j = schedule.scheduleJob(rule, function(){\n  console.log('Today is recognized by Rebecca Black!');\n});\n```\n`RecurrenceRule` 实例的每个cron属性可接受以数组的形式添加多个时间数值，`Range()`方法可指定一个范围的开始值及结束值;\n\n#### 通过对象字面量的方式设置：\n```js\n// 每周日的14时30分执行\nvar j = schedule.scheduleJob({hour: 14, minute: 30, dayOfWeek: 0}, function(){\n  console.log('Time for tea!');\n});\n```\n\n#### 任务定时器的开始及结束时间设置：\n```js\n// 5秒后任务开始执行且10秒后任务结束，任务在此过程中每秒执行一次\nlet startTime = new Date(Date.now() + 5000);\nlet endTime = new Date(startTime.getTime() + 5000);\nvar j = schedule.scheduleJob({ \n    start: startTime, \n    end: endTime, \n    rule: '*/1 * * * * *' \n}, function(){\n  console.log('Time for tea!');\n});\n```\n\n\n---\n> 参考：\nhttp://www.cnblogs.com/zhongweiv/p/node_schedule.html\nhttp://www.codexiu.cn/javascript/blog/16175/\nhttps://zh.wikipedia.org/wiki/Cron\n","source":"_posts/NodeSchedule.md","raw":"title: \"Node 任务定时器的使用\"\ndate: 2017-04-02 14:12:24\ncategories: \"技术\" \ntags: \n  - node\n  - schedule\n  - cron \ntype: \"tags\"\n---\n\n## 什么是任务定时器：\n\n> 能够在指定时间定期地执行命令、脚本或者程序，可以被用于系统的自动化维护及管理的工具；\n\n最常见的任务定时器当属 `Cron` ，该词源于希腊语 chronos，原意是时间；\n在类 Unix 系统中，可以通过 `crontab` 命令设置定时任务执行的时间周期，然后 `cron` 的守护进程会在后台实时的检测是否有需要执行的任务，通常这些需要执行的任务被称为 `cron jobs`;\n\n<!--more-->\n\n## 定时器的参数说明：\n\n`Cron` 在类 Unix 系统中有很多的实现，如：cronie、bcron、dcron、fcron 等；\n虽然实现有多种，但是基于 `cron` 风格的时序参数结构却是相似的；\n\n这里展示了一个 cron 的时序参数格式：\n\n```\n*    *    *    *    *    *\n┬    ┬    ┬    ┬    ┬    ┬\n│    │    │    │    │    |\n│    │    │    │    │    └ day of week (0 - 7) (0 or 7 is Sun)\n│    │    │    │    └───── month (1 - 12)\n│    │    │    └────────── day of month (1 - 31)\n│    │    └─────────────── hour (0 - 23)\n│    └──────────────────── minute (0 - 59)\n└───────────────────────── second (0 - 59, OPTIONAL)\n```\n\n`*` 表示通配符，匹配任意，当秒为 '*' 时，代表任意秒数都会触发执行；\n\n观察这组参数说明的过程中，发现了一个有趣的问题:\n\n`Q`: 在 `day of week` 参数上，0 或 7 其实都可以代表星期日(Sunday)，WHY?\n`A`: 原因在于 `cron` 的众多实现版本里，对于这个参数，部分实现的设置为：0 - 6 => Sunday - Saturday，而另一部分实现的设置为：1 - 7 => Monday - Sunday，为了兼容，确保两种设置都正确，所以如上；\n\n## 具体参数设置的试例：\n```\n\n* * * * *           # 例1: 每1分钟执行一次\n\n3,15 * * * *        # 例2: 每小时的第3和第15分钟执行\n\n3,15 8-11 * * *     # 例3: 在每天上午8点到11点的第3和第15分钟执行\n\n3,15 8-11 */2 * *   # 例4：每隔两天的上午8点到11点的第3和第15分钟执行\n\n3,15 8-11 * * 1     # 例5：每周一的上午8点到11点的第3和第15分钟执行\n\n30 21 * * *         # 例6：每晚的21时30分执行\n\n45 4 1,10,22 * *    # 例7：每月的1、10、22日的4时45分执行\n \n10 1 * * 6,0        # 例8：每周六、周日的1时10分执行\n\n0,30 18-23 * * *    # 例9：每天 18:00 至 23:00 之间每隔30分钟执行\n\n0 23 * * 6          # 例10：每星期六晚 23:00 执行\n\n* */1 * * *         # 例11：每隔1小时执行\n\n* 23-7/1 * * *      # 例12：晚上23时到次日7时之间每隔1小时执行\n \n```\n\n## 任务定时器在 Node 中的使用\n\n在 Node.JS 中，可以使用 [`Node-Schedule`](https://github.com/node-schedule/node-schedule) 这个 npm 包来进行任务定时器的操作：\n\n\n\n> 描述： A cron-like and not-cron-like job scheduler for Node.\n\n### 安装方式：\n```\nnpm install node-schdule\n```\n\n### 如何使用：\n\n#### 任务定时器的创建：\n```js\nvar schedule = require('node-schedule');\n\nvar j = schedule.scheduleJob('42 * * * *', function(){\n    // 每小时的第42分钟被执行\n  console.log('The answer to life, the universe, and everything!');\n});\n```\n`scheduleJob()` 方法的回调函数用于实现具体定时任务执行的内容;\n\n#### 任务定时器的注销：\n```js\nj.cancel();\n```\n\n#### 基于JS Date类型的时间参数设置：\n```js\nvar schedule = require('node-schedule');\n// 2012年12月21日5时30分执行\nvar date = new Date(2012, 11, 21, 5, 30, 0);\n\nvar j = schedule.scheduleJob(date, function(){\n  console.log('The world is going to end today.');\n});\n```\n注意： 在使用 Date 设置参数是，月份的设定范围是 0~11 ，其中0代表一月，11代表十二月；\n\n#### 4.2.4 递归循环任务的设置：\n```js\nvar schedule = require('node-schedule');\n\nvar rule = new schedule.RecurrenceRule();\n// 每小时的第 42 分钟执行\nrule.minute = 42;\n// rule.dayOfWeek = 5;\n// rule.month = 6;\n// rule.dayOfMonth = 15;\n// rule.hour = 1;\n// rule.second = 0\n\nvar j = schedule.scheduleJob(rule, function(){\n  console.log('The answer to life, the universe, and everything!');\n});\n```\n\n#### 指定时间范围的设置：\n```js\nvar rule = new schedule.RecurrenceRule();\n// 每个月的星期四、五、六、日的17点整执行\nrule.dayOfWeek = [0, new schedule.Range(4, 6)];\nrule.hour = 17;\nrule.minute = 0;\n\nvar j = schedule.scheduleJob(rule, function(){\n  console.log('Today is recognized by Rebecca Black!');\n});\n```\n`RecurrenceRule` 实例的每个cron属性可接受以数组的形式添加多个时间数值，`Range()`方法可指定一个范围的开始值及结束值;\n\n#### 通过对象字面量的方式设置：\n```js\n// 每周日的14时30分执行\nvar j = schedule.scheduleJob({hour: 14, minute: 30, dayOfWeek: 0}, function(){\n  console.log('Time for tea!');\n});\n```\n\n#### 任务定时器的开始及结束时间设置：\n```js\n// 5秒后任务开始执行且10秒后任务结束，任务在此过程中每秒执行一次\nlet startTime = new Date(Date.now() + 5000);\nlet endTime = new Date(startTime.getTime() + 5000);\nvar j = schedule.scheduleJob({ \n    start: startTime, \n    end: endTime, \n    rule: '*/1 * * * * *' \n}, function(){\n  console.log('Time for tea!');\n});\n```\n\n\n---\n> 参考：\nhttp://www.cnblogs.com/zhongweiv/p/node_schedule.html\nhttp://www.codexiu.cn/javascript/blog/16175/\nhttps://zh.wikipedia.org/wiki/Cron\n","slug":"NodeSchedule","published":1,"updated":"2017-04-06T13:27:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1nm195h0016rmupa1318s6s","content":"<h2 id=\"什么是任务定时器：\"><a href=\"#什么是任务定时器：\" class=\"headerlink\" title=\"什么是任务定时器：\"></a>什么是任务定时器：</h2><blockquote>\n<p>能够在指定时间定期地执行命令、脚本或者程序，可以被用于系统的自动化维护及管理的工具；</p>\n</blockquote>\n<p>最常见的任务定时器当属 <code>Cron</code> ，该词源于希腊语 chronos，原意是时间；<br>在类 Unix 系统中，可以通过 <code>crontab</code> 命令设置定时任务执行的时间周期，然后 <code>cron</code> 的守护进程会在后台实时的检测是否有需要执行的任务，通常这些需要执行的任务被称为 <code>cron jobs</code>;</p>\n<a id=\"more\"></a>\n<h2 id=\"定时器的参数说明：\"><a href=\"#定时器的参数说明：\" class=\"headerlink\" title=\"定时器的参数说明：\"></a>定时器的参数说明：</h2><p><code>Cron</code> 在类 Unix 系统中有很多的实现，如：cronie、bcron、dcron、fcron 等；<br>虽然实现有多种，但是基于 <code>cron</code> 风格的时序参数结构却是相似的；</p>\n<p>这里展示了一个 cron 的时序参数格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">*    *    *    *    *    *</div><div class=\"line\">┬    ┬    ┬    ┬    ┬    ┬</div><div class=\"line\">│    │    │    │    │    |</div><div class=\"line\">│    │    │    │    │    └ day of week (0 - 7) (0 or 7 is Sun)</div><div class=\"line\">│    │    │    │    └───── month (1 - 12)</div><div class=\"line\">│    │    │    └────────── day of month (1 - 31)</div><div class=\"line\">│    │    └─────────────── hour (0 - 23)</div><div class=\"line\">│    └──────────────────── minute (0 - 59)</div><div class=\"line\">└───────────────────────── second (0 - 59, OPTIONAL)</div></pre></td></tr></table></figure>\n<p><code>*</code> 表示通配符，匹配任意，当秒为 ‘*’ 时，代表任意秒数都会触发执行；</p>\n<p>观察这组参数说明的过程中，发现了一个有趣的问题:</p>\n<p><code>Q</code>: 在 <code>day of week</code> 参数上，0 或 7 其实都可以代表星期日(Sunday)，WHY?<br><code>A</code>: 原因在于 <code>cron</code> 的众多实现版本里，对于这个参数，部分实现的设置为：0 - 6 =&gt; Sunday - Saturday，而另一部分实现的设置为：1 - 7 =&gt; Monday - Sunday，为了兼容，确保两种设置都正确，所以如上；</p>\n<h2 id=\"具体参数设置的试例：\"><a href=\"#具体参数设置的试例：\" class=\"headerlink\" title=\"具体参数设置的试例：\"></a>具体参数设置的试例：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">* * * * *           # 例1: 每1分钟执行一次</div><div class=\"line\"></div><div class=\"line\">3,15 * * * *        # 例2: 每小时的第3和第15分钟执行</div><div class=\"line\"></div><div class=\"line\">3,15 8-11 * * *     # 例3: 在每天上午8点到11点的第3和第15分钟执行</div><div class=\"line\"></div><div class=\"line\">3,15 8-11 */2 * *   # 例4：每隔两天的上午8点到11点的第3和第15分钟执行</div><div class=\"line\"></div><div class=\"line\">3,15 8-11 * * 1     # 例5：每周一的上午8点到11点的第3和第15分钟执行</div><div class=\"line\"></div><div class=\"line\">30 21 * * *         # 例6：每晚的21时30分执行</div><div class=\"line\"></div><div class=\"line\">45 4 1,10,22 * *    # 例7：每月的1、10、22日的4时45分执行</div><div class=\"line\"> </div><div class=\"line\">10 1 * * 6,0        # 例8：每周六、周日的1时10分执行</div><div class=\"line\"></div><div class=\"line\">0,30 18-23 * * *    # 例9：每天 18:00 至 23:00 之间每隔30分钟执行</div><div class=\"line\"></div><div class=\"line\">0 23 * * 6          # 例10：每星期六晚 23:00 执行</div><div class=\"line\"></div><div class=\"line\">* */1 * * *         # 例11：每隔1小时执行</div><div class=\"line\"></div><div class=\"line\">* 23-7/1 * * *      # 例12：晚上23时到次日7时之间每隔1小时执行</div></pre></td></tr></table></figure>\n<h2 id=\"任务定时器在-Node-中的使用\"><a href=\"#任务定时器在-Node-中的使用\" class=\"headerlink\" title=\"任务定时器在 Node 中的使用\"></a>任务定时器在 Node 中的使用</h2><p>在 Node.JS 中，可以使用 <a href=\"https://github.com/node-schedule/node-schedule\" target=\"_blank\" rel=\"external\"><code>Node-Schedule</code></a> 这个 npm 包来进行任务定时器的操作：</p>\n<blockquote>\n<p>描述： A cron-like and not-cron-like job scheduler for Node.</p>\n</blockquote>\n<h3 id=\"安装方式：\"><a href=\"#安装方式：\" class=\"headerlink\" title=\"安装方式：\"></a>安装方式：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install node-schdule</div></pre></td></tr></table></figure>\n<h3 id=\"如何使用：\"><a href=\"#如何使用：\" class=\"headerlink\" title=\"如何使用：\"></a>如何使用：</h3><h4 id=\"任务定时器的创建：\"><a href=\"#任务定时器的创建：\" class=\"headerlink\" title=\"任务定时器的创建：\"></a>任务定时器的创建：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> schedule = <span class=\"built_in\">require</span>(<span class=\"string\">'node-schedule'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> j = schedule.scheduleJob(<span class=\"string\">'42 * * * *'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 每小时的第42分钟被执行</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'The answer to life, the universe, and everything!'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>scheduleJob()</code> 方法的回调函数用于实现具体定时任务执行的内容;</p>\n<h4 id=\"任务定时器的注销：\"><a href=\"#任务定时器的注销：\" class=\"headerlink\" title=\"任务定时器的注销：\"></a>任务定时器的注销：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">j.cancel();</div></pre></td></tr></table></figure>\n<h4 id=\"基于JS-Date类型的时间参数设置：\"><a href=\"#基于JS-Date类型的时间参数设置：\" class=\"headerlink\" title=\"基于JS Date类型的时间参数设置：\"></a>基于JS Date类型的时间参数设置：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> schedule = <span class=\"built_in\">require</span>(<span class=\"string\">'node-schedule'</span>);</div><div class=\"line\"><span class=\"comment\">// 2012年12月21日5时30分执行</span></div><div class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">2012</span>, <span class=\"number\">11</span>, <span class=\"number\">21</span>, <span class=\"number\">5</span>, <span class=\"number\">30</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> j = schedule.scheduleJob(date, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'The world is going to end today.'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>注意： 在使用 Date 设置参数是，月份的设定范围是 0~11 ，其中0代表一月，11代表十二月；</p>\n<h4 id=\"4-2-4-递归循环任务的设置：\"><a href=\"#4-2-4-递归循环任务的设置：\" class=\"headerlink\" title=\"4.2.4 递归循环任务的设置：\"></a>4.2.4 递归循环任务的设置：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> schedule = <span class=\"built_in\">require</span>(<span class=\"string\">'node-schedule'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> rule = <span class=\"keyword\">new</span> schedule.RecurrenceRule();</div><div class=\"line\"><span class=\"comment\">// 每小时的第 42 分钟执行</span></div><div class=\"line\">rule.minute = <span class=\"number\">42</span>;</div><div class=\"line\"><span class=\"comment\">// rule.dayOfWeek = 5;</span></div><div class=\"line\"><span class=\"comment\">// rule.month = 6;</span></div><div class=\"line\"><span class=\"comment\">// rule.dayOfMonth = 15;</span></div><div class=\"line\"><span class=\"comment\">// rule.hour = 1;</span></div><div class=\"line\"><span class=\"comment\">// rule.second = 0</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> j = schedule.scheduleJob(rule, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'The answer to life, the universe, and everything!'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"指定时间范围的设置：\"><a href=\"#指定时间范围的设置：\" class=\"headerlink\" title=\"指定时间范围的设置：\"></a>指定时间范围的设置：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> rule = <span class=\"keyword\">new</span> schedule.RecurrenceRule();</div><div class=\"line\"><span class=\"comment\">// 每个月的星期四、五、六、日的17点整执行</span></div><div class=\"line\">rule.dayOfWeek = [<span class=\"number\">0</span>, <span class=\"keyword\">new</span> schedule.Range(<span class=\"number\">4</span>, <span class=\"number\">6</span>)];</div><div class=\"line\">rule.hour = <span class=\"number\">17</span>;</div><div class=\"line\">rule.minute = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> j = schedule.scheduleJob(rule, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Today is recognized by Rebecca Black!'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>RecurrenceRule</code> 实例的每个cron属性可接受以数组的形式添加多个时间数值，<code>Range()</code>方法可指定一个范围的开始值及结束值;</p>\n<h4 id=\"通过对象字面量的方式设置：\"><a href=\"#通过对象字面量的方式设置：\" class=\"headerlink\" title=\"通过对象字面量的方式设置：\"></a>通过对象字面量的方式设置：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 每周日的14时30分执行</span></div><div class=\"line\"><span class=\"keyword\">var</span> j = schedule.scheduleJob(&#123;<span class=\"attr\">hour</span>: <span class=\"number\">14</span>, <span class=\"attr\">minute</span>: <span class=\"number\">30</span>, <span class=\"attr\">dayOfWeek</span>: <span class=\"number\">0</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Time for tea!'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"任务定时器的开始及结束时间设置：\"><a href=\"#任务定时器的开始及结束时间设置：\" class=\"headerlink\" title=\"任务定时器的开始及结束时间设置：\"></a>任务定时器的开始及结束时间设置：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 5秒后任务开始执行且10秒后任务结束，任务在此过程中每秒执行一次</span></div><div class=\"line\"><span class=\"keyword\">let</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"built_in\">Date</span>.now() + <span class=\"number\">5000</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> endTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(startTime.getTime() + <span class=\"number\">5000</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> j = schedule.scheduleJob(&#123; </div><div class=\"line\">    <span class=\"attr\">start</span>: startTime, </div><div class=\"line\">    <span class=\"attr\">end</span>: endTime, </div><div class=\"line\">    <span class=\"attr\">rule</span>: <span class=\"string\">'*/1 * * * * *'</span> </div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Time for tea!'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>参考：<br><a href=\"http://www.cnblogs.com/zhongweiv/p/node_schedule.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/zhongweiv/p/node_schedule.html</a><br><a href=\"http://www.codexiu.cn/javascript/blog/16175/\" target=\"_blank\" rel=\"external\">http://www.codexiu.cn/javascript/blog/16175/</a><br><a href=\"https://zh.wikipedia.org/wiki/Cron\" target=\"_blank\" rel=\"external\">https://zh.wikipedia.org/wiki/Cron</a></p>\n</blockquote>\n","excerpt":"<h2 id=\"什么是任务定时器：\"><a href=\"#什么是任务定时器：\" class=\"headerlink\" title=\"什么是任务定时器：\"></a>什么是任务定时器：</h2><blockquote>\n<p>能够在指定时间定期地执行命令、脚本或者程序，可以被用于系统的自动化维护及管理的工具；</p>\n</blockquote>\n<p>最常见的任务定时器当属 <code>Cron</code> ，该词源于希腊语 chronos，原意是时间；<br>在类 Unix 系统中，可以通过 <code>crontab</code> 命令设置定时任务执行的时间周期，然后 <code>cron</code> 的守护进程会在后台实时的检测是否有需要执行的任务，通常这些需要执行的任务被称为 <code>cron jobs</code>;</p>","more":"<h2 id=\"定时器的参数说明：\"><a href=\"#定时器的参数说明：\" class=\"headerlink\" title=\"定时器的参数说明：\"></a>定时器的参数说明：</h2><p><code>Cron</code> 在类 Unix 系统中有很多的实现，如：cronie、bcron、dcron、fcron 等；<br>虽然实现有多种，但是基于 <code>cron</code> 风格的时序参数结构却是相似的；</p>\n<p>这里展示了一个 cron 的时序参数格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">*    *    *    *    *    *</div><div class=\"line\">┬    ┬    ┬    ┬    ┬    ┬</div><div class=\"line\">│    │    │    │    │    |</div><div class=\"line\">│    │    │    │    │    └ day of week (0 - 7) (0 or 7 is Sun)</div><div class=\"line\">│    │    │    │    └───── month (1 - 12)</div><div class=\"line\">│    │    │    └────────── day of month (1 - 31)</div><div class=\"line\">│    │    └─────────────── hour (0 - 23)</div><div class=\"line\">│    └──────────────────── minute (0 - 59)</div><div class=\"line\">└───────────────────────── second (0 - 59, OPTIONAL)</div></pre></td></tr></table></figure>\n<p><code>*</code> 表示通配符，匹配任意，当秒为 ‘*’ 时，代表任意秒数都会触发执行；</p>\n<p>观察这组参数说明的过程中，发现了一个有趣的问题:</p>\n<p><code>Q</code>: 在 <code>day of week</code> 参数上，0 或 7 其实都可以代表星期日(Sunday)，WHY?<br><code>A</code>: 原因在于 <code>cron</code> 的众多实现版本里，对于这个参数，部分实现的设置为：0 - 6 =&gt; Sunday - Saturday，而另一部分实现的设置为：1 - 7 =&gt; Monday - Sunday，为了兼容，确保两种设置都正确，所以如上；</p>\n<h2 id=\"具体参数设置的试例：\"><a href=\"#具体参数设置的试例：\" class=\"headerlink\" title=\"具体参数设置的试例：\"></a>具体参数设置的试例：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">* * * * *           # 例1: 每1分钟执行一次</div><div class=\"line\"></div><div class=\"line\">3,15 * * * *        # 例2: 每小时的第3和第15分钟执行</div><div class=\"line\"></div><div class=\"line\">3,15 8-11 * * *     # 例3: 在每天上午8点到11点的第3和第15分钟执行</div><div class=\"line\"></div><div class=\"line\">3,15 8-11 */2 * *   # 例4：每隔两天的上午8点到11点的第3和第15分钟执行</div><div class=\"line\"></div><div class=\"line\">3,15 8-11 * * 1     # 例5：每周一的上午8点到11点的第3和第15分钟执行</div><div class=\"line\"></div><div class=\"line\">30 21 * * *         # 例6：每晚的21时30分执行</div><div class=\"line\"></div><div class=\"line\">45 4 1,10,22 * *    # 例7：每月的1、10、22日的4时45分执行</div><div class=\"line\"> </div><div class=\"line\">10 1 * * 6,0        # 例8：每周六、周日的1时10分执行</div><div class=\"line\"></div><div class=\"line\">0,30 18-23 * * *    # 例9：每天 18:00 至 23:00 之间每隔30分钟执行</div><div class=\"line\"></div><div class=\"line\">0 23 * * 6          # 例10：每星期六晚 23:00 执行</div><div class=\"line\"></div><div class=\"line\">* */1 * * *         # 例11：每隔1小时执行</div><div class=\"line\"></div><div class=\"line\">* 23-7/1 * * *      # 例12：晚上23时到次日7时之间每隔1小时执行</div></pre></td></tr></table></figure>\n<h2 id=\"任务定时器在-Node-中的使用\"><a href=\"#任务定时器在-Node-中的使用\" class=\"headerlink\" title=\"任务定时器在 Node 中的使用\"></a>任务定时器在 Node 中的使用</h2><p>在 Node.JS 中，可以使用 <a href=\"https://github.com/node-schedule/node-schedule\"><code>Node-Schedule</code></a> 这个 npm 包来进行任务定时器的操作：</p>\n<blockquote>\n<p>描述： A cron-like and not-cron-like job scheduler for Node.</p>\n</blockquote>\n<h3 id=\"安装方式：\"><a href=\"#安装方式：\" class=\"headerlink\" title=\"安装方式：\"></a>安装方式：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install node-schdule</div></pre></td></tr></table></figure>\n<h3 id=\"如何使用：\"><a href=\"#如何使用：\" class=\"headerlink\" title=\"如何使用：\"></a>如何使用：</h3><h4 id=\"任务定时器的创建：\"><a href=\"#任务定时器的创建：\" class=\"headerlink\" title=\"任务定时器的创建：\"></a>任务定时器的创建：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> schedule = <span class=\"built_in\">require</span>(<span class=\"string\">'node-schedule'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> j = schedule.scheduleJob(<span class=\"string\">'42 * * * *'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 每小时的第42分钟被执行</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'The answer to life, the universe, and everything!'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>scheduleJob()</code> 方法的回调函数用于实现具体定时任务执行的内容;</p>\n<h4 id=\"任务定时器的注销：\"><a href=\"#任务定时器的注销：\" class=\"headerlink\" title=\"任务定时器的注销：\"></a>任务定时器的注销：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">j.cancel();</div></pre></td></tr></table></figure>\n<h4 id=\"基于JS-Date类型的时间参数设置：\"><a href=\"#基于JS-Date类型的时间参数设置：\" class=\"headerlink\" title=\"基于JS Date类型的时间参数设置：\"></a>基于JS Date类型的时间参数设置：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> schedule = <span class=\"built_in\">require</span>(<span class=\"string\">'node-schedule'</span>);</div><div class=\"line\"><span class=\"comment\">// 2012年12月21日5时30分执行</span></div><div class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">2012</span>, <span class=\"number\">11</span>, <span class=\"number\">21</span>, <span class=\"number\">5</span>, <span class=\"number\">30</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> j = schedule.scheduleJob(date, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'The world is going to end today.'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>注意： 在使用 Date 设置参数是，月份的设定范围是 0~11 ，其中0代表一月，11代表十二月；</p>\n<h4 id=\"4-2-4-递归循环任务的设置：\"><a href=\"#4-2-4-递归循环任务的设置：\" class=\"headerlink\" title=\"4.2.4 递归循环任务的设置：\"></a>4.2.4 递归循环任务的设置：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> schedule = <span class=\"built_in\">require</span>(<span class=\"string\">'node-schedule'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> rule = <span class=\"keyword\">new</span> schedule.RecurrenceRule();</div><div class=\"line\"><span class=\"comment\">// 每小时的第 42 分钟执行</span></div><div class=\"line\">rule.minute = <span class=\"number\">42</span>;</div><div class=\"line\"><span class=\"comment\">// rule.dayOfWeek = 5;</span></div><div class=\"line\"><span class=\"comment\">// rule.month = 6;</span></div><div class=\"line\"><span class=\"comment\">// rule.dayOfMonth = 15;</span></div><div class=\"line\"><span class=\"comment\">// rule.hour = 1;</span></div><div class=\"line\"><span class=\"comment\">// rule.second = 0</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> j = schedule.scheduleJob(rule, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'The answer to life, the universe, and everything!'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"指定时间范围的设置：\"><a href=\"#指定时间范围的设置：\" class=\"headerlink\" title=\"指定时间范围的设置：\"></a>指定时间范围的设置：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> rule = <span class=\"keyword\">new</span> schedule.RecurrenceRule();</div><div class=\"line\"><span class=\"comment\">// 每个月的星期四、五、六、日的17点整执行</span></div><div class=\"line\">rule.dayOfWeek = [<span class=\"number\">0</span>, <span class=\"keyword\">new</span> schedule.Range(<span class=\"number\">4</span>, <span class=\"number\">6</span>)];</div><div class=\"line\">rule.hour = <span class=\"number\">17</span>;</div><div class=\"line\">rule.minute = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> j = schedule.scheduleJob(rule, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Today is recognized by Rebecca Black!'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>RecurrenceRule</code> 实例的每个cron属性可接受以数组的形式添加多个时间数值，<code>Range()</code>方法可指定一个范围的开始值及结束值;</p>\n<h4 id=\"通过对象字面量的方式设置：\"><a href=\"#通过对象字面量的方式设置：\" class=\"headerlink\" title=\"通过对象字面量的方式设置：\"></a>通过对象字面量的方式设置：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 每周日的14时30分执行</span></div><div class=\"line\"><span class=\"keyword\">var</span> j = schedule.scheduleJob(&#123;<span class=\"attr\">hour</span>: <span class=\"number\">14</span>, <span class=\"attr\">minute</span>: <span class=\"number\">30</span>, <span class=\"attr\">dayOfWeek</span>: <span class=\"number\">0</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Time for tea!'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"任务定时器的开始及结束时间设置：\"><a href=\"#任务定时器的开始及结束时间设置：\" class=\"headerlink\" title=\"任务定时器的开始及结束时间设置：\"></a>任务定时器的开始及结束时间设置：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 5秒后任务开始执行且10秒后任务结束，任务在此过程中每秒执行一次</span></div><div class=\"line\"><span class=\"keyword\">let</span> startTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"built_in\">Date</span>.now() + <span class=\"number\">5000</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> endTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(startTime.getTime() + <span class=\"number\">5000</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> j = schedule.scheduleJob(&#123; </div><div class=\"line\">    <span class=\"attr\">start</span>: startTime, </div><div class=\"line\">    <span class=\"attr\">end</span>: endTime, </div><div class=\"line\">    <span class=\"attr\">rule</span>: <span class=\"string\">'*/1 * * * * *'</span> </div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Time for tea!'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>参考：<br><a href=\"http://www.cnblogs.com/zhongweiv/p/node_schedule.html\">http://www.cnblogs.com/zhongweiv/p/node_schedule.html</a><br><a href=\"http://www.codexiu.cn/javascript/blog/16175/\">http://www.codexiu.cn/javascript/blog/16175/</a><br><a href=\"https://zh.wikipedia.org/wiki/Cron\">https://zh.wikipedia.org/wiki/Cron</a></p>\n</blockquote>"},{"title":"WebSocket学习笔记","date":"2016-01-19T05:54:31.000Z","type":"tags","_content":"\nHTTP 协议是一种无状态协议，服务器端本身不具备识别客户端的能力，必须借助外部机制，比如 session 和 cookie 才能与特定客户端保持对话。那么如果我们遇到一种需求，它要求保证服务器端与客户端持续的数据交换，比如网络聊天，那再使用 HTTP 协议就会有不便，这时我们就需要用到 Websocket API了。\n\n<!--more-->\n\n---\n\n### 概述 ：\n\nWebSocket 的主要作用：允许服务器端与客户端进行全双工（full-duplex）的通信。\n举例来说，\nHTTP 协议有点像发电子邮件，发出后必须等待对方回信；\nWebSocket 则是像打电话，服务器端和客户端可以同时向对方发送数据，它们之间存着一条持续打开的数据通道。\n\nWebSocket 协议完全可以取代 Ajax 方法，用来向服务器端发送文本和二进制数据，而且还没有“同域限制”。\n\nWebSocket 不使用 HTTP 协议，浏览器在发送 Websocket 请求时，会将 HTTP 协议升级（Upgrade）为 webSocket 自己的协议。\n\n> WebSocket 协议用 ws 表示。此外，还有 wss 协议，表示加密的 WebSocket 协议，对应 HTTPs 协议。\n\n在完成TCP协议三次握手之后，WebSocket 协议就在 TCP 协议之上，开始数据的传送。\n\nWebSocket 协议需要服务器支持，目前比较流行的实现是基于 node.js 的 socket.io ，至于浏览器端，目前主流浏览器都支持 WebSocket 协议。\n\n \n### 客户端 ：\n\n浏览器端对WebSocket协议的处理，主要归纳为三件事：\n\n* 建立连接和断开连接\n* 发送数据和接收数据\n* 处理错误\n\n#### 建立连接和断开连接\n\n首先，客户端要检查浏览器是否支持 WebSocket ，使用的方法是查看 window 对象是否具有 WebSocket 属性。\n\n\tif(window.WebSocket != undefined) {\n    \t// WebSocket代码\n\t}\n\n然后，开始与服务器建立连接（这里假定服务器就是本机的1740端口，需要使用ws协议）。\n\n\tif(window.WebSocket != undefined) {\n    \tvar connection = new WebSocket('ws://localhost:1740');\n\t}\n\n建立连接以后的 WebSocket 实例对象（即上面代码中的connection），有一个readyState属性，表示目前的状态，可以取4个值：\n\n\t0： 正在连接\n\t1： 连接成功\n\t2： 正在关闭\n\t3： 连接关闭\n\n握手协议成功以后，readyState 就从 0 变为 1 ，并触发 open 事件，这时就可以向服务器发送信息了。我们可以指定 open 事件的回调函数。\n\n\tconnection.onopen = wsOpen;\n\n\tfunction wsOpen (event) {\n    \tconsole.log('Connected to: ' + event.currentTarget.URL);\n\t}\n\t\n关闭 WebSocket 连接，会触发 close 事件。\n\n\tconnection.onclose = wsClose;\n\n\tfunction wsClose () {\n    \tconsole.log(\"Closed\");\n\t}\n\n\tconnection.close();\n\n\n#### 发送数据和接收数据\n\n连接建立后，客户端通过 send 方法向服务器端发送数据。\n\n\tconnection.send(message);\n\t\n除了发送字符串，也可以使用 Blob 或 ArrayBuffer 对象发送二进制数据。\n\n\t// 使用ArrayBuffer发送canvas图像数据\n\tvar img = canvas_context.getImageData(0, 0, 400, 320);\n\tvar binary = new Uint8Array(img.data.length);\n\tfor (var i = 0; i < img.data.length; i++) {\n    \tbinary[i] = img.data[i];\n\t}\n\tconnection.send(binary.buffer);\n\n\t// 使用Blob发送文件\n\tvar file = document.querySelector('input[type=\"file\"]').files[0];\n\tconnection.send(file);\n\t\n客户端收到服务器发送的数据，会触发 message 事件。可以通过定义 message 事件的回调函数，来处理服务端返回的数据。\n\n\tconnection.onmessage = wsMessage;\n\n\tfunction wsMessage (event) {\n    \tconsole.log(event.data);\n\t}\n\t\n上面代码的回调函数 wsMessage 的参数为事件对象 event ，该对象的 data 属性包含了服务器返回的数据。\n\n如果接收的是二进制数据，需要将连接对象的格式设为 blob 或 arraybuffer。\n\n\tconnection.binaryType = 'arraybuffer';\n\n\tconnection.onmessage = function(e) {\n  \t\t// ArrayBuffer对象有byteLength属性\n  \t\tconsole.log(e.data.byteLength); \n\t};\n\n#### 处理错误\n\n如果出现错误，浏览器会触发WebSocket实例对象的error事件。\n\n\tconnection.onerror = wsError;\n\n\tfunction wsError(event) {\n    \tconsole.log(\"Error: \" + event.data);\n\t}\n\t\n\n### 服务端 ：\n\n服务器端需要单独部署处理 WebSocket 的代码。下面用 node.js 搭建一个服务器环境。\n\n\tvar http = require('http');\n\tvar server = http.createServer(function(request, response) {});\n\n假设监听 1740 端口。\n\n\tserver.listen(1740, function() {\n    \tconsole.log((new Date()) + ' Server is listening on port 1740');\n\t});\n\t\n接着启动 WebSocket 服务器。这需要加载websocket库，如果没有安装，可以先使用npm命令安装。\n\n\tvar WebSocketServer = require('websocket').server;\n\tvar wsServer = new WebSocketServer({\n    \thttpServer: server\n\t});\nWebSocket服务器建立 request 事件的回调函数。\n\n\tvar connection;\n\n\twsServer.on('request', function(req){\n    \tconnection = req.accept('echo-protocol', req.origin);\n\t});\n\t\n上面代码的回调函数接受一个参数 req ，表示 request 请求对象。然后，在回调函数内部，建立WebSocket连接connection。接着，就要对connection的message事件指定回调函数。\n\n\twsServer.on('request', function(r){\n    \tconnection = req.accept('echo-protocol', req.origin);\n\n    \tconnection.on('message', function(message) {\n        \tvar msgString = message.utf8Data;\n        \tconnection.sendUTF(msgString);\n    \t});\n\t});\n\t\n最后，监听用户的 disconnect 事件。\n\n\tconnection.on('close', function(reasonCode, description) {\n    \tconsole.log(connection.remoteAddress + ' disconnected.');\n\t});\n\t\n使用 [ws](https://github.com/websockets/ws) 模块，部署一个简单的 WebSocket 服务器非常容易。\n\n\tvar WebSocketServer = require('ws').Server;\n\tvar wss = new WebSocketServer({ port: 8080 });\n\n\twss.on('connection', function connection(ws) {\n  \t\tws.on('message', function incoming(message) {\n    \t\tconsole.log('received: %s', message);\n  \t\t});\n\n  \t\tws.send('something');\n\t});\n\n### Socket.IO ：\n\nSocket.io 是目前最流行的 WebSocket 实现，包括服务器和客户端两个部分。它不仅简化了接口，使得操作更容易，而且对于那些不支持 WebSocket 的浏览器，会自动降为 Ajax 连接，最大限度地保证了兼容性。它的目标是统一通信机制，使得所有浏览器和移动设备都可以进行实时通信。\n\n第一步，在服务器端的项目根目录下，安装 socket.io 模块。\n\n\t$ npm install socket.io\n\t\n第二步，在根目录下建立 app.js ，并写入以下代码（假定使用了Express框架）。\n\n\tvar app = require('express')();\n\tvar server = require('http').createServer(app);\n\tvar io = require('socket.io').listen(server);\n\n\tserver.listen(80);\n\n\tapp.get('/', function (req, res) {\n  \t\tres.sendfile(__dirname + '/index.html');\n\t});\n\t\n上面代码表示，先建立并运行 HTTP 服务器。Socket.io 的运行建立在 HTTP 服务器之上。\n\n第三步，将 Socket.io 插入客户端网页。\n\n\t<script src=\"/socket.io/socket.io.js\"></script>\n\t\n然后，在客户端脚本中，建立 WebSocket 连接。\n\n\tvar socket = io.connect('http://localhost');\n\t\n由于本例假定 WebSocket 主机与客户端是同一台机器，所以 connect 方法的参数是 http://localhost。接着，指定 news 事件（即服务器端发送news）的回调函数。\n\n\tsocket.on('news', function (data){\n   \t\tconsole.log(data);\n\t});\n\t\n最后，用 emit 方法向服务器端发送信号，触发服务器端的 anotherNews 事件。\n\n\tsocket.emit('anotherNews');\n\t\n> 请注意，emit 方法可以取代 Ajax 请求，而on方法指定的回调函数，也等同于 Ajax 的回调函数。\n\n第四步，在服务器端的 app.js，加入以下代码。\n\n\t//广播信息给除当前用户之外的用户\n    socket.broadcast.emit('user connected');\n    \n    //广播给全体客户端\n\tio.sockets.on('connection', function (socket) {\n  \t\tsocket.emit('news', { hello: 'world' });\n  \t\tsocket.on('anotherNews', function (data) {\n    \t\tconsole.log(data);\n  \t\t});\n\t});\n\t\n上面代码的 io.sockets.on 方法指定 connection 事件（ WebSocket 连接建立）的回调函数。在回调函数中，用 emit 方法向客户端发送数据，触发客户端的 news 事件。然后，再用 on 方法指定服务器端anotherNews 事件的回调函数。\n\n> 不管是服务器还是客户端，socket.io 提供两个核心方法：\nemit方法用于发送消息，on方法用于监听对方发送的消息。\n\n\n---\n参考：\n\n* [JavaScript标准参考教程](http://javascript.ruanyifeng.com/htmlapi/websocket.html \"JavaScript标准参考教程\")\n","source":"_posts/WebSocketNote.md","raw":"title: \"WebSocket学习笔记\"\ndate: 2016-01-19 13:54:31\ncategories: \"技术\" \ntags: \n  - websocket\n  - socket.io\ntype: \"tags\"\n---\n\nHTTP 协议是一种无状态协议，服务器端本身不具备识别客户端的能力，必须借助外部机制，比如 session 和 cookie 才能与特定客户端保持对话。那么如果我们遇到一种需求，它要求保证服务器端与客户端持续的数据交换，比如网络聊天，那再使用 HTTP 协议就会有不便，这时我们就需要用到 Websocket API了。\n\n<!--more-->\n\n---\n\n### 概述 ：\n\nWebSocket 的主要作用：允许服务器端与客户端进行全双工（full-duplex）的通信。\n举例来说，\nHTTP 协议有点像发电子邮件，发出后必须等待对方回信；\nWebSocket 则是像打电话，服务器端和客户端可以同时向对方发送数据，它们之间存着一条持续打开的数据通道。\n\nWebSocket 协议完全可以取代 Ajax 方法，用来向服务器端发送文本和二进制数据，而且还没有“同域限制”。\n\nWebSocket 不使用 HTTP 协议，浏览器在发送 Websocket 请求时，会将 HTTP 协议升级（Upgrade）为 webSocket 自己的协议。\n\n> WebSocket 协议用 ws 表示。此外，还有 wss 协议，表示加密的 WebSocket 协议，对应 HTTPs 协议。\n\n在完成TCP协议三次握手之后，WebSocket 协议就在 TCP 协议之上，开始数据的传送。\n\nWebSocket 协议需要服务器支持，目前比较流行的实现是基于 node.js 的 socket.io ，至于浏览器端，目前主流浏览器都支持 WebSocket 协议。\n\n \n### 客户端 ：\n\n浏览器端对WebSocket协议的处理，主要归纳为三件事：\n\n* 建立连接和断开连接\n* 发送数据和接收数据\n* 处理错误\n\n#### 建立连接和断开连接\n\n首先，客户端要检查浏览器是否支持 WebSocket ，使用的方法是查看 window 对象是否具有 WebSocket 属性。\n\n\tif(window.WebSocket != undefined) {\n    \t// WebSocket代码\n\t}\n\n然后，开始与服务器建立连接（这里假定服务器就是本机的1740端口，需要使用ws协议）。\n\n\tif(window.WebSocket != undefined) {\n    \tvar connection = new WebSocket('ws://localhost:1740');\n\t}\n\n建立连接以后的 WebSocket 实例对象（即上面代码中的connection），有一个readyState属性，表示目前的状态，可以取4个值：\n\n\t0： 正在连接\n\t1： 连接成功\n\t2： 正在关闭\n\t3： 连接关闭\n\n握手协议成功以后，readyState 就从 0 变为 1 ，并触发 open 事件，这时就可以向服务器发送信息了。我们可以指定 open 事件的回调函数。\n\n\tconnection.onopen = wsOpen;\n\n\tfunction wsOpen (event) {\n    \tconsole.log('Connected to: ' + event.currentTarget.URL);\n\t}\n\t\n关闭 WebSocket 连接，会触发 close 事件。\n\n\tconnection.onclose = wsClose;\n\n\tfunction wsClose () {\n    \tconsole.log(\"Closed\");\n\t}\n\n\tconnection.close();\n\n\n#### 发送数据和接收数据\n\n连接建立后，客户端通过 send 方法向服务器端发送数据。\n\n\tconnection.send(message);\n\t\n除了发送字符串，也可以使用 Blob 或 ArrayBuffer 对象发送二进制数据。\n\n\t// 使用ArrayBuffer发送canvas图像数据\n\tvar img = canvas_context.getImageData(0, 0, 400, 320);\n\tvar binary = new Uint8Array(img.data.length);\n\tfor (var i = 0; i < img.data.length; i++) {\n    \tbinary[i] = img.data[i];\n\t}\n\tconnection.send(binary.buffer);\n\n\t// 使用Blob发送文件\n\tvar file = document.querySelector('input[type=\"file\"]').files[0];\n\tconnection.send(file);\n\t\n客户端收到服务器发送的数据，会触发 message 事件。可以通过定义 message 事件的回调函数，来处理服务端返回的数据。\n\n\tconnection.onmessage = wsMessage;\n\n\tfunction wsMessage (event) {\n    \tconsole.log(event.data);\n\t}\n\t\n上面代码的回调函数 wsMessage 的参数为事件对象 event ，该对象的 data 属性包含了服务器返回的数据。\n\n如果接收的是二进制数据，需要将连接对象的格式设为 blob 或 arraybuffer。\n\n\tconnection.binaryType = 'arraybuffer';\n\n\tconnection.onmessage = function(e) {\n  \t\t// ArrayBuffer对象有byteLength属性\n  \t\tconsole.log(e.data.byteLength); \n\t};\n\n#### 处理错误\n\n如果出现错误，浏览器会触发WebSocket实例对象的error事件。\n\n\tconnection.onerror = wsError;\n\n\tfunction wsError(event) {\n    \tconsole.log(\"Error: \" + event.data);\n\t}\n\t\n\n### 服务端 ：\n\n服务器端需要单独部署处理 WebSocket 的代码。下面用 node.js 搭建一个服务器环境。\n\n\tvar http = require('http');\n\tvar server = http.createServer(function(request, response) {});\n\n假设监听 1740 端口。\n\n\tserver.listen(1740, function() {\n    \tconsole.log((new Date()) + ' Server is listening on port 1740');\n\t});\n\t\n接着启动 WebSocket 服务器。这需要加载websocket库，如果没有安装，可以先使用npm命令安装。\n\n\tvar WebSocketServer = require('websocket').server;\n\tvar wsServer = new WebSocketServer({\n    \thttpServer: server\n\t});\nWebSocket服务器建立 request 事件的回调函数。\n\n\tvar connection;\n\n\twsServer.on('request', function(req){\n    \tconnection = req.accept('echo-protocol', req.origin);\n\t});\n\t\n上面代码的回调函数接受一个参数 req ，表示 request 请求对象。然后，在回调函数内部，建立WebSocket连接connection。接着，就要对connection的message事件指定回调函数。\n\n\twsServer.on('request', function(r){\n    \tconnection = req.accept('echo-protocol', req.origin);\n\n    \tconnection.on('message', function(message) {\n        \tvar msgString = message.utf8Data;\n        \tconnection.sendUTF(msgString);\n    \t});\n\t});\n\t\n最后，监听用户的 disconnect 事件。\n\n\tconnection.on('close', function(reasonCode, description) {\n    \tconsole.log(connection.remoteAddress + ' disconnected.');\n\t});\n\t\n使用 [ws](https://github.com/websockets/ws) 模块，部署一个简单的 WebSocket 服务器非常容易。\n\n\tvar WebSocketServer = require('ws').Server;\n\tvar wss = new WebSocketServer({ port: 8080 });\n\n\twss.on('connection', function connection(ws) {\n  \t\tws.on('message', function incoming(message) {\n    \t\tconsole.log('received: %s', message);\n  \t\t});\n\n  \t\tws.send('something');\n\t});\n\n### Socket.IO ：\n\nSocket.io 是目前最流行的 WebSocket 实现，包括服务器和客户端两个部分。它不仅简化了接口，使得操作更容易，而且对于那些不支持 WebSocket 的浏览器，会自动降为 Ajax 连接，最大限度地保证了兼容性。它的目标是统一通信机制，使得所有浏览器和移动设备都可以进行实时通信。\n\n第一步，在服务器端的项目根目录下，安装 socket.io 模块。\n\n\t$ npm install socket.io\n\t\n第二步，在根目录下建立 app.js ，并写入以下代码（假定使用了Express框架）。\n\n\tvar app = require('express')();\n\tvar server = require('http').createServer(app);\n\tvar io = require('socket.io').listen(server);\n\n\tserver.listen(80);\n\n\tapp.get('/', function (req, res) {\n  \t\tres.sendfile(__dirname + '/index.html');\n\t});\n\t\n上面代码表示，先建立并运行 HTTP 服务器。Socket.io 的运行建立在 HTTP 服务器之上。\n\n第三步，将 Socket.io 插入客户端网页。\n\n\t<script src=\"/socket.io/socket.io.js\"></script>\n\t\n然后，在客户端脚本中，建立 WebSocket 连接。\n\n\tvar socket = io.connect('http://localhost');\n\t\n由于本例假定 WebSocket 主机与客户端是同一台机器，所以 connect 方法的参数是 http://localhost。接着，指定 news 事件（即服务器端发送news）的回调函数。\n\n\tsocket.on('news', function (data){\n   \t\tconsole.log(data);\n\t});\n\t\n最后，用 emit 方法向服务器端发送信号，触发服务器端的 anotherNews 事件。\n\n\tsocket.emit('anotherNews');\n\t\n> 请注意，emit 方法可以取代 Ajax 请求，而on方法指定的回调函数，也等同于 Ajax 的回调函数。\n\n第四步，在服务器端的 app.js，加入以下代码。\n\n\t//广播信息给除当前用户之外的用户\n    socket.broadcast.emit('user connected');\n    \n    //广播给全体客户端\n\tio.sockets.on('connection', function (socket) {\n  \t\tsocket.emit('news', { hello: 'world' });\n  \t\tsocket.on('anotherNews', function (data) {\n    \t\tconsole.log(data);\n  \t\t});\n\t});\n\t\n上面代码的 io.sockets.on 方法指定 connection 事件（ WebSocket 连接建立）的回调函数。在回调函数中，用 emit 方法向客户端发送数据，触发客户端的 news 事件。然后，再用 on 方法指定服务器端anotherNews 事件的回调函数。\n\n> 不管是服务器还是客户端，socket.io 提供两个核心方法：\nemit方法用于发送消息，on方法用于监听对方发送的消息。\n\n\n---\n参考：\n\n* [JavaScript标准参考教程](http://javascript.ruanyifeng.com/htmlapi/websocket.html \"JavaScript标准参考教程\")\n","slug":"WebSocketNote","published":1,"updated":"2017-04-06T13:28:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1nm195k001armup686b6ayw","content":"<p>HTTP 协议是一种无状态协议，服务器端本身不具备识别客户端的能力，必须借助外部机制，比如 session 和 cookie 才能与特定客户端保持对话。那么如果我们遇到一种需求，它要求保证服务器端与客户端持续的数据交换，比如网络聊天，那再使用 HTTP 协议就会有不便，这时我们就需要用到 Websocket API了。</p>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"概述-：\"><a href=\"#概述-：\" class=\"headerlink\" title=\"概述 ：\"></a>概述 ：</h3><p>WebSocket 的主要作用：允许服务器端与客户端进行全双工（full-duplex）的通信。<br>举例来说，<br>HTTP 协议有点像发电子邮件，发出后必须等待对方回信；<br>WebSocket 则是像打电话，服务器端和客户端可以同时向对方发送数据，它们之间存着一条持续打开的数据通道。</p>\n<p>WebSocket 协议完全可以取代 Ajax 方法，用来向服务器端发送文本和二进制数据，而且还没有“同域限制”。</p>\n<p>WebSocket 不使用 HTTP 协议，浏览器在发送 Websocket 请求时，会将 HTTP 协议升级（Upgrade）为 webSocket 自己的协议。</p>\n<blockquote>\n<p>WebSocket 协议用 ws 表示。此外，还有 wss 协议，表示加密的 WebSocket 协议，对应 HTTPs 协议。</p>\n</blockquote>\n<p>在完成TCP协议三次握手之后，WebSocket 协议就在 TCP 协议之上，开始数据的传送。</p>\n<p>WebSocket 协议需要服务器支持，目前比较流行的实现是基于 node.js 的 socket.io ，至于浏览器端，目前主流浏览器都支持 WebSocket 协议。</p>\n<h3 id=\"客户端-：\"><a href=\"#客户端-：\" class=\"headerlink\" title=\"客户端 ：\"></a>客户端 ：</h3><p>浏览器端对WebSocket协议的处理，主要归纳为三件事：</p>\n<ul>\n<li>建立连接和断开连接</li>\n<li>发送数据和接收数据</li>\n<li>处理错误</li>\n</ul>\n<h4 id=\"建立连接和断开连接\"><a href=\"#建立连接和断开连接\" class=\"headerlink\" title=\"建立连接和断开连接\"></a>建立连接和断开连接</h4><p>首先，客户端要检查浏览器是否支持 WebSocket ，使用的方法是查看 window 对象是否具有 WebSocket 属性。</p>\n<pre><code>if(window.WebSocket != undefined) {\n    // WebSocket代码\n}\n</code></pre><p>然后，开始与服务器建立连接（这里假定服务器就是本机的1740端口，需要使用ws协议）。</p>\n<pre><code>if(window.WebSocket != undefined) {\n    var connection = new WebSocket(&apos;ws://localhost:1740&apos;);\n}\n</code></pre><p>建立连接以后的 WebSocket 实例对象（即上面代码中的connection），有一个readyState属性，表示目前的状态，可以取4个值：</p>\n<pre><code>0： 正在连接\n1： 连接成功\n2： 正在关闭\n3： 连接关闭\n</code></pre><p>握手协议成功以后，readyState 就从 0 变为 1 ，并触发 open 事件，这时就可以向服务器发送信息了。我们可以指定 open 事件的回调函数。</p>\n<pre><code>connection.onopen = wsOpen;\n\nfunction wsOpen (event) {\n    console.log(&apos;Connected to: &apos; + event.currentTarget.URL);\n}\n</code></pre><p>关闭 WebSocket 连接，会触发 close 事件。</p>\n<pre><code>connection.onclose = wsClose;\n\nfunction wsClose () {\n    console.log(&quot;Closed&quot;);\n}\n\nconnection.close();\n</code></pre><h4 id=\"发送数据和接收数据\"><a href=\"#发送数据和接收数据\" class=\"headerlink\" title=\"发送数据和接收数据\"></a>发送数据和接收数据</h4><p>连接建立后，客户端通过 send 方法向服务器端发送数据。</p>\n<pre><code>connection.send(message);\n</code></pre><p>除了发送字符串，也可以使用 Blob 或 ArrayBuffer 对象发送二进制数据。</p>\n<pre><code>// 使用ArrayBuffer发送canvas图像数据\nvar img = canvas_context.getImageData(0, 0, 400, 320);\nvar binary = new Uint8Array(img.data.length);\nfor (var i = 0; i &lt; img.data.length; i++) {\n    binary[i] = img.data[i];\n}\nconnection.send(binary.buffer);\n\n// 使用Blob发送文件\nvar file = document.querySelector(&apos;input[type=&quot;file&quot;]&apos;).files[0];\nconnection.send(file);\n</code></pre><p>客户端收到服务器发送的数据，会触发 message 事件。可以通过定义 message 事件的回调函数，来处理服务端返回的数据。</p>\n<pre><code>connection.onmessage = wsMessage;\n\nfunction wsMessage (event) {\n    console.log(event.data);\n}\n</code></pre><p>上面代码的回调函数 wsMessage 的参数为事件对象 event ，该对象的 data 属性包含了服务器返回的数据。</p>\n<p>如果接收的是二进制数据，需要将连接对象的格式设为 blob 或 arraybuffer。</p>\n<pre><code>connection.binaryType = &apos;arraybuffer&apos;;\n\nconnection.onmessage = function(e) {\n      // ArrayBuffer对象有byteLength属性\n      console.log(e.data.byteLength); \n};\n</code></pre><h4 id=\"处理错误\"><a href=\"#处理错误\" class=\"headerlink\" title=\"处理错误\"></a>处理错误</h4><p>如果出现错误，浏览器会触发WebSocket实例对象的error事件。</p>\n<pre><code>connection.onerror = wsError;\n\nfunction wsError(event) {\n    console.log(&quot;Error: &quot; + event.data);\n}\n</code></pre><h3 id=\"服务端-：\"><a href=\"#服务端-：\" class=\"headerlink\" title=\"服务端 ：\"></a>服务端 ：</h3><p>服务器端需要单独部署处理 WebSocket 的代码。下面用 node.js 搭建一个服务器环境。</p>\n<pre><code>var http = require(&apos;http&apos;);\nvar server = http.createServer(function(request, response) {});\n</code></pre><p>假设监听 1740 端口。</p>\n<pre><code>server.listen(1740, function() {\n    console.log((new Date()) + &apos; Server is listening on port 1740&apos;);\n});\n</code></pre><p>接着启动 WebSocket 服务器。这需要加载websocket库，如果没有安装，可以先使用npm命令安装。</p>\n<pre><code>var WebSocketServer = require(&apos;websocket&apos;).server;\nvar wsServer = new WebSocketServer({\n    httpServer: server\n});\n</code></pre><p>WebSocket服务器建立 request 事件的回调函数。</p>\n<pre><code>var connection;\n\nwsServer.on(&apos;request&apos;, function(req){\n    connection = req.accept(&apos;echo-protocol&apos;, req.origin);\n});\n</code></pre><p>上面代码的回调函数接受一个参数 req ，表示 request 请求对象。然后，在回调函数内部，建立WebSocket连接connection。接着，就要对connection的message事件指定回调函数。</p>\n<pre><code>wsServer.on(&apos;request&apos;, function(r){\n    connection = req.accept(&apos;echo-protocol&apos;, req.origin);\n\n    connection.on(&apos;message&apos;, function(message) {\n        var msgString = message.utf8Data;\n        connection.sendUTF(msgString);\n    });\n});\n</code></pre><p>最后，监听用户的 disconnect 事件。</p>\n<pre><code>connection.on(&apos;close&apos;, function(reasonCode, description) {\n    console.log(connection.remoteAddress + &apos; disconnected.&apos;);\n});\n</code></pre><p>使用 <a href=\"https://github.com/websockets/ws\" target=\"_blank\" rel=\"external\">ws</a> 模块，部署一个简单的 WebSocket 服务器非常容易。</p>\n<pre><code>var WebSocketServer = require(&apos;ws&apos;).Server;\nvar wss = new WebSocketServer({ port: 8080 });\n\nwss.on(&apos;connection&apos;, function connection(ws) {\n      ws.on(&apos;message&apos;, function incoming(message) {\n        console.log(&apos;received: %s&apos;, message);\n      });\n\n      ws.send(&apos;something&apos;);\n});\n</code></pre><h3 id=\"Socket-IO-：\"><a href=\"#Socket-IO-：\" class=\"headerlink\" title=\"Socket.IO ：\"></a>Socket.IO ：</h3><p>Socket.io 是目前最流行的 WebSocket 实现，包括服务器和客户端两个部分。它不仅简化了接口，使得操作更容易，而且对于那些不支持 WebSocket 的浏览器，会自动降为 Ajax 连接，最大限度地保证了兼容性。它的目标是统一通信机制，使得所有浏览器和移动设备都可以进行实时通信。</p>\n<p>第一步，在服务器端的项目根目录下，安装 socket.io 模块。</p>\n<pre><code>$ npm install socket.io\n</code></pre><p>第二步，在根目录下建立 app.js ，并写入以下代码（假定使用了Express框架）。</p>\n<pre><code>var app = require(&apos;express&apos;)();\nvar server = require(&apos;http&apos;).createServer(app);\nvar io = require(&apos;socket.io&apos;).listen(server);\n\nserver.listen(80);\n\napp.get(&apos;/&apos;, function (req, res) {\n      res.sendfile(__dirname + &apos;/index.html&apos;);\n});\n</code></pre><p>上面代码表示，先建立并运行 HTTP 服务器。Socket.io 的运行建立在 HTTP 服务器之上。</p>\n<p>第三步，将 Socket.io 插入客户端网页。</p>\n<pre><code>&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>然后，在客户端脚本中，建立 WebSocket 连接。</p>\n<pre><code>var socket = io.connect(&apos;http://localhost&apos;);\n</code></pre><p>由于本例假定 WebSocket 主机与客户端是同一台机器，所以 connect 方法的参数是 <a href=\"http://localhost。接着，指定\" target=\"_blank\" rel=\"external\">http://localhost。接着，指定</a> news 事件（即服务器端发送news）的回调函数。</p>\n<pre><code>socket.on(&apos;news&apos;, function (data){\n       console.log(data);\n});\n</code></pre><p>最后，用 emit 方法向服务器端发送信号，触发服务器端的 anotherNews 事件。</p>\n<pre><code>socket.emit(&apos;anotherNews&apos;);\n</code></pre><blockquote>\n<p>请注意，emit 方法可以取代 Ajax 请求，而on方法指定的回调函数，也等同于 Ajax 的回调函数。</p>\n</blockquote>\n<p>第四步，在服务器端的 app.js，加入以下代码。</p>\n<pre><code>//广播信息给除当前用户之外的用户\nsocket.broadcast.emit(&apos;user connected&apos;);\n\n//广播给全体客户端\nio.sockets.on(&apos;connection&apos;, function (socket) {\n      socket.emit(&apos;news&apos;, { hello: &apos;world&apos; });\n      socket.on(&apos;anotherNews&apos;, function (data) {\n        console.log(data);\n      });\n});\n</code></pre><p>上面代码的 io.sockets.on 方法指定 connection 事件（ WebSocket 连接建立）的回调函数。在回调函数中，用 emit 方法向客户端发送数据，触发客户端的 news 事件。然后，再用 on 方法指定服务器端anotherNews 事件的回调函数。</p>\n<blockquote>\n<p>不管是服务器还是客户端，socket.io 提供两个核心方法：<br>emit方法用于发送消息，on方法用于监听对方发送的消息。</p>\n</blockquote>\n<hr>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://javascript.ruanyifeng.com/htmlapi/websocket.html\" title=\"JavaScript标准参考教程\" target=\"_blank\" rel=\"external\">JavaScript标准参考教程</a></li>\n</ul>\n","excerpt":"<p>HTTP 协议是一种无状态协议，服务器端本身不具备识别客户端的能力，必须借助外部机制，比如 session 和 cookie 才能与特定客户端保持对话。那么如果我们遇到一种需求，它要求保证服务器端与客户端持续的数据交换，比如网络聊天，那再使用 HTTP 协议就会有不便，这时我们就需要用到 Websocket API了。</p>","more":"<hr>\n<h3 id=\"概述-：\"><a href=\"#概述-：\" class=\"headerlink\" title=\"概述 ：\"></a>概述 ：</h3><p>WebSocket 的主要作用：允许服务器端与客户端进行全双工（full-duplex）的通信。<br>举例来说，<br>HTTP 协议有点像发电子邮件，发出后必须等待对方回信；<br>WebSocket 则是像打电话，服务器端和客户端可以同时向对方发送数据，它们之间存着一条持续打开的数据通道。</p>\n<p>WebSocket 协议完全可以取代 Ajax 方法，用来向服务器端发送文本和二进制数据，而且还没有“同域限制”。</p>\n<p>WebSocket 不使用 HTTP 协议，浏览器在发送 Websocket 请求时，会将 HTTP 协议升级（Upgrade）为 webSocket 自己的协议。</p>\n<blockquote>\n<p>WebSocket 协议用 ws 表示。此外，还有 wss 协议，表示加密的 WebSocket 协议，对应 HTTPs 协议。</p>\n</blockquote>\n<p>在完成TCP协议三次握手之后，WebSocket 协议就在 TCP 协议之上，开始数据的传送。</p>\n<p>WebSocket 协议需要服务器支持，目前比较流行的实现是基于 node.js 的 socket.io ，至于浏览器端，目前主流浏览器都支持 WebSocket 协议。</p>\n<h3 id=\"客户端-：\"><a href=\"#客户端-：\" class=\"headerlink\" title=\"客户端 ：\"></a>客户端 ：</h3><p>浏览器端对WebSocket协议的处理，主要归纳为三件事：</p>\n<ul>\n<li>建立连接和断开连接</li>\n<li>发送数据和接收数据</li>\n<li>处理错误</li>\n</ul>\n<h4 id=\"建立连接和断开连接\"><a href=\"#建立连接和断开连接\" class=\"headerlink\" title=\"建立连接和断开连接\"></a>建立连接和断开连接</h4><p>首先，客户端要检查浏览器是否支持 WebSocket ，使用的方法是查看 window 对象是否具有 WebSocket 属性。</p>\n<pre><code>if(window.WebSocket != undefined) {\n    // WebSocket代码\n}\n</code></pre><p>然后，开始与服务器建立连接（这里假定服务器就是本机的1740端口，需要使用ws协议）。</p>\n<pre><code>if(window.WebSocket != undefined) {\n    var connection = new WebSocket(&apos;ws://localhost:1740&apos;);\n}\n</code></pre><p>建立连接以后的 WebSocket 实例对象（即上面代码中的connection），有一个readyState属性，表示目前的状态，可以取4个值：</p>\n<pre><code>0： 正在连接\n1： 连接成功\n2： 正在关闭\n3： 连接关闭\n</code></pre><p>握手协议成功以后，readyState 就从 0 变为 1 ，并触发 open 事件，这时就可以向服务器发送信息了。我们可以指定 open 事件的回调函数。</p>\n<pre><code>connection.onopen = wsOpen;\n\nfunction wsOpen (event) {\n    console.log(&apos;Connected to: &apos; + event.currentTarget.URL);\n}\n</code></pre><p>关闭 WebSocket 连接，会触发 close 事件。</p>\n<pre><code>connection.onclose = wsClose;\n\nfunction wsClose () {\n    console.log(&quot;Closed&quot;);\n}\n\nconnection.close();\n</code></pre><h4 id=\"发送数据和接收数据\"><a href=\"#发送数据和接收数据\" class=\"headerlink\" title=\"发送数据和接收数据\"></a>发送数据和接收数据</h4><p>连接建立后，客户端通过 send 方法向服务器端发送数据。</p>\n<pre><code>connection.send(message);\n</code></pre><p>除了发送字符串，也可以使用 Blob 或 ArrayBuffer 对象发送二进制数据。</p>\n<pre><code>// 使用ArrayBuffer发送canvas图像数据\nvar img = canvas_context.getImageData(0, 0, 400, 320);\nvar binary = new Uint8Array(img.data.length);\nfor (var i = 0; i &lt; img.data.length; i++) {\n    binary[i] = img.data[i];\n}\nconnection.send(binary.buffer);\n\n// 使用Blob发送文件\nvar file = document.querySelector(&apos;input[type=&quot;file&quot;]&apos;).files[0];\nconnection.send(file);\n</code></pre><p>客户端收到服务器发送的数据，会触发 message 事件。可以通过定义 message 事件的回调函数，来处理服务端返回的数据。</p>\n<pre><code>connection.onmessage = wsMessage;\n\nfunction wsMessage (event) {\n    console.log(event.data);\n}\n</code></pre><p>上面代码的回调函数 wsMessage 的参数为事件对象 event ，该对象的 data 属性包含了服务器返回的数据。</p>\n<p>如果接收的是二进制数据，需要将连接对象的格式设为 blob 或 arraybuffer。</p>\n<pre><code>connection.binaryType = &apos;arraybuffer&apos;;\n\nconnection.onmessage = function(e) {\n      // ArrayBuffer对象有byteLength属性\n      console.log(e.data.byteLength); \n};\n</code></pre><h4 id=\"处理错误\"><a href=\"#处理错误\" class=\"headerlink\" title=\"处理错误\"></a>处理错误</h4><p>如果出现错误，浏览器会触发WebSocket实例对象的error事件。</p>\n<pre><code>connection.onerror = wsError;\n\nfunction wsError(event) {\n    console.log(&quot;Error: &quot; + event.data);\n}\n</code></pre><h3 id=\"服务端-：\"><a href=\"#服务端-：\" class=\"headerlink\" title=\"服务端 ：\"></a>服务端 ：</h3><p>服务器端需要单独部署处理 WebSocket 的代码。下面用 node.js 搭建一个服务器环境。</p>\n<pre><code>var http = require(&apos;http&apos;);\nvar server = http.createServer(function(request, response) {});\n</code></pre><p>假设监听 1740 端口。</p>\n<pre><code>server.listen(1740, function() {\n    console.log((new Date()) + &apos; Server is listening on port 1740&apos;);\n});\n</code></pre><p>接着启动 WebSocket 服务器。这需要加载websocket库，如果没有安装，可以先使用npm命令安装。</p>\n<pre><code>var WebSocketServer = require(&apos;websocket&apos;).server;\nvar wsServer = new WebSocketServer({\n    httpServer: server\n});\n</code></pre><p>WebSocket服务器建立 request 事件的回调函数。</p>\n<pre><code>var connection;\n\nwsServer.on(&apos;request&apos;, function(req){\n    connection = req.accept(&apos;echo-protocol&apos;, req.origin);\n});\n</code></pre><p>上面代码的回调函数接受一个参数 req ，表示 request 请求对象。然后，在回调函数内部，建立WebSocket连接connection。接着，就要对connection的message事件指定回调函数。</p>\n<pre><code>wsServer.on(&apos;request&apos;, function(r){\n    connection = req.accept(&apos;echo-protocol&apos;, req.origin);\n\n    connection.on(&apos;message&apos;, function(message) {\n        var msgString = message.utf8Data;\n        connection.sendUTF(msgString);\n    });\n});\n</code></pre><p>最后，监听用户的 disconnect 事件。</p>\n<pre><code>connection.on(&apos;close&apos;, function(reasonCode, description) {\n    console.log(connection.remoteAddress + &apos; disconnected.&apos;);\n});\n</code></pre><p>使用 <a href=\"https://github.com/websockets/ws\">ws</a> 模块，部署一个简单的 WebSocket 服务器非常容易。</p>\n<pre><code>var WebSocketServer = require(&apos;ws&apos;).Server;\nvar wss = new WebSocketServer({ port: 8080 });\n\nwss.on(&apos;connection&apos;, function connection(ws) {\n      ws.on(&apos;message&apos;, function incoming(message) {\n        console.log(&apos;received: %s&apos;, message);\n      });\n\n      ws.send(&apos;something&apos;);\n});\n</code></pre><h3 id=\"Socket-IO-：\"><a href=\"#Socket-IO-：\" class=\"headerlink\" title=\"Socket.IO ：\"></a>Socket.IO ：</h3><p>Socket.io 是目前最流行的 WebSocket 实现，包括服务器和客户端两个部分。它不仅简化了接口，使得操作更容易，而且对于那些不支持 WebSocket 的浏览器，会自动降为 Ajax 连接，最大限度地保证了兼容性。它的目标是统一通信机制，使得所有浏览器和移动设备都可以进行实时通信。</p>\n<p>第一步，在服务器端的项目根目录下，安装 socket.io 模块。</p>\n<pre><code>$ npm install socket.io\n</code></pre><p>第二步，在根目录下建立 app.js ，并写入以下代码（假定使用了Express框架）。</p>\n<pre><code>var app = require(&apos;express&apos;)();\nvar server = require(&apos;http&apos;).createServer(app);\nvar io = require(&apos;socket.io&apos;).listen(server);\n\nserver.listen(80);\n\napp.get(&apos;/&apos;, function (req, res) {\n      res.sendfile(__dirname + &apos;/index.html&apos;);\n});\n</code></pre><p>上面代码表示，先建立并运行 HTTP 服务器。Socket.io 的运行建立在 HTTP 服务器之上。</p>\n<p>第三步，将 Socket.io 插入客户端网页。</p>\n<pre><code>&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>然后，在客户端脚本中，建立 WebSocket 连接。</p>\n<pre><code>var socket = io.connect(&apos;http://localhost&apos;);\n</code></pre><p>由于本例假定 WebSocket 主机与客户端是同一台机器，所以 connect 方法的参数是 <a href=\"http://localhost。接着，指定\">http://localhost。接着，指定</a> news 事件（即服务器端发送news）的回调函数。</p>\n<pre><code>socket.on(&apos;news&apos;, function (data){\n       console.log(data);\n});\n</code></pre><p>最后，用 emit 方法向服务器端发送信号，触发服务器端的 anotherNews 事件。</p>\n<pre><code>socket.emit(&apos;anotherNews&apos;);\n</code></pre><blockquote>\n<p>请注意，emit 方法可以取代 Ajax 请求，而on方法指定的回调函数，也等同于 Ajax 的回调函数。</p>\n</blockquote>\n<p>第四步，在服务器端的 app.js，加入以下代码。</p>\n<pre><code>//广播信息给除当前用户之外的用户\nsocket.broadcast.emit(&apos;user connected&apos;);\n\n//广播给全体客户端\nio.sockets.on(&apos;connection&apos;, function (socket) {\n      socket.emit(&apos;news&apos;, { hello: &apos;world&apos; });\n      socket.on(&apos;anotherNews&apos;, function (data) {\n        console.log(data);\n      });\n});\n</code></pre><p>上面代码的 io.sockets.on 方法指定 connection 事件（ WebSocket 连接建立）的回调函数。在回调函数中，用 emit 方法向客户端发送数据，触发客户端的 news 事件。然后，再用 on 方法指定服务器端anotherNews 事件的回调函数。</p>\n<blockquote>\n<p>不管是服务器还是客户端，socket.io 提供两个核心方法：<br>emit方法用于发送消息，on方法用于监听对方发送的消息。</p>\n</blockquote>\n<hr>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://javascript.ruanyifeng.com/htmlapi/websocket.html\" title=\"JavaScript标准参考教程\">JavaScript标准参考教程</a></li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj1nm18y20000rmupfirf7tbx","category_id":"cj1nm18ys0002rmup343n0ir7","_id":"cj1nm18z90008rmup3n6aecbt"},{"post_id":"cj1nm18ya0001rmupzfaslaol","category_id":"cj1nm18ys0002rmup343n0ir7","_id":"cj1nm18zc000crmup4xk549hx"},{"post_id":"cj1nm18yy0004rmupgvof88t3","category_id":"cj1nm18ys0002rmup343n0ir7","_id":"cj1nm18zc000ermupcu5gcyzj"},{"post_id":"cj1nm194f000hrmupqka3eyaz","category_id":"cj1nm18ys0002rmup343n0ir7","_id":"cj1nm194t000ormupjj5cpp8w"},{"post_id":"cj1nm194w000qrmup431p5p9g","category_id":"cj1nm18ys0002rmup343n0ir7","_id":"cj1nm1956000wrmupiado4qm9"},{"post_id":"cj1nm194j000jrmupps4k364r","category_id":"cj1nm194t000nrmuplsj3lgbj","_id":"cj1nm1959000zrmupsc2nr99n"},{"post_id":"cj1nm1951000srmupa5cgktfy","category_id":"cj1nm18ys0002rmup343n0ir7","_id":"cj1nm195d0012rmup9yrnuy6d"},{"post_id":"cj1nm1953000urmup62h62w4a","category_id":"cj1nm18ys0002rmup343n0ir7","_id":"cj1nm195g0015rmup3kt610h0"},{"post_id":"cj1nm194s000mrmupycjyis7f","category_id":"cj1nm194t000nrmuplsj3lgbj","_id":"cj1nm195j0018rmupzxmq1uef"},{"post_id":"cj1nm1956000xrmupwt49esz0","category_id":"cj1nm194t000nrmuplsj3lgbj","_id":"cj1nm195m001crmupi6pgg3ca"},{"post_id":"cj1nm19590010rmupyh73492s","category_id":"cj1nm18ys0002rmup343n0ir7","_id":"cj1nm195n001ermupwiqfo9rg"},{"post_id":"cj1nm194u000prmupeurbrz31","category_id":"cj1nm194t000nrmuplsj3lgbj","_id":"cj1nm195p001hrmup0ab9ybe4"},{"post_id":"cj1nm195d0013rmupkhuj552i","category_id":"cj1nm18ys0002rmup343n0ir7","_id":"cj1nm195p001irmuptmz4v7ik"},{"post_id":"cj1nm195h0016rmupa1318s6s","category_id":"cj1nm18ys0002rmup343n0ir7","_id":"cj1nm195q001lrmupkqe53m6z"},{"post_id":"cj1nm195k001armup686b6ayw","category_id":"cj1nm18ys0002rmup343n0ir7","_id":"cj1nm195r001mrmuppjqi4kty"}],"PostTag":[{"post_id":"cj1nm18y20000rmupfirf7tbx","tag_id":"cj1nm18yx0003rmupzwd1oxk5","_id":"cj1nm18z80007rmupkb2ay46g"},{"post_id":"cj1nm18ya0001rmupzfaslaol","tag_id":"cj1nm18z20006rmupi7cgbhgs","_id":"cj1nm18zc000brmupg544bn7c"},{"post_id":"cj1nm18yy0004rmupgvof88t3","tag_id":"cj1nm18zb000armupg6s2ev4d","_id":"cj1nm18zc000frmupmcue6zag"},{"post_id":"cj1nm18yy0004rmupgvof88t3","tag_id":"cj1nm18zc000drmupyi6lbmz3","_id":"cj1nm18zd000grmupnbb7pkpv"},{"post_id":"cj1nm194f000hrmupqka3eyaz","tag_id":"cj1nm194r000lrmup2c93v981","_id":"cj1nm195g0014rmupqrrcfi5q"},{"post_id":"cj1nm194f000hrmupqka3eyaz","tag_id":"cj1nm194y000rrmupte0agh6m","_id":"cj1nm195j0017rmupdgunqhu5"},{"post_id":"cj1nm194f000hrmupqka3eyaz","tag_id":"cj1nm1955000vrmup7vnogppt","_id":"cj1nm195m001brmupe8vxybt1"},{"post_id":"cj1nm194j000jrmupps4k364r","tag_id":"cj1nm195d0011rmup2v8oa0mz","_id":"cj1nm195n001drmupwdxjbzn9"},{"post_id":"cj1nm194s000mrmupycjyis7f","tag_id":"cj1nm195d0011rmup2v8oa0mz","_id":"cj1nm195o001grmupxkfo8j35"},{"post_id":"cj1nm194u000prmupeurbrz31","tag_id":"cj1nm195d0011rmup2v8oa0mz","_id":"cj1nm195q001krmupy7ppiuuk"},{"post_id":"cj1nm194w000qrmup431p5p9g","tag_id":"cj1nm195p001jrmuptiv4zsn8","_id":"cj1nm195u001prmupk5rv7sv2"},{"post_id":"cj1nm194w000qrmup431p5p9g","tag_id":"cj1nm195s001nrmupdd3ugxie","_id":"cj1nm195v001qrmupgiofojkn"},{"post_id":"cj1nm1951000srmupa5cgktfy","tag_id":"cj1nm195u001ormup6tr8jzp4","_id":"cj1nm195v001srmupxtjnwjgk"},{"post_id":"cj1nm1953000urmup62h62w4a","tag_id":"cj1nm195v001rrmupgpvj9t7a","_id":"cj1nm195x001vrmup3h9tnwvc"},{"post_id":"cj1nm1953000urmup62h62w4a","tag_id":"cj1nm195v001trmupjd509axp","_id":"cj1nm195x001wrmuphsk2ukd8"},{"post_id":"cj1nm1956000xrmupwt49esz0","tag_id":"cj1nm195d0011rmup2v8oa0mz","_id":"cj1nm195y001yrmupp84cnqht"},{"post_id":"cj1nm19590010rmupyh73492s","tag_id":"cj1nm18zb000armupg6s2ev4d","_id":"cj1nm195z0020rmups5sc7an4"},{"post_id":"cj1nm19590010rmupyh73492s","tag_id":"cj1nm195x001xrmupei79abm5","_id":"cj1nm195z0021rmupcv84r776"},{"post_id":"cj1nm195d0013rmupkhuj552i","tag_id":"cj1nm195z001zrmuplas09uyp","_id":"cj1nm19600023rmup5q4h6yhf"},{"post_id":"cj1nm195h0016rmupa1318s6s","tag_id":"cj1nm195v001rrmupgpvj9t7a","_id":"cj1nm19620027rmup68lnb7cq"},{"post_id":"cj1nm195h0016rmupa1318s6s","tag_id":"cj1nm19600024rmupvb3j1yzy","_id":"cj1nm19620028rmup1lbmjd99"},{"post_id":"cj1nm195h0016rmupa1318s6s","tag_id":"cj1nm19610025rmupgacxijf2","_id":"cj1nm1963002armupv6vmu3nq"},{"post_id":"cj1nm195k001armup686b6ayw","tag_id":"cj1nm19620026rmupzexlyg48","_id":"cj1nm1963002brmupjbubea4d"},{"post_id":"cj1nm195k001armup686b6ayw","tag_id":"cj1nm19620029rmup625svx6j","_id":"cj1nm1964002crmupn8l2sbco"}],"Tag":[{"name":"nvm","_id":"cj1nm18yx0003rmupzwd1oxk5"},{"name":"gulp","_id":"cj1nm18z20006rmupi7cgbhgs"},{"name":"c","_id":"cj1nm18zb000armupg6s2ev4d"},{"name":"ssl","_id":"cj1nm18zc000drmupyi6lbmz3"},{"name":"mongoLab","_id":"cj1nm194r000lrmup2c93v981"},{"name":"redis4You","_id":"cj1nm194y000rrmupte0agh6m"},{"name":"heroku","_id":"cj1nm1955000vrmup7vnogppt"},{"name":"个人日志","_id":"cj1nm195d0011rmup2v8oa0mz"},{"name":"Mac","_id":"cj1nm195p001jrmuptiv4zsn8"},{"name":"mount","_id":"cj1nm195s001nrmupdd3ugxie"},{"name":"MEAN","_id":"cj1nm195u001ormup6tr8jzp4"},{"name":"node","_id":"cj1nm195v001rrmupgpvj9t7a"},{"name":"debug","_id":"cj1nm195v001trmupjd509axp"},{"name":"DNS","_id":"cj1nm195x001xrmupei79abm5"},{"name":"redis","_id":"cj1nm195z001zrmuplas09uyp"},{"name":"schedule","_id":"cj1nm19600024rmupvb3j1yzy"},{"name":"cron","_id":"cj1nm19610025rmupgacxijf2"},{"name":"websocket","_id":"cj1nm19620026rmupzexlyg48"},{"name":"socket.io","_id":"cj1nm19620029rmup625svx6j"}]}}